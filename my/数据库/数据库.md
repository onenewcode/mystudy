# 认识数据库
## 数据库系统的目标
- 数据的冗余和不一致
- 数据访问的困难
- 数据孤立
- 完整新问题
- 原子性问题
- 并发访问异常
- 安全性问题
## 视图
### 数据抽象
- 物理层 最低层次的抽象，数据是怎么存储的
- 逻辑层 描述数据库中存储什么数据以及数据之间存在什么关系
- 视图层 只描述数据库中的某个部分
<img src="img\屏幕截图 2022-12-14 084424.png">

###  实例和模式
特定时间存储在数据库中的信息集合称为数据库的一个**实例**；
数据库的总体设计称作数据库的**模式**、

物理模式物理层，逻辑模式逻辑层，视图层，子模式
应用程序如果不依赖物理模式，它们就被称为具有**物理数据独立性**

### 数据模型
- 关系模型 关系模型用表的集合来表示数据与数据之间的关系
- 实体-联系模型 （E-R）
- 基于对象的数据模型 面向对象的程序设计，可以看作是对E-R模型增加封装
- 半结构化数据模型 半结构化数据模型允许相同类型的数据项含有不同的属性集的数据定义。
# 关系数据库
## 关系型数据库模式
数据库模式 是数据库的逻辑设计
数据库实例 是数据库的一个快照
## 码
**超码**：一个或多个属性的集合，这些属性的组合可以使我们在一个关系中唯一的标识一个元组；
**候选码** 一个超码的任意真子集都不能成为超码，这样的最小超码叫候选码
**主码** 用来在一个关系中区分不同元组的候选码。
### 模式图
 一个含有主码和外码依赖的数据库可以用模式图来表示。
<img src="img\屏幕截图 2022-12-14 090909.png">

## 关系运算
<img src="img\屏幕截图 2022-12-14 091038.png">


# SQL
**数据库定义（DDL）**
**数据库操作（DML）**:CRUD功能
**完整性（integrity）** 
**视图定义（view definition）**
**事务控制（transaction）**
**嵌入式sql和动态sql(embeded sql and dynamic sql)**
**授权**
## 匹配
### 正则 REGEXP

    1. 匹配两个字符串其中之一
    REGEXP（'1000|2000')
    1. 匹配几个字符串
    '[123]ton'
    1. 匹配范围
    [0-9],[a-z]

```cmd
[:alnum:] 任意字母和数字（同[a-zA-Z0-9]）
[:alpha:] 任意字符（同[a-zA-Z]）
[:blank:] 空格和制表（同[\\t]）
[:cntrl:] ASCII控制字符（ASCII 0到31和127）
[:digit:] 任意数字（同[0-9]）
[:graph:] 与[:print:]相同，但不包括空格
[:lower:] 任意小写字母（同[a-z]）
[:print:] 任意可打印字符
[:punct:] 既不在[:alnum:]又不在[:cntrl:]中的任意字符
[:space:] 包括空格在内的任意空白字符（同[\\f\\n\\r\\t\\v]）
[:upper:] 任意大写字母（同[A-Z]）
[:xdigit:] 任意十六进制数字（同[a-fA-F0-9]）
* 0个或多个匹配
+ 1个或多个匹配（等于{1,}）
? 0个或1个匹配（等于{0,1}）
{n} 指定数目的匹配
{n,} 不少于指定数目的匹配
{n,m} 匹配数目的范围（m不超过255）
^ 文本的开始
$ 文本的结尾
[[:<:]] 词的开始
[[:>:] 词的结尾
```
## 创建计算字段

1. CONCAT(字段，字段)，
   中间还可以添加字符串表示格式，也可以用trim（）取消左右的空格

## 函数

### 文本函数

```sql
    Left() 返回串左边的字符
    Length() 返回串的长度
    Locate() 找出串的一个子串
    Lower() 将串转换为小写
    LTrim() 去掉串左边的空格
    Right() 返回串右边的字符  
    RTrim() 去掉串右边的空格
    Soundex() 返回串的SOUNDEX值
    SubString() 返回子串的字符
    Upper() 将串转换为大写  
```

SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法SOUNDEX考虑了类似的发音字符和音节，使得能对串进行发音比较而不是字母比较

### 日期函数

```sql
AddDate() 增加一个日期（天、周等）
AddTime() 增加一个时间（时、分等）
CurDate() 返回当前日期
CurTime() 返回当前时间
Date() 返回日期时间的日期部分
DateDiff() 计算两个日期之差
Date_Add() 高度灵活的日期运算函数
Date_Format() 返回一个格式化的日期或时间串
Day() 返回一个日期的天数部分
DayOfWeek() 对于一个日期，返回对应的星期几
Hour() 返回一个时间的小时部分
Minute() 返回一个时间的分钟部分
Month() 返回一个日期的月份部分
Now() 返回当前日期和时间
Second() 返回一个时间的秒部分
Time() 返回一个日期时间的时间部分
Year() 返回一个日期的年份部分
```

不管是插入或更新表值还是用WHERE子句进行过滤，日期必须为
格式yyyy-mm-dd

### 数值函数

```sql
Abs() 返回一个数的绝对值
Cos() 返回一个角度的余弦
Exp() 返回一个数的指数值
Mod() 返回除操作的余数
Pi() 返回圆周率
Rand() 返回一个随机数
Sin() 返回一个角度的正弦
Sqrt() 返回一个数的平方根
Tan() 返回一个角度的正切
```

### 聚集函数

```sql
AVG() 返回某列的平均值
COUNT() 返回某列的行数
MAX() 返回某列的最大值
MIN() 返回某列的最小
```

### 分组函数

**group**
 GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套，
为数据分组提供更细致的控制。
 如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组上
进行汇总。换句话说，在建立分组时，指定的所有列都一起计算
（所以不能从个别的列取回数据）。
 GROUP BY子句中列出的每个列都必须是检索列或有效的表达式
（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在
GROUP BY子句中指定相同的表达式。不能使用别名。
 除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子
句中给出。
 如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列
中有多行NULL值，它们将分为一组。
 GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。
**having**

```sql
SELECT 要返回的列或表达式 是
FROM 从中检索数据的表 仅在从表选择数据时使用
WHERE 行级过滤 否
GROUP BY 分组说明 仅在按组计算聚集时使用
HAVING 组级过滤 否
ORDER BY 输出排序顺序 否
LIMIT 要检索的行数 否
```
## 全文本搜索

并不是所有引擎都支持全文本搜索（MyISAM支持）
CREATE TABLE语句定义表productnotes并列出它所包含的列
即可。这些列中有一个名为note_text的列，为了进行全文本搜索，
MySQL根据子句FULLTEXT(note_text)的指示对它进行索引。这里的
FULLTEXT索引单个列，如果需要也可以指定多个列。
索引之后，使用两个函数Match()和Against()执行全文本搜索，
其中Match()指定被搜索的列，Against()指定要使用的搜索表达式。

使用完整的 Match() 说 明 传递给 Match() 的值必须与
FULLTEXT()定义中的相同。如果指定多个列，则必须列出它
们（而且次序正确）。
搜索不区分大小写 除非使用BINARY方式（本章中没有介绍），
否则全文本搜索不区分大小写

## 存储过程

 通过把处理封装在容易使用的单元中，简化复杂的操作（正如前
面例子所述）。
 由于不要求反复建立一系列处理步骤，这保证了数据的完整性。
如果所有开发人员和应用程序都使用同一（试验和测试）存储过
程，则所使用的代码都是相同的。
这一点的延伸就是防止错误。需要执行的步骤越多，出错的可能
性就越大。防止错误保证了数据的一致性。
 简化对变动的管理。如果表名、列名或业务逻辑（或别的内容）
有变化，只需要更改存储过程的代码。使用它的人员甚至不需要
知道这些变化。
这一点的延伸就是安全性。通过存储过程限制对基础数据的访问减
少了数据讹误（无意识的或别的原因所导致的数据讹误）的机会。
 提高性能。因为使用存储过程比使用单独的SQL语句要快。
 存在一些只能用在单个请求中的MySQL元素和特性，存储过程可
以使用它们来编写功能更强更灵活的代码（在下一章的例子中可
以看到。

**例子：**

```sql
CREATE PROCEDURE pp(OUT p1 DECIMAL(8,2) ) COMMENT
'cdc'
#DELETE表示分割字符，第一个数表示有几位数，第二个表示小数点后保留几位；
#out 表示存储过程中输出的值
#in表示存储过程传入的值
BEGIN 
DECLARE topss INT;#定义自变量
SELECT AVG(s.price) INTO p1 FROM tb_order s;
END;
CALL pp(@p4);#给输出的值重命名，必须带@
SELECT @p4;#查找输出的值
DROP PROCEDURE pp;
SHOW PROCEDURE STATUS;
#列出所有存储过程。为限制其输出，可使用LIKE指定一个过滤模式
```
COMMENT关键字 本例子中的存储过程在CREATE PROCEDURE语
句中包含了一个COMMENT值。它不是必需的，但如果给出，将
在SHOW PROCEDURE STATUS的结果中显示。
```sql
create procedure kaka(out count int,
in num INT)
begin
	declare v1 int(11) default 1;
	declare v2 int(11) default 0;
	while v1 < num do
		set v2 = v2 + v1;
		set v1 = v1 + 1;
	end while;
	set count = v2;
end

call kaka(@count,10);
#@count 是sql中的变量
select @count;
drop PROCEDURE kaka;

```
## 事务
 事务（transaction）指一组 SQL 语句；
 回退（rollback）指撤销指定 SQL 语句的过程；
 提交（commit）指将未存储的 SQL 语句结果写入数据库表；
 保留点（savepoint）指事务处理中设置的临时占位符（placeholder），
可以对它发布回退（与回退整个事务处理不同）
```sql
BEGIN ;
DELETE FROM tb_order WHERE tb_order.id=101;
COMMIT ;
ROLLBACK;#只能回滚未提交的事物
```
## 游标
    
 能够标记游标为只读，使数据能读取，但不能更新和删除。
 能控制可以执行的定向操作（向前、向后、第一、最后、绝对位置和
相对位置等）。
 能标记某些列为可编辑的，某些列为不可编辑的。
 规定范围，使游标对创建它的特定请求（如存储过程）或对所有请求
可访问。
 指示 DBMS 对检索出的数据（而不是指出表中活动数据）进行复制，
使数据在游标打开和访问期间不变化。
```sql
CREATE PROCEDURE pp() 
BEGIN 
DECLARE o int;
DECLARE done BOOLEAN  DEFAULT 0;
DECLARE oppp CURSOR
FOR
SELECT s.price FROM tb_order s;
OPEN oppp;
FETCH oppp INTO o; #遍历
close oppp;
END;
DROP PROCEDURE pp;
SHOW PROCEDURE STATUS;
```
## 触发器
```sql
CREATE TRIGGER trigger_name AFTER|BEFORE INSERT|UPDATE|DELETE ON table_name
FOR EACH ROW -- 行级触发器
BEGIN
	... -- 具体执行语句
END
 -- 代表创建触发器语句结束，这样就不会执行到分号;的时候暂停执行了。
;
```
1.new.字段的值可以在before类型的触发器中进行赋值和取值，在after类型触发器中只能取值。(在after类型触发器中进行对new数据行赋值操作会报错。因为after是在操作之后，已经产生了新数据行，不可修改。)
2.在insert操作中，只有new数据行，没有old数据行。(使用old关键字会报错)
3.在update操作中，new数据行和old数据行存在。
4.在delete操作中，只有old数据行。(使用new关键字会报错)
触发器自定抛出异常
```sql
CREATE TRIGGER checkeage BEFORE INSERT ON expert
FOR EACH ROW -- 行级触发器
BEGIN
	DECLARE msg varchar(200);
IF NEW.age<0 and NEW.Sage>100
THEN 
SET msg="fss";
 END if;
END;
```
例子
**必要信息**
 唯一的触发器名；
 触发器关联的表；
 触发器应该响应的活动（DELETE、INSERT或UPDATE）；
 触发器何时执行（处理之前或之后）
INSERT触发器在INSERT语句执行之前或之后执行。需要知道以下几
点：
 在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被
插入的行；
 在BEFORE INSERT触发器中，NEW中的值也可以被更新（允许更改
被插入的值）；
 对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT
执行之后包含新的自动生成值
## 索引
 索引改善检索操作的性能，但降低了数据插入、修改和删除的性能。
在执行这些操作时，DBMS 必须动态地更新索引。
 索引数据可能要占用大量的存储空间。
 并非所有数据都适合做索引。取值不多的数据（如州）不如具有更多
可能值的数据（如姓或名），能通过索引得到那么多的好处。
 索引用于数据过滤和数据排序。如果你经常以某种特定的顺序排序数
据，则该数据可能适合做索引。
 可以在索引中定义多个列（例如，州加上城市）。这样的索引仅在以州
加城市的顺序排序时有用。如果想按城市排序，则这种索引没有用处
```sql
CREATE INDEX prod_name_ind
ON Products (prod_name);
分析▼
索引必须唯一命名。这里的索引名 prod_name_ind 在关键字 CREATE 
INDEX 之后定义。ON 用来指定被索引的表，而索引中包含的列（此例中
仅有一列）在表名后的圆括号中给出
```
## 异常
## 自定义函数
创建自定义函数
```sql
DELIMITER $$
DROP FUNCTION IF EXISTS genPerson$$
CREATE FUNCTION genPerson(name varchar(20)) RETURNS varchar(50)
BEGIN
  DECLARE str VARCHAR(50) DEFAULT '';
  SET @tableName=name;
  SET str=CONCAT('create table ', @tableName,'(id int, name varchar(20));');
  return str;
END $$
```
DELIMITER ;
   （1）DELIMITER $$  定义结束符。MySQL默认的结束符是分号，但是函数体中可能用到分号。为了避免冲突，需要另外定义结束符。

   （2）DROP FUNCTION IF EXISTS genPerson$$  如果函数genPerson已经存在了，就删除掉。

   （3）CREATE FUNCTION 创建函数genPerson，函数的参数是name，返回值是varchar(50)。

   （4）函数体放在BEGIN 与 END之间。

   （5）DECLARE 声明变量，str类型是varchar(50)，默认值是空。

   （6）CONCAT连接多个字符串。

   （7）RETURN 返回拼接后的字符串str。
## 约束

```sql

1.主键约束
添加:alter table  table_name add primary key (字段)
删除:alter table table_name drop primary key
2.非空约束
添加:alter  table table_name modify 列名 数据类型  not null 
删除:alter table table_name modify 列名 数据类型 null
3.唯一约束
添加:alter table table_name add unique 约束名（字段）
删除:alter table table_name drop key 约束名
4.自动增长
添加:alter table table_name  modify 列名 int  auto_increment
删除:alter table table_name modify 列名 int  
5.外键约束
添加:alter table table_name add constraint 约束名 foreign key(外键列) 
references 主键表（主键列）
删除:
第一步:删除外键
alter table table_name drop foreign key 约束名
第二步:删除索引
alter  table table_name drop  index 索引名
[^1]: 
约束名和索引名一样
6.默认值
添加:alter table table_name alter 列名  set default '值'
删除:alter table table_name alter 列名  drop default
7.检查约束
alter table table_name add constraint 列名 check(m_id>10);//命令
ALTER TABLE `表名` DROP CHECK 约束名;
```
## 联级约束
```sql
#删除级联
ALTER TABLE emp ADD FOREIGN KEY(did) REFERENCES dept(id) ON DELETE CASCADE

# 权限控制

   ```
### 用户权限
```sql
#创建用户n
CREATE USER user1@localhost 
IDENTIFIED BY '12345';
CREATE USER  user2@localhost 
IDENTIFIED BY '12345';
#查看权限
SHOW GRANTS FOR user1@localhost;
SELECT * FROM mysql.user;
#删除用户
DELETE FROM `user` WHERE `user`.`User`="dbadmin"; 
#
GRANT SELECT on myspj.s TO 'user1'@'localhost' IDENTIFIED by '12345';
#不用加密码，管理员
grant SELECT on myspj.s to 'user1'@'localhost' ; 
GRANT all ON myspj.s to 'user2'@'localhost' ; 
#移除权限
REVOKE UPDATE,DELETE,INSERT ON myspj.s FROM' user2'@'localhost' ;
grant SELECT on myspj.s to 'user1'@'localhost' ; 
```
# 数据库设计
## 数据库设计和实体——联系模型
### 实体——联系模型
**实体——(entity-ralationship，E——R)**数据模型提出旨在方便数据库的设计，他是通过允许定义代表数据库的全局逻辑结构的企业模式实现的。
**实体集**是相同类型即具有相同性质（或属性）的一个实体集合。
**联系集**相同类型联系的集合
**联系** 多个实体间的相互关联。
要避免数据冗余和数据不完整
<img src="img\屏幕截图 2022-11-11 193415.png">

**属性** : 每一个属性都有一个可取值得集合，称为该属性的域
### 属性划分
**简单和符合属性** 简单的不能再划分，复合的属性还能在划分。
**单值和多指** 
**派生**  可以从别的相关属性或实体派生出来。
### 约束
**映射基数** 表示一个实体通过一个联系集能关联的实体的个数。
类型： 一对一，一对多，多对多，多对一
### E-R图
主要部件
**分成两部分的矩形**代表实体集
**菱形**代表联系集
**为分割的矩形**代表联系集的属性
**线段**将实体集连接到联系集
**虚线**将联系集连接到联系集
**双线**显示实体在联系集中的参与度
**双菱形**代表弱实体集的标志性联系集
**弱实体集** 没有足够的属性形成主码
**强实体集** 有主码的实体集
**映射图**
<img src="img\屏幕截图 2022-12-14 093304.png">


### 扩展E-R特性
**特化** 在实体集内部进行分组的过程

在E-R图描述特化的方法取决于一个实体集是否可能属于多个特化实体集或者它们是否必须属于至多一个特化实体集。前者成为**重叠特化**，后者（允许之多一个）成为**不相交特化**。
**概化** 从初始实体集到一系列不同层次的实体自己的细化代表了一个自顶向下的设计过程
#### 概化上的约束
**条件定义的**  条件定义的底层实体集中，成员资格的确定基于实体是否满足一个显示的条件或谓词。
**用户定义的**由数据库用户将实体指派给某个实体集。
**不相交**不相交约束要求一个实体至多属于一个底层实体集。
**重叠** 同一实体可以同时属于同一个概化中的多个低层实体集。
**部分概化**每个高层实体必须属于一个底层实体
##### 转化为图示关系
- 为高层实体集创建一个模式，为每一个低层实体集创建一个模式，模式中的属性包括对应低层实体集的每个属性，以及对应于高层实体集主码的每个属性。
- 如果概化是不相交且完全的————如果不存在输入两个同级的低层实体集的实体，如果高层实体集的任何实体也都是某个低层实体集的成员
<img src="img\屏幕截图 2022-12-14 094245.png">
<img src="img\屏幕截图 2022-12-14 094314.png">

### 数据建模的其他表示法
#### 统一建模语言UML
- 类图 类图和E-R图相似。
- 用况图 说明了用户和系统之间的交互，特别是用户执行的任务中的每一步操作。
- 活动图 说明了系统不同部分之间的任务流
- 实现图 实现图在软件层和硬件构件说明了系统的各个组成部分以及它们之间的联系
## 关系数据库设计
### 原子域和第一范式
在关系模型中，我们将属性不具有任何子结构这个思想形式化。一个域是**原子的**，如果该域的元素被认为是不可分割的单元。称关系模式R属于**第一范式**。
### Boyce-Codd范式
bcnf范式消除所有基于函数依赖能够发现的冗余。具有函数依赖集F的关系模式R属于BCNF的条件是，对F`中所有形如a->b的函数依赖（a属于R，b属于R），下面至少有一项成立：
- a->b是平凡的函数依赖（b属于a）
- a是模式R的一个超码

### 第三范式
第三范式条件，对F`中所有形如a->b的函数依赖（a属于R，b属于R），下面至少有一项成立：
- a->b是平凡的函数依赖（b属于a）
- a是模式R的一个超码
- b-a中的每个属性A都包含于R的一个候选码中

# 数据的储蓄和查询
## 索引与散列表
基本索引类型 顺序索引和散列索引
通常需要在一个文件上建立多个索引。例如，可能按作者，主题或者书名来查找一本书。

# 事务管理
## 事务
数据库保证事务正常执行叫事务的**隔离性**。
事务的语句只能全执行或全不执行**原子性**。
保证数据改变后逻辑不变**一致性**。
事务完成后数据要保存在数据库**持久性**。
### 存储结构
**易失性存储器**系统崩溃后不存在。
**非易失性存储器** 系统崩溃后幸存。
**稳定性存储器** 稳定性存储器中的信息永远不会丢失。

### 可串行化
在并发执行中，通过保证所执行的任何调度的效果都与没有并发的调度效果一样，这种调度称为可串行化

### 事务隔离级别
- **可串行化**：通常保证可串行化调度
- **可重复读**：只允许读取已提交的事务，而且在一个事务两次读取一个数据项时，其他事务不得更新该数据。但该事务不要求与其他事务可串行化。
-  **已提交读**： 只允许读取已提交的数据但不要求可重复读
- **未提交读**；允许读取未提交数据；
 
###  隔离级别的实现
1. **锁**
一个事务可以封锁其访问的数据项，而不用封锁整个数据库。
2. **时间戳**
为每个事务分配一个时间戳，通常是当它开始的时候。
3. **多版本和快照隔离**

## 并发控制

