# 计算机三大原则
1. 计算机是执行输入、运算、输出的机器
2. 程序是指令和数据的集合
3. 计算机的处理方式有时与人们的思维习惯不同
# 计算机系统漫游
## 程序被其他程序翻译成不同的格式
gcc -o hello hello.c
<img src="img\屏幕截图 2022-11-06 210202.png">

- **预处理阶段**
  预处理器（cpp）根据以字符#开头的命令，修改原始C程序。
- **编译阶段**
  编译器（ccl）将文本hello.i翻译成hello.s包含一个汇编语言程序
  <img src="img\屏幕截图 2022-11-06 210924.png">
- **汇编阶段**
   翻译成机器语言，把这些指令打包成叫可重定位目标的程序的格式（二进制文件）。
-**链接阶段**
    printf函数，他是每个c编译器都提供的标准函数，存在printf.o的单独的预编译好的文件中，这个文件必须与某种方法合并到我们的hello.o程序中。链接器（ld）就负责处理这种合并。

## 硬件
1. 总线
    贯穿系统的电子管道，携带字节在不同部件传递信息（32位）4字节，
2. I/O设备
    I/O（输入/输出）设备是系统与外界联系的通道。（例子：鼠标，显示器）每个I/O设备通过控制器或适配器与I/O总线相连。（ps：控制器与适配器主要区别在于封装方式。控制器是I/O本身或者印在主板上的芯片组上，适配器插在主板插槽的卡）。
3. 主存
    临时储存设备，在处理程序时，用来存放程序和程序处理的结果。从物理来说，主存由一组动态随机取存储器（DRAM）芯片组成。从逻辑上讲，存储器是一个线性字节数组，每一个字节都有唯一的地址，这些地址都是从零开始的。
4.  处理器
    中央处理单元（CPU）。处理器的核心是一个大小为一个字的存储设备（或寄存器），成为程序计数器（PC），在任何时刻，PC都指向主存中的某条机器语言指令（及含有该指令的地址）。
    cpu在通电后一直不断地执行程序计数器指向的指令，再更新计数器。这个模型是由指令集决定的。
    这样的操作并不多，它们围绕着主存，寄存器文件和算数/逻辑单元（ALU）进行。寄存器文件是一个小的储存设备，有一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU计算新的数据和地址值。
    -加载： 从主存复制一个字节或者一个字到寄存器，
    覆盖原来的内容
    -存储：从寄存器复制一个字节或者一个字到主存，
    覆盖原来的内容 
    -操作：把两个寄存器的内容复制到ALU，ALU对这两个字做算数运算,并将结果放在寄存器中，已覆盖寄存器中原来的内容
<img src="img\屏幕截图 2022-10-30 170948.png" />

**运行hello程序** 
首先将键盘输入的启动字符读入寄存器，再把它放入内存，把编译的文件加载入主存，一旦代码和数据加载如主存，处理器就开始执行hello程序中的main程序中的机器语言指令。这些指令把主存中的程序复制到寄存器，再从寄存器复制发到显示屏上。
## 高速缓存重要性
系统花费大量时间把信息从一个地方复制到另一个地方，减缓了程序的运行时间。
根据机器原理，大的存储设备比小的慢，针对处理器和主存的差异，系统设计者采取更小更快的初春设备，高速缓存器（cache memory），作为暂时集结趋于，存放处理器近期可能会需要的信息。L1位于处理器芯片上，L2 采用静态随机访问存储器（SRAM）。

<img src="img\屏幕截图 2022-10-30 211948.png"  /> 
<img src="img\屏幕截图 2022-10-30 213345.png" /> 

## 操作系统管理硬件
    操作系统的基本功能：
    1. 防止硬件被失控的应用程序滥用
    2. 向应用程序提供简单一直的机制来控制复杂的而又通常大不相同的低级硬件设备 （文件是对I/O设备的抽象，虚拟内存是对主存和磁盘I/O设备的抽象表示，进程是对处理器，主存和I/O设备的抽象）
1. 进程
进程是操作系统对一个正在运行的程序的抽象。一个系统上。系统同时并发运行（一个进程和另一个进程的指令交错运行）。cpu看上去是在并发的执行进程，实际是通过处理器在进程之间切换来实现的，这种机制叫 **上下文切换 **
<img src="img\屏幕截图 2022-10-31 072343.png">

2. 线程
一个进程有多个线程执行单元组成，每个线程都运行在进程的上下文中，，并共享同样的代码和全局数据。由于网络服务对并行的需求，线程成为越来越重要的编程模型，多线程之间比多进程间更容易共享数据，线程一般比进程更高效。
3. 虚拟内存
 虚拟内存是一个抽象概念，它为每个个进程提供一个假象，即每个进程都在独占使用主存。每个进程看到的内存是一致的，成为虚拟地址空间。
 <img src="屏幕截图 2022-10-31 075731.png">

    介绍各个区
    程序代码和数据：对所有的进程来说，代码是从同一固定的地址开始，紧接着的是和C全局变量对应的数据位置。代码和数据区是直接按照可执行文件初始化的。
    堆 ： 代码和数据区紧跟着的是运行时堆。
    共享库：大约在地址空间的中间部分是一块用来存放像C标准库和数学库这样的共享的代码和数据区域。
    栈：位于用户虚拟地址的顶部是用户栈，编译器用它来实现函数调用。
    内核虚拟内存：地址空间顶部的区域时为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，他们必须调用内核来执行这些操作。虚拟内存的运作需要硬件和操作系统软件之间复杂的交互，包括对处理器生成每个地址的硬件翻译。
4. 文件
   文件就是字节序列，仅此而已。每个I/O设备都可以看成文件。  文件这个简单而精致的概念是非常强大的，他向应用程序提供了一个统一的视图，来看待系统中的各种各样分I/O设备。例如：同一个程序可以在使用不同的 磁盘技术的不同系统上运行
## 系统之间利用网络通信    
    网络也可以看作一种I/O设备
<img src="屏幕截图 2022-10-31 083919.png">

## 小结
    1. Amdahl定律：想要显著加速整个系统，必须提升全系统中相当大部分的速度。
    2. 并发和并行
    并发是指一个同时具有多个活动的系统；
    并行指用并发使一个系统运行的更快
     1.线程级并发
        使用线程，使我们能在一个进程中执行多个控制流
<img src="img\屏幕截图 2022-10-31 112941.png">
        超线程，又称为多线程，是允许CPU实行多个控制流的技术。他从两方面提高了系统的性能。首先他减少了在执行任务时模拟并发的需求。其次，但可以是程序运行的更快（要用多线程开发）。
     2.指令级并行
        在比较低的抽象层次上，现代处理器可以同时执行多条指令   的属性成为指令级并行
     3. 单指令，多数据并行
        在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令，产生多个可以执行的操作，这种方式成为单指令，多数据（SIMD）并行。  

    3.抽象
<img src="img\屏幕截图 2022-10-31 131723.png">

# 信息处理表示
## 信息存储
   大多数计算机使用16位的块，或者字节，作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的数组，成为虚拟内存。内存的每个字节都有一个唯一的数字来标识，称它为地址，所有可能地址的集合就成为虚拟地址空间。顾名思义，这个虚拟地址空间只是展示给机器级程序的概念性印象。实际的实现是将动态随机访问的存储器（DRAM），闪存，磁盘存储器，特殊硬件和操作系统软件结合起来，为程序提供看上去统一的字节数组。
   1. 十六进制表示法
    一个字节有八位组成，在二进制表示法中它的值域是00000000-111111111，在十进制中，0-255。0-9，a-f表示十六进制（hex）。
   2. 字数据大小
    每台计算机都有一个字长，指明指针数据的大小。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数是虚拟地址空间的大小。32（4g），64（16g） 
    3. 寻址和字节顺序
       对于跨字节的程序对象，我们必须建立两个规则：这个对象的地址是什么，以及在内存中如何排列这些字节
    4. 表示字符串
      C语言中的字符串被编码为一个一null（值为0）的字符结尾的字符数组。每个字符都有某个标准的编码来表示/
    5. 表示代码
        不同的平台指令编码不同，二进制代码很少能在不同的操作系统间移植
    6. 布尔代数简介    
        最简单的布尔代数是在二元集合{0，1}基础上定义的，
## 整数表示        
1.        无符号编码具有唯一性
2. 补码编码   
   最常见的有符号数的计算机表示方式是补码
3. 有符号数和无符号数之间的转换，
## 浮点数

# 程序的机器级表示
## 程序编码
``sh
gcc -Og -o` p p1.c
```
产生符合原始c代码的整体结构的机器代码
实际上gcc命令调用了一整套的程序，将源代码转化成可执行代码。首先，C预处理器扩展源码，插入所有用#include命令指定的文件，并拓展所有用#define声明指定的宏。接下来，汇编器会将汇编代码转换成二进制文件，但是还没有填入全局值的地址。最后，链接器将目标文件与实现库函数（例如printf）的代码合并，并产生最终的可执行代码文件。

1. 程序编码
gcc指GCC C编译器，linux上默认的编译器，编译选项-og告诉编译器使用会生成符合原始C代码整体结构的机器代码优化等级
2. 机器级代码
 对于机器级编程，其中两种抽象尤其重要，第一种是由指令集体系结构或指令集架构来定义机器级程序的格式和行为，它定义了处理器状态，指令的格式，以及每条指令对状态的影响。第二种，机器级程序使用的内存地址是虚拟地址，提供内存模型看上去是非常大的字节数组。
    -**程序计数器（pc）**给出将要执行下一条指令在内存中的地址
    -**整数寄存器文件** 包含16个命名位置，分别储存64位的值，这些寄存器可以储存地址和整数数据。有的寄存器被用来纪录某些重要的程序状态，而其他寄存器用来保存临时数据。
    -**条码机寄存器**保存最近执行的算术或逻辑指令的状态，信息，它们用来实现控制或数据流中条件的变化（如if，while）
    -**一组向量寄存器**可以存放一个或多个整数或浮点数
``sh
gcc -Og -S p p1.c
#产生汇编文件
gcc -Og -c p p1.c
#产生二进制文件，的十六进制格式
```
### 数据格式
<img src="img\屏幕截图 2022-11-03 090029.png">

### 访问信息
一个x86-64的中央处理单元（cpu）包含一组16个储存64位值的通用目的的寄存器。
<img src="img\屏幕截图 2022-11-09 193549.png">

### 操作符指示数
  大多数指令有一个或多个操作数，指示出执行操作中要使用的源数据的值，以及放置结果的位置。源数据的值可以以常数形式给出，或是从寄存器或是从内存读出。结果可以存放在寄存器或内存中。
  - 立即数（immediate）:用来表示常数值
  - 寄存器（register）:表示某个寄存器的内容。16个寄存器的1，2，4或8字节中的一个作为操作数，分别对应8，16，32，64位。
  - 内存引用:它会根据计算出的地址（通常成为有效地址）访问某个内存位置。
  <img src="img\屏幕截图 2022-11-03 091521.png">
2. 数据传送指令
 大多数指令由一个或多个操作数，指示出源数据的值，以及放置结果的的目的的位置。
   <img src="img\屏幕截图 2022-11-03 091745.png">

### 压入和弹出栈数据

<img src="\img\屏幕截图 2022-11-09 201034.png">

## 算数和逻辑操作

<img src="img\屏幕截图 2022-11-09 201509.png">

1. 加载有效地址
 加载有效地址（load effective address）指令leaq实际上是movq的变形。它的第一个操作数看上去是一个内存的引用，但该指令并不是从指定的位置读入数据，而是将有效的地址写入到目的地的操作数。
2. 一元和二元操作
- 一元操作 只有一个操作数，既是源又是目的。这个操作数可以是一个寄存器，也可以是一个内存位置。
- 二元操作: 二元操作第二个数既是源又是目的。注意:当第二个操作数为内存地址时，处理器必须从内存中读出值，执行操作，再把结果写回内存。
## 控制
### 条件码
1. **条件码整数寄存器**  它们描述了最近的算数或逻辑操作的属性。
- CF:进位标志。最近的操作使最高位产生了进位。可以来检查无符号操作的溢出
- ZF:零标志。最近操作得到的结果为0
- SF:符号标志，最近操作得到的结果为负数。
- OF:溢出标志。最近的操作导致一个补码溢出————正溢出或负溢出
2. 条件码通常不会直接读取，常使用的方法有三种
- 可以根据条件码的某种组合，将一个字节设为0或者1
- 可以条件跳转到程序的某个其他的部分
- 可以有条件的传送数据
<img src="img\屏幕截图 2022-11-09 213025.png">

3. 跳转指令
<img src="im\屏幕截图 2022-11-09 213928.png">

4. 转跳指令编码
# 处理器体系结构
## Y84-64指令集体系结构
    定义一个指令集结构包括定义各种在状态单元，指令集和编码，一组编程规范和异常事件处理
**程序猿可见的状态**  Y86-64程序中每条指令都会读取或修改处理器状态的某些部分。
# 优化程序性能

## 表示程序的性能
我们引入度量标准每元素的周期数（CPE）作为一种表示程序性能并指导我们改进代码的方法。
## 理解现代处理器
**整体操作** 
<img src="img\屏幕截图 2022-11-12 211925.png">

# 存储器层次结构

## 存储技术
 ### 随机访问存储器
**静态RAM**
 SRAM（静态随机存取存储器）将每个位存储在一个双稳定的存储单元里。每个单元用一个六晶体管电路来实现的。它可以无限期地保持两个不同的电压配置，或状态之一。其他任何状态都是不稳定的————从不稳定状态开始，电路会迅速的转移到两个稳定状态中的一个
 **动态RAM**
DRAM将每一个位存储为对一个对一个电容的充电。
 1.DARM芯片中的单元被分成d个个超单元，每个超单元由w个DRAM单元组成，

<img src="img\屏幕截图 2022-11-13 192755.png">

 每个DRAM芯片被链接到某个成为内存控制器的电路，这个电路可以一次传送位到每个DRAM芯片或一次从每个DRAM芯片传出w位。
 <img src="img\屏幕截图 2022-11-13 193255.png">

### 磁盘存储
<img src="img\屏幕截图 2022-11-14 083429.png">

**记录容量**
- 记录密度 磁道一英寸dede段中可以放入的位数
- 磁道密度 从盘片中心出发半径上一英寸的段内可以有的磁道数
- 面密度 记录密度与磁道密度的乘积

**读取过程**
<img src="img\屏幕截图 2022-11-14 084715.png">

### 固态硬盘

<img src="img\屏幕截图 2022-11-14 084935.png">

## 局部性
**时间局部性和空间局部性**在一个具有良好时间局部性的程序中，被引用过一次的内存位置可能在不远的将来被多次引用。在一个具有良好的空间局部性的程序中，如果一个内存的位置被引用了一次，那么程序很可能在不远的将来引用附近的一个内存的位置。
 
## 储存器的层次结构
<img src="img\屏幕截图 2022-10-30 213345.png">

**存储器层次结构中的缓存** 高速缓存是一个小而快的存储设备，他作为存储器在更大，也更慢的设备中的数据对象的缓冲区。
 
  存储器结构层次的中心思想是，对于每个k，位于k层的更快更小的存储器作为位于k+1层更大更慢存储设备的缓存的。
<img src="img\屏幕截图 2022-11-14 100551.png">

## 高速缓存存储器
<img src="img\屏幕截图 2022-11-14 101453.png">

### 通用的高速缓存存储器组织结构
  考虑一个计算机系统，其中每个存储器地址由m位，形成M=2^m个不同的地址。，一个机器的高速缓存被组织成一个有S=2^s个高速缓存组的数组，每个组包含E个高速缓存行，每个行是由一个B=2^b字节的数据块组成，一个有效位指明这个行是否包含有意义的信息，还有t=m-（b+s）个标记位（是当前块的内存的地址的位的一个子集）。
<img src="img\屏幕截图 2022-11-14 101929.png">

**直接映射高速缓存** 每组只有一行（E=1）的高速缓存成为(E=1)的高速缓存成为直接映射高速缓存

高速缓存确定一个请求是否命中，然后抽取出被请求的字的过程分为三部 1. 组选择 2.行匹配 3.字抽取
- **直接映射高速缓存中的组选择** 高速缓存从w的地址中间取出s个组索引，这些位被解释成一个对应与一个组号的无符号整数。如果我们把高速缓存看成是一个关于组的一位数组，那么这些组索引位就是一个到这个数组的索引
<img src="img\屏幕截图 2022-11-14 141017.png">

- **直接映射高速缓存中的行匹配** 上一步确定了某个组i，接下来就要确定是否有字w的一个副本存储在i组包含的一个高速行中。
 在这个例子中，选中的组只有一个高速行。这个行的有效位设置了，所以我们知道标记和块中的位是有意义的，因为这个高速缓存行中的标记与地址中的标记位相匹配，所以我们知道我们想要的那个字的一个副本确实存储在这个行中。
<img src="img\屏幕截图 2022-11-14 142244.png">

- **直接映射高速缓存中的字选择** 一旦命中，我们就知道w就在这个块的某个地方，最后一步确定所需的字在块是从哪里开始的。例如，这个示例，块偏移是100，它表明，w的副本是从块中的字节4开始的。
- **综合：运行中的直接映射的高速缓存**
### 组相联高速缓存
<img src="img\屏幕截图 2022-11-14 150013.png">

### 全相联高速缓存
  只分一个组
### 一个真实的高速缓存层次结构的解剖
这一层次结构一个有趣的特性是所有的SRAM高速缓存器都在CPU芯片上
<img src="img\屏幕截图 2022-11-15 164355.png">

## 高速缓存对程序性能的影响


# 链接
l 链接是将各种代码和数据片收集并组合成一个单一文件的过程，这个文件可被加载（复制）到内存并执行。链接可以执行于编译时，也就是在源代码被翻译成机器代码时；也可以执行于加载时，也就是程序被加载器加载到内存并执行；甚至执行与运行时，也就是由应用程序来执行
## 编译器驱动程序
<img src="img\屏幕截图 2022-11-15 200602.png">

### 静态链接
以一组可重定位目标文件和命令行参数作为输入，生成一个完全连接的，可以加载和运行的可执行的目标文件作为输出。
需要解决的问题
- **符号解析** 目标文件定义和引用符号，每个符号对应于一个函数，一个全局变量或一个静态变量。
- **重定位** 编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节
## 目标文件
有三种形式
- 可重定位目标文件。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。
- 可执行目标文件。包含二进制代码和数据，其形式可被直接复制到内存并执行
- 共享目标文件 一种特殊类型的可重定位文件，可以在加载或运行时被同态的加载进内存并链接
## 可重定位目标文件
<img src="img\屏幕截图 2022-11-15 203846.png">

## 符号和和符号表
- 由模块m定义能被其他模块引用的全局符号。
- 由其他模块定义并被模块m引用的全局符号
- 只被模块m定义和引用的局部符号。
## 符号解析
### 链接器如何解析多重定义的全局符号
链接器的输入是一组可重定位目标模块。每个模块定义一组模块，
### 与静态库链接
所有的编译系统都提供一种机制，将所有相关的目标模块打包成一个单独的文件，成为静态库。
**优点** 将编译器的实现与标准函数的实现分离开
<img src="img\屏幕截图 2022-11-17 184814.png">

## 重定位
 一旦链接器完成符号解析这一步，就把代码中的每个符号引用和正好一个符号定义关联起来
- 重定位节和符号定义 这一步，链接器把所有相同类型的节合并成为同一类型的聚合字节。
-重定位节中的符号引用 链接器修改代码节和数据节中对每个符号的引用使他们指向正确的运行时地址。
### 重定位条目
无论何时汇编器遇到对最终位置位置的目标引用，它就会生成一个重定位条目。
<img src="img\屏幕截图 2022-11-18 092721.png">

## 可执行目标文件

# 异常控制流

## 异常
<img src="img\屏幕截图 2022-11-18 100211.png">

### 异常处理

### 异常分类
<img src="img\src\屏幕截图 2022-11-18 101629.png">

1. 中断
 中断是异步发生的，是来自处理器外部的I/O设备的信号的结果，硬件中断不是由任何一条专门的指令造成的。
2. 陷阱和系统调用
陷阱是有意的异常，是执行一条指令的结果，陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫系统调用。
3. 故障
故障由错误情况引起的，他可能被故障处理程序修正，当放生故障时，处理器将控制转移交给故障处理程序。
4. 终止
终止是不可回复的致命的错误造成的结果。
### linux系统中的异常

## 进程
**定义** 一个执行程序中的实例。
- 一个独立的逻辑控制流，提供一个假象好像我们的程序独占使用处理器。
- 一个私有的地址空间 ， 提供一个假象，我们的程序独占内存系统。
1. 逻辑控制流
PC值的序列叫逻辑控制流，或逻辑流
2. 并发流
一个逻辑流的执行时间上与另一个流重叠，称为并发流。
这两个流被称为并发运行。
多个流并发的执行的一般称为并发，
一个进程和其他进程轮流运行时的概念称为多任务。
3. 私有地址空间
 在这个空间某个地址相关的内存字节是不能被其他进程读或写的。
 <img src="img\屏幕截图 2022-11-18 143728.png">

4. 用户模式和内核模式
 为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间的范围。
5. 上下文切换
内核为每一个进程维持一个上下文，上下文是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的的寄存器，浮点寄存器，程序计数器，用户栈，状态寄存器，内核栈和各种内核数据结构。
<img src="img\屏幕截图 2022-11-18 151052.png">

## 系统调用错误处理

## 进程控制
每个进程都有唯一的PID
三种状态
- 运行 进程要么在cpu上执行，要么在等待被执行且最终会被内核调度
- 终止 进程被挂起且不会被调调度
- 终止 进程永远停止了
## 信号
信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。
每种信号类型都对应于某种系统事件，低层的硬件异常是由内核异常处理程序处理的，正常情况下，队用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。
1. 信号术语
传送一个信号到目的的进程是由两个不同的步骤组成的：
- 发送信号。内核通过更新目的进程上下文的某个状态，发送一个信号给目的进程。发送信号的原因：（1）内核检测到一个系统事件（2）一个进程调用了kill函数，显式的要求内核发送一个信号给目的进程。
- 接受信号 进程可以忽略这个信号，终止或者通过执行一个成为信号处理程序。
<img src="img\屏幕截图 2022-11-18 163909.png">

1. 发送信号
- 进程组
 每个进程都只属于一个进程组，进程组是由一个正整数进程组ID来标识。
2. 接受信号
当内核把进程p从内核模式转换到用户模式，他会检查进程p的违背阻塞的待处理信号的集合，如果这个集合为空，内核将控制传递到p的逻辑控制流中的下一条命令，如果非空，内核选择集合中某个信号k，并强制p接受信号k，收到这个信号会触发进程的某种行为。每个信号都有一个预定义的默认行为。
- 进程终止
- 进程终止并转储内存
- 进程停止直到被SIGCONT信号重启
- 进程忽略该信号
3. 阻塞和解除阻塞信号
隐式阻塞机制。 内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。
显示阻塞机制 应用程序可以使用sigprocmask函数和它的辅助函数，明确地阻塞和解除阻塞选定的信号

# 虚拟内存
虚拟内存是硬件异常，硬件地址翻译，主存，磁盘文件和内核软件的完美交互，它为每个进程提供一个大的，一致的和私有的地址空间。
能力
- 它将主存看成一个存储在磁盘上的地址空间的高速缓存，在主存中只保留活动区域，并根据需要在磁盘和主存之间来回传送数据
- 它为每个进程提供了一致的地址空间，从而简化内存管理
- 它保护每个进程的地址空间不被其他进程破坏
## 物理和虚拟寻址
<img src="img\屏幕截图 2022-11-18 195455.png">

<img src="img\屏幕截图 2022-11-18 195530.png">

## 地址空间
 地址空间是一个非负整数地址的有序集合

## 虚拟内存作为缓存的工具
虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。磁盘上的数据被分割成块，这些块作为磁盘和主存之间的传输单元。VM系统通过将虚拟内存分割成为虚拟页。
<img src="img\屏幕截图 2022-11-18 201722.png">

1. DRAM缓存的组织结构
采用全相联
2. 页表
同任何缓存一样，虚拟内存系统必须由某种方法判定一个虚拟页是否缓存在DRAM中的某个地方，如果是，必须确定这个虚拟页存放在那个物理页中，不命中，系统必须判断这个虚拟页存放在磁盘的那个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到DRAM，替换这个牺牲页。
<img src="img\屏幕截图 2022-11-19 083942.png">

3. 页命中
cpu想要读取包含在vp2中的虚拟内存的一个字时的情况。
<img src="img\屏幕截图 2022-11-19 092053.png>

4. 缺页
在虚拟内存中，DRAM缓存不命中称为缺页。
<img src="img\屏幕截图 2022-11-19 095642.png">

牺牲页
<img src="img\屏幕截图 2022-11-19 095918.png">

## 虚拟内存作为内存管理的工具
早期系统，支持一个比物理内存更小的虚拟地址空间。
<img src="img\屏幕截图 2022-11-19 100732.png">

- 简化链接。独立的地址空间允许每个进程的内存映像使用相同的格式，而不管代码和数据实际存放在物理内存的何处。
- 简化加载 虚拟内存使内存更容易加载可执行文件和共享文件对象。
- 简化共享 独立的地址空间为操作系统提供了一个管理用户进程和操作系统自身之间共享的一致机制。
- 简化内存分配 虚拟内存为用户进程提供一个分配额外的的机制。
## 虚拟内存作为内存保护的工具

## 地址翻译
<img src="img\屏幕截图 2022-11-19 104119.png">

<img src="img\屏幕截图 2022-11-19 104328.png">
                              
# 系统级I/O
## unix I/O
所有的I/O设备都被模型化为文件，而所有的输入和输出都被当做对应的文件的读和写来执行。
- 打开文件 一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备。
- Linux shell 创建的每个进程开始都有三个打开的文件：标准输入，标准输出和标准错误
- 改变当前文件的位置 对于每个打开的文件夹，内核保持着一个文件位置k，初始为0；
- 读写文件 一个读操作就是从文件复制n>0个字节到内存，然后将k增加到k+n。
- 关闭文件 当应用完成了对文件的访问之后，他就通知内核关闭文件。

## 文件
 文件类型
- 普通文件（regular file）包含任意数据。
- 目录 包含一组连接的文件，
- 套接字 是用来与另一个进程进行跨网络通信的文件

# 网络编程

## 客户端-服务器编程模型
客户端-服务器模型中的基本操作是事务。
1. 当一个客户端需要服务时，他想服务器发送一个请求，
发起一个事务。
2. 服务器收到请求后，解释它，并以适当的方式操作它的资源。
3. 服务器给客户端发送一个响应，并等待下一个请求。
4. 客户端收到响应并处理他。
## 网络
对主机而言，网络只是一种I/O设备，是数据源和数据接收方，
<img src="img\屏幕截图 2022-11-19 142021.png">

网络是一个按照地理远近组成的层次系统，最低层次是LAN（局域网）
<img src="img\屏幕截图 2022-11-19 142935.png">

<img src="img\屏幕截图 2022-11-19 143527.png">

## 全球ip因特网
<img src="img\屏幕截图 2022-11-19 144623.png">

1. ip地址
ip地址是一个32位无符号整数
2. 域名
DNS域名系统
3. 因特网连接
因特网客户端和服务器通过在连接上发送和接受字节来通信。从连接一对进程的意义上而言，连接是点对点的。从数据可以同时双向流动的角度来说，他是全双工的。
<img src="img\屏幕截图 2022-11-19 152813.png">

##  套接字接口
套接字接口是一组函数，它们和unixI/O函数结合起来，用来创建网络应用。
<img src="img\屏幕截图 2022-11-19 153125.png">

## web服务器
1. web基础
web客户端和服务器之间交互用的是一个基于文本的应用级协议，叫做HTTP。
2. web内容
对于web客户端和服务器而已，内容是一个MIME（Multipurpose Internet Mail Extensions,多用途的)
<img src="img\屏幕截图 2022-11-19 161011.png">

- 取出一个磁盘文件，将他内容返回客户端。
- 运行一个可执行文件，并将它的输出返回客户端
3. http事务

# 并发编程
## 基于进程的并发编程
构造并发程序最简单的方式是使用进程
<img src="img\屏幕截图 2022-11-19 170342.png">

