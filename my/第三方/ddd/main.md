# D开篇
领域驱动设计(domain-driven design，DDD)需要应对软件复杂度的挑战！那么，软件复杂度的成因究竟是什么，又该如何应对？概括而言，即：
- 规模——通过分而治之控制规模；
- 结构——通过边界保证清晰有序；
- 变化——顺应变化方向。

领域驱动设计对软件复杂度的应对之道可进一步**阐述**为：
- 规模——以子领域、限界上下文对问题空间与解空间分而治之；
- 结构——以分层架构隔离业务复杂度与技术复杂度，形成清晰的架构；
- 变化——通过领域建模抽象为以聚合为核心的领域模型，响应需求之变化。

子领域、限界上下文、分层架构和聚合皆为领域驱动设计的核心元模型，分属战略设计和战术设计，贯穿了从问题空间到解空间的全过程。

领域驱动设计统一过程分为3个阶段：
- 全局分析阶段；
- 架构映射阶段；
- 领域建模阶段。
## 软件复杂程度
多数软件系统需要实现的整体功能往往是难以理解的，同时，随着需求的不断演进，它又在一定程度具有未来的不可预测性，这意味着软件系统的“复杂”同时覆盖了“复杂难解”(complicated)与“复杂难测”(complex)两个层面。既然如此，那么设计一个软件系统就像规划一座城市，既要考虑城市布局，以便居民的生活与工作，满足外来游客或商务人员的旅游或出差需求，又要考虑未来因素的变化，例如“当居民对城市的使用方式有所变化，或者受到外力的影响时，城市就会相应地演化”。参考城市的复杂度特征，我们要剖析软件系统的复杂度，就可以从理解能力与预测能力这两个维度探索软件复杂度的成因。
##  理解能力
### 规模
软件的需求决定了系统的规模。一个只有数十万行代码的软件系统自然不可与有数千万行代码的大规模系统相提并论。软件系统的规模取决于需求的数量，更何况需求还会像树木那样生长。一棵小树会随着时间增长渐渐长成一棵参天大树，只有到了某个时间节点，需求的数量才会慢慢稳定下来。
系统规模的扩张，不仅取决需求的数量，还取决于需求功能点之间的关系。需求的每个功能不可能做到完全独立，彼此之间相互影响相互依赖，修改一处就会牵一发而动全身，就好似城市中的某条道路因为施工需要临时关闭，车辆只得改道绕行，这又导致了其他原本已经饱和的道路因为涌入更多车辆而变得更加拥堵。这种拥堵现象又会顺势向其他分叉道路蔓延，形成辐射效应。

软件开发的拥堵现象或许更严重，这是因为：
- 函数存在副作用，调用时可能对函数的结果做了隐含的假设；
- 类的职责繁多，导致开发人员不敢轻易修改，因为不知会影响到哪些模块；
- 热点代码被频繁变更，职责被包裹了一层又一层，没有清晰的边界；
- 在系统某个角落，隐藏着伺机而动的bug，当诱发条件具备时，就会让整条调用链瘫痪；
- 不同的业务场景包含了不同的例外场景，每种例外场景的处理方式都各不相同；
- 同步处理代码与异步处理代码纠缠在一起，不可预知程序执行的顺序。

### 结构
结构之所以变得复杂，多数情况下还是由系统的质量属性(quality attribute)决定的。例如，我们需要满足高性能、高并发的需求，就需要考虑在系统中引入缓存、并行处理、CDN、异步消息以及支持分区的可伸缩结构；
软件系统的结构繁复还会增加软件组织的复杂度。系统架构的分解促成了软件构建工作的分工，这种分工虽然使得高效的并行开发成为可能，却也可能因为沟通成本的增加为管理带来挑战。

##  预测能力
## 过度设计
设计软件系统时，变化让我们患得患失，不知道如何把握系统设计的度。若拒绝对变化做出理智的预测，系统的设计会变得僵化，一旦有新的变化发生，修改的成本会非常大；若过于看重变化产生的影响，渴望涵盖一切变化的可能，若预期的变化没有发生，我们之前为变化付出的成本就再也补偿不回来了，这就是所谓的“过度设计”。
## 设计不足
要应对需求变化，终归需要一些设计技巧。很多时候，因为设计人员的技能不足，没有明确识别出未来确认会发生的变化，或者对需求变化发展的方向缺乏前瞻，所以导致整个设计变得过于僵化，修改的成本太高，从而走向了过度设计的另外一个极端，我将这一问题称为“设计不足”。
# 领域驱动设计概览
软件的核心是其为用户解决领域相关的问题的能力。所有其他特性，不管有多么重要，都要服务于这个基本目的。
——Eric Evans，《领域驱动设计》

## 领域驱动设计的基本概念
领域驱动设计作为一个针对大型复杂业务系统的领域建模方法体系，它改变了传统软件开发工程师针对数据库建模的方式，通过面向领域的思维方式，将要解决的业务概念和业务规则等内容提炼为领域知识，然后借由不同的建模范式将这些领域知识抽象为能够反映真实世界的领域模型。
### 领域驱动设计元模型
领域驱动设计元模型是以模式的形式呈现在大家眼前的，由诸多松散的模式构成，这些模式在领域驱动设计中的关系如图
![alt text](image.png)
领域驱动设计的核心是模型驱动设计，而模型驱动设计的核心又是领域模型，领域模型必须在统一语言的指导下获得。为整个业务系统建立的领域模型要么属于核心子领域，要么属于通用子领域。之所以区分子领域，一方面是为了将一个不易解决的庞大问题切割为团队可以掌控的若干小问题，达到各个击破的目的，另一方面也是为了更好地实现资产的合理分配。

为了保证定义的领域模型在不同上下文表达各自的知识语境，需要引入限界上下文来确定业务能力的自治边界，并考虑通过持续集成来维护模型的统一。上下文映射清晰地表达了多个限界上下文之间的协作关系。根据协作方式的不同，可以将上下文映射分为如下8种模式
- 客户方/供应方；
- 共享内核；
- 遵奉者；
- 分离方式；
- 开放主机服务；
- 发布语言；
- 防腐层；
- 大泥球。

模型驱动设计可以在限界上下文的边界内部进行，它通过分层架构(layered architecture)将领域独立出来，并在统一语言的指导下，通过与领域专家的协作获得领域模型。表示领域模型的设计要素包括实体(entity)、值对象(value object)、领域服务(domain service)和领域事件(domain event)。领域逻辑都应该封装在这些对象中。这一严格的设计原则可以避免领域逻辑泄露到领域层之外，导致技术实现与领域逻辑的混淆。

聚合(aggregate)是一种边界，它可以封装一到多个实体与值对象，并维持该边界范围之内的业务完整性。聚合至少包含一个实体，且只有实体才能作为聚合根(aggregate root)。工厂(factory)和资源库(repository)负责管理聚合的生命周期。前者负责聚合的创建，用于封装复杂或者可能变化的创建逻辑；后者负责从存放资源的位置（数据库、内存或者其他Web资源）获取、添加、删除或者修改聚合。
### 问题空间和解空间
软件系统的构建实则是对问题空间的求解，以获得构成解空间的设计方案
![alt text](lohtpj3pnkzpvc6pjt.jpg)

为什么要在软件构建过程中引入问题空间和解空间？

实际上，随着IT技术的发展，软件系统正是在这两个方向不断发展和变化的。在问题空间，我们要解决的问题越来越棘手，空间规模越来越大，因为随着软件技术的发展，许多原本由人来处理的线下流程慢慢被自动化操作所替代，人机交互的方式发生了翻天覆地的变化，IT化的范围变得更加宽广，涉及的领域也越来越多。问题空间的难度与规模直接决定了软件系统的复杂度。

**构成解空间的解决方案不仅要解决问题，还要控制软件系统的复杂度**。

问题空间需要解空间来应对，解空间自然也不可脱离问题空间而单独存在。对于客户提出的需求，要分清楚什么是问题，什么是解决方案，真正的需求才可能浮现出来。在看清了问题的真相之后，我们才能有据可依地寻找真正能解决问题的解决方案。软件构建过程中的需求分析，实际就是对问题空间的定位与探索。如果在问题空间还是一团迷雾的时候就贸然开始设计，带来的灾难性结果是可想而知的。

怎么区分方案级需求和问题级需求？方案级需求就好比一个病人到医院看病，不管病情就直接让医生开阿司匹林，而问题级需求则是向医生描述自己身体的症状。病情是医生要解决的问题，处方是医生提供的解决方案。

在针对问题空间求解时，必须映射于问题空间定义的问题，如此才能遵循恰如其分的设计原则，在问题空间的上下文约束下寻找合理的解决方案。

领域驱动设计为问题空间与解空间提供了不同的设计元模型。对于问题空间，强调运用统一语言来描述需求问题，利用核心子领域、通用子领域与支撑子领域来分解问题空间，如此就可以“揭示什么是重要的以及在何处付出努力”。除去统一语言与子领域，其余设计元模型都将运用于解空间，指导解决方案围绕着“领域”这一核心开展业务系统的战略设计与战术设计。
### 战略设计和战术设计
既然软件构建的过程就是对问题空间求解的过程，那么面对太多太大的问题，就无法奢求一步求解，需要根据问题的层次进行分解。不同层次的求解目标并不相同：为了把握系统的全景，就需要从宏观层次分析和探索问题空间，获得对等于软件架构的战略设计原则；为了深入业务的细节，则需要从微观层次开展建模活动，并在战略设计原则的指导下做出战术设计决策。这就是领域驱动设计的两个阶段：战略设计阶段和战术设计阶段。

战略设计阶段要从以下两个方面来考量。
- 问题空间：对问题空间进行合理分解，识别出核心子领域、通用子领域和支撑子领域，并确定各个子领域的目标、边界和建模策略。
- 解空间：对问题空间进行解决方案的架构映射，通过划分限界上下文，为统一语言提供知识语境，并在其边界内维护领域模型的统一。每个限界上下文的内部有着自己的架构，限界上下文之间的协作关系则通过上下文映射来体现和表达。

子领域的边界明确了问题空间中领域的优先级，限界上下文的边界则确保了领域建模的最大自由度。这也是战略设计在分治上起到的效用。当我们在战略层次从问题空间映射到解空间时，子领域也将映射到限界上下文，即可根据子领域的类型为限界上下文选择不同的建模方式。例如为处于核心子领域的限界上下文选择领域模型(domain model)模式，为处于支撑子领域(supporting subdomain)的限界上下文选择事务脚本(transaction script)模式，这样就可以灵活地平衡开发成本与开发质量。

战术设计阶段需要在限界上下文内部开展领域建模，前提是你为限界上下文选择了领域模型模式。在限界上下文内部，需要通过分层架构将领域独立出来，在排除技术实现的干扰下，通过与领域专家的协作在统一语言的指导下逐步获得领域模型。

战术设计阶段最重要的设计元模型是聚合模式。虽然聚合是实体和值对象的**概念边界**，然而在获得了清晰表达领域知识的领域模型后，我们可以将聚合视为表达领域逻辑的最小设计单元。如果领域行为是无状态的，或者需要多个聚合的协作，又或者需要访问**外部资源**，则应该将它分配给**领域服务**。至于领域事件，则主要用于表达领域对象状态的迁移，也可以通过事件来实现聚合乃至限界上下文之间的状态通知。




从战略设计到战术设计是一个自顶向下的设计过程，体现为设计原则对设计决策的指导；将战术设计方案反馈给战略设计，则是自底向上的演化过程，体现为对领域概念的重构引起对战略架构的重构。二者形成不断演化、螺旋上升的设计循环。

### 领域模型驱动设计
领域驱动设计是一种思维方式，而模型驱动设计则是领域驱动设计的一种设计元模型。因此，模型驱动设计必须在领域驱动设计思维方式的指导下进行，或者更加准确地将其描述为领域模型驱动设计。

领域模型驱动设计通过单一的领域模型同时满足分析建模、设计建模和实现建模的需要，从而将分析、设计和编码实现糅合在一个整体阶段中，避免彼此的分离造成知识传递带来的知识流失和偏差。

模型驱动设计主要在战术阶段进行，换言之，整个领域建模的工作是在限界上下文的边界约束下进行的，统一语言的知识语境会对领域模型产生影响，至少，建模人员不用考虑在整个系统范围下领域概念是否存在冲突，是否带来歧义。由于限界上下文拥有自己的内部架构，一旦领域模型牵涉到跨限界上下文之间的协作，就需要遵循限界上下文与上下文映射的架构约束了。

既然模型驱动设计是面向领域的，就必须明确以下两个关键原则。
- 以领域为建模驱动力：在建模过程中，针对领域知识提炼抽象的领域模型，并不断针对领域模型进行深化与突破，直到最终以代码来表达领域模型。
- 排除技术因素的干扰：领域建模与技术实现的关注点分离有助于保证领域模型的纯粹性，也能避免混淆领域概念和其他只与技术相关的概念。

模型驱动设计不能一蹴而就。毕竟，即使通过限界上下文降低了业务复杂度，对领域知识的理解是一个渐进的过程。在这个过程中，开发团队需要和领域专家紧密协作，共同研究领域知识。在获得领域模型之后，也要及时验证，确认领域模型有没有真实表达领域知识。一旦发现遗漏或失真的现象，就需要重构领域模型。首先建立领域模型，然后重构领域模型，进而精炼领域模型，保证领域概念被直观而真实地表达为简单清晰的领域模型。显然，在战术设计阶段，模型驱动设计也应该是一个演进的不断完善的螺旋上升的循环过程。
## 领域驱动设计过程
领域驱动设计过程是一条若隐若现的由许多点构成的设计轨迹，这些点就是领域驱动设计的设计元模型。如果我们从问题空间到解空间，从战略设计到战术设计寻找到对应的设计元模型，分别“点亮”它们，那么这条设计轨迹就会如图
![alt text](lohtpkvmim7sayfxng.jpg)


通过对问题空间开展战略层次的求解，获得限界上下文形成解空间的主要支撑元素。识别限界上下文的基础来自问题空间的业务需求，遵循“高内聚松耦合”的原则划分领域知识的边界，再通过上下文映射管理它们之间的关系。每个限界上下文都是一个相对独立的“自治王国”，可以根据限界上下文是否属于核心子领域来选择内部的架构。通常，需要通过分层架构将限界上下文内部的领域隔离出来，进入战术设计阶段，进行面向领域的模型驱动设计。


选定一个限界上下文，在统一语言的指导下，针对该上下文内部的领域知识开展领域模型驱动设计。首先进行领域分析，提炼领域知识建立满足统一语言要求的领域分析模型，然后引入实体、值对象、领域服务、领域事件、聚合、资源库和工厂等设计要素开始程序设计，获得设计模型后在它的指导下进行编码实现，输出最终的领域模型。

在领域驱动设计过程中，战略设计控制和分解了战术设计的边界与粒度，战术设计则以实证角度验证领域模型的有效性、完整性和一致性，进而以迭代的方式分别完成对限界上下文与领域模型的更新与演化，各自形成设计过程的闭环。两个不同阶段的设计目标保持一致，形成一个连贯的过程，彼此之间相互指导与规范，最终保证战略架构与领域模型的同时演进。

##  控制软件复杂度
问题空间的复杂度决定了“求解”的难度，领域驱动设计对软件复杂度的控制之道就是竭力改变设计的质量，也就是在解空间中引入设计元模型，对问题空间的复杂度进行有效的控制。

###  控制规模
下面让我们通过一个案例认识到如何通过限界上下文控制系统的规模。

国际报税系统是为跨国公司的驻外雇员提供的、方便一体化的税收信息填报平台。税务专员通过该平台收集雇员提交的报税信息，然后对这些信息进行税务评审。如果税务专员评审出信息有问题，则将其返回给雇员重新修改和填报。一旦信息确认无误，则进行税收分析和计算，并生成最终的税务报告提交给当地政府以及雇员本人。

系统主要涉及的功能包括：

- 驻外雇员的薪酬与福利；
- 税收计划与合规评审；
- 对税收评审的分配管理；
- 税收策略设计与评审；
- 对驻外出差雇员的税收合规评审；
- 全球的签证服务。


主要涉及的用户角色包括：
- 驻外雇员(assignee)；
- 税务专员(admin)；

整个系统的解空间分解为多个限界上下文，每个限界上下文提供了自身领域独立的业务能力，系统架构。
![alt text](lohtpj5yono2cukv3yh.jpg)

每个限界上下文都是一个独立的自治单元。根据限界上下文的边界划分团队，建立单独的代码库。团队只为所属限界上下文负责：除了需要了解限界上下文之间的协作接口，以确定上下文映射的模式，团队只需要了解边界内的领域知识，为其建立各自的领域模型。系统复杂度通过限界上下文的分解得到了明显的控制。

### 清晰结构
保持系统结构的清晰是控制结构复杂度的不二法门。关键在于，要以正确的方式认清系统内部的边界。限界上下文从业务能力的角度形成了一条**清晰的边界**，它与业务模块不同，在内部也拥有独立的架构，通过分层架构将领域分离出来，在业务逻辑与技术实现之间划定一条清晰的边界。

问题空间由真实世界的客户需求组成，需求可以简单分为业务需求与质量需求。



我们可以将业务需求带来的复杂度称为“业务复杂度”(business complexity)。

软件系统的质量需求就是我们为系统定义的质量属性，包括安全、高性能、高并发、高可用性等，它们往往给软件的技术实现带来挑战。

我们可以将质量需求带来的复杂度称为“技术复杂度”(technology complexity)。

技术复杂度与业务复杂度并非完全独立的，二者的共同作用会让系统的复杂度变得不可预期。

要避免业务逻辑的复杂度与技术实现的复杂度混杂在一起，就需要确定业务逻辑与技术实现的边界，从而隔离各自的复杂度。这种隔离也符合关注点分离的设计原则。例如，在电商的领域逻辑中，订单业务关注的业务规则包括验证订单有效性，计算订单总额，提交和审批订单的流程等；技术关注点则从实现层面保障这些业务能够正确地完成，包括确保分布式系统之间的数据一致性，确保服务之间通信的正确性等。

领域驱动设计引入的分层架构规定了严格的分层定义，将业务逻辑封装到领域层(domain layer)，支撑业务逻辑的技术实现放到基础设施层(infrastructure layer)。在领域层之上的应用层(application layer)则扮演了双重角色：一方面，作为业务逻辑的外观(facade)，它暴露了能够体现业务用例的应用服务接口；另一方面，它又是业务逻辑与技术实现之间的黏合剂，实现了二者之间的协作。

下图图展示了一个典型的领域驱动设计分层架构。
![alt text](lohtpjoczoywouv43e.jpg)
领域层的内容与业务逻辑有关，基础设施层的内容与技术实现有关，二者泾渭分明，然后汇合在作为业务外观的应用层。应用层确定了业务逻辑与技术实现的边界，通过依赖注入(dependency injection)的方式将二者结合起来。

### 响应变化
未来的变化是无法控制的，我们只能以积极的态度拥抱变化。

领域驱动设计通过模型驱动设计针对限界上下文进行领域建模，形成了结合分析、设计和实现于一体的领域模型。通过提炼领域知识，并运用抽象的领域模型去表达，就可以达到对领域逻辑的化繁为简。模型是封装，实现了对业务细节的隐藏；模型是抽象，提取了领域知识的共同特征，保留了面对变化时能够良好扩展的可能性。

领域建模的一个难点是如何将看似分散的事物抽象成一个统一的领域模型。例如，我们要开发的项目管理系统需要支持多种软件项目管理流程，如瀑布、统一过程、极限编程或者Scrum，这些项目管理流程迥然不同，如果需要我们为各自提供不同的解决方案，就会使系统的模型变得非常复杂，也可能引入许多不必要的重复。通过领域建模，我们可以对项目管理领域的知识进行抽象，寻找具有共同特征的领域概念。这就需要分析各种项目管理流程的主要特征与表现，以从中提炼出领域模型。

瀑布式软件开发由需求、分析、设计、编码、测试、验收6个阶段构成，每个阶段都由不同的活动构成，这些活动可能是设计或开发任务，也可能是召开评审会。

统一过程(rational unified process，RUP)清晰地划分了4个阶段：先启阶段、细化阶段、构造阶段和交付阶段。每个阶段可以包含一到多个迭代，每个迭代有不同的工作，例如业务建模、分析设计、配置和变更管理等。

极限编程(eXtreme programming，XP)作为一种敏捷方法，采用了迭代的增量式开发，提倡为客户交付具有业务价值的可运行软件。在执行交付计划之前，极限编程要求团队对系统的架构做一次预研（architectural spike，又被译为架构穿刺）。当架构的初始方案确定后，就可以进入每次小版本的交付。每个小版本交付又被划分为多个周期相同的迭代。在迭代过程中，要求执行一些必需的活动，如编写用户故事、故事点估算、验收测试等。

Scrum同样是迭代的增量开发过程。项目在开始之初，需要在准备阶段确定系统愿景、梳理业务用例、确定产品待办项(product backlog)、制订发布计划以及组建团队。一旦确定了产品待办项以及发布计划，就进入冲刺(sprint)迭代阶段。sprint迭代过程是一个固定时长的项目过程，在这个过程中，整个团队需要召开计划会议、每日站会、评审会议和回顾会议。

领域建模就是要从这些纷繁复杂的领域逻辑中寻找到能够表示项目管理领域的概念，对概念进行抽象，确定它们之间的关系。经过分析这些项目管理流程，我们发现它们的业务概念和规则上虽有不同之处，但都归属于软件开发领域，因此必然具备一些共同特征。

从项目管理系统的角度看，无论针对何种项目管理流程，我们的主题需求是不变的，就是要为这些管理流程制订软件开发计划(plan)。不同之处在于，计划可以由多个阶段(phase)组成，也可以由多个发布(release)组成。一些项目管理流程没有发布的概念，我们也可以认为是一个发布。那么，到底是一个发布包含多个阶段，还是一个阶段包含多个发布呢？我们发现，在XP中明显地划分了两个阶段：架构预研阶段与发布计划阶段，而发布只属于发布计划阶段。因而从概念内涵上，可以认为是阶段(phase)包含了发布(release)，每个发布又包含了一到多个迭代(iteration)。至于Scrum的sprint概念，其实可以看作迭代的一种特例。每个迭代可以开展多种不同的活动(activity)，这些活动可以是整个团队参与的会议，也可以是部分成员或特定角色执行的实践。对计划而言，我们还需要跟踪任务(task)。与活动不同，任务具有明确的计划起止时间、实际起止时间、工作量、优先级和承担人。

![alt text](lohtpk5382alhr39a8k.jpg)

为了让项目管理者更加方便地制订项目计划，产品经理提出了计划模板功能。当管理者选择对应的项目管理生命周期类型后，系统会自动创建满足其规则的初始计划。基于增加的这一新需求，我们更新了之前的领域模型，如图2-8所示。

在增加的领域模型中，生命周期规格(life cycle specification)是一个隐含的概念，遵循领域驱动设计提出的规格(specification)模式154，封装了项目开发生命周期的约束规则。

领域模型以可视化的方式清晰地表达了业务含义。我们可以利用这个模型指导后面的程序设计与编码实现：当需求发生变化时，能够敏锐地捕捉到现有模型的不匹配之处，并对其进行更新，使得我们的设计与实现能够以较小的成本响应需求的变化。
![alt text](lohtpjpimgu8js1b85g.jpg)

## 冷静认识
控制软件复杂度是构建软件过程中永恒的旋律，必须明确：软件复杂度可以控制，但不可消除。领域驱动设计控制软件复杂度的中心主要在于“领域”，Eric Evans就认为：“很多应用程序最主要的复杂度并不在技术上，而是来自领域本身、用户的活动或业务。”2这当然并不全面，随着软件的“触角”已经蔓延到人类生活的方方面面，在业务复杂度变得越来越高的同时，技术复杂度也在不断地向技术极限发起挑战，其制造的技术障碍完全不亚于业务层面带来的困难。领域驱动设计并非“银弹”，它的适用范围主要是大规模的、具有复杂业务的中大型软件系统，至于对技术复杂度的应对，它的选择是“隔离”，然后交给专门的技术团队设计合理的解决方案。

领域驱动设计控制软件复杂度的方法当然不仅限于本章给出的阐释和说明，它的设计元模型在软件构建的多个方面都在发挥着作用，其目的自然也是改进设计质量以应对软件复杂度——这是领域驱动设计的立身之本！如果你要构建的软件系统没有什么业务复杂度，领域驱动设计就发挥不了它的价值；如果构建软件的团队对于软件复杂度的控制漠不关心，只顾着追赶进度而采取“头痛医头，脚痛医脚”的态度，领域驱动设计这套方法可能也入不了他们的法眼。即便认识到了领域驱动设计的价值，怎么用好它也是一个天大的难题。我尝试破解落地难题的方法，就是重新梳理领域驱动设计的知识体系，尝试建立一个固化的、具有参考价值的领域驱动设计统一过程。

# 领域驱动设计统一过程
## 领域驱动设计现存的不足
