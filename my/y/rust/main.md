# å‘
## äº¤å‰ç¼–è¯‘
ming64 å¿…é¡»æ˜¯sehï¼Œç‰ˆæœ¬æœª13 ç½‘å€ https://github.com/niXman/mingw-builds-binaries/releases
# åŸºç¡€
## å˜é‡
### é®è”½å˜é‡ 
mut å˜é‡çš„ä½¿ç”¨æ˜¯ä¸åŒçš„ï¼Œç¬¬äºŒä¸ª let ç”Ÿæˆäº†å®Œå…¨ä¸åŒçš„æ–°å˜é‡ï¼Œä¸¤ä¸ªå˜é‡åªæ˜¯æ°å¥½æ‹¥æœ‰åŒæ ·çš„åç§°ï¼Œæ¶‰åŠä¸€æ¬¡å†…å­˜å¯¹è±¡çš„å†åˆ†é… ï¼Œè€Œ mut å£°æ˜çš„å˜é‡ï¼Œå¯ä»¥ä¿®æ”¹åŒä¸€ä¸ªå†…å­˜åœ°å€ä¸Šçš„å€¼ï¼Œå¹¶ä¸ä¼šå‘ç”Ÿå†…å­˜å¯¹è±¡çš„å†åˆ†é…ï¼Œæ€§èƒ½è¦æ›´å¥½ã€‚
```rs
fn main() {
    let x = 5;
    // åœ¨mainå‡½æ•°çš„ä½œç”¨åŸŸå†…å¯¹ä¹‹å‰çš„xè¿›è¡Œé®è”½
    let x = x + 1;

    {
        // åœ¨å½“å‰çš„èŠ±æ‹¬å·ä½œç”¨åŸŸå†…ï¼Œå¯¹ä¹‹å‰çš„xè¿›è¡Œé®è”½
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x);
    }

    println!("The value of x is: {}", x);
}
```
## åŸºæœ¬ç±»å‹
### æ•´æ•°ç±»å‹
åœ¨å½“ä½¿ç”¨ --release å‚æ•°è¿›è¡Œ release æ¨¡å¼æ„å»ºæ—¶ï¼ŒRust ä¸æ£€æµ‹æº¢å‡ºã€‚ç›¸åï¼Œå½“æ£€æµ‹åˆ°æ•´å‹æº¢å‡ºæ—¶ï¼ŒRust ä¼šæŒ‰ç…§è¡¥ç å¾ªç¯æº¢å‡ºï¼ˆtwoâ€™s complement wrappingï¼‰çš„è§„åˆ™å¤„ç†ã€‚ç®€è€Œè¨€ä¹‹ï¼Œå¤§äºè¯¥ç±»å‹æœ€å¤§å€¼çš„æ•°å€¼ä¼šè¢«è¡¥ç è½¬æ¢æˆè¯¥ç±»å‹èƒ½å¤Ÿæ”¯æŒçš„å¯¹åº”æ•°å­—çš„æœ€å°å€¼ã€‚æ¯”å¦‚åœ¨ u8 çš„æƒ…å†µä¸‹ï¼Œ256 å˜æˆ 0ï¼Œ257 å˜æˆ 1ï¼Œä¾æ­¤ç±»æ¨ã€‚ç¨‹åºä¸ä¼š panicï¼Œä½†æ˜¯è¯¥å˜é‡çš„å€¼å¯èƒ½ä¸æ˜¯ä½ æœŸæœ›çš„å€¼ã€‚ä¾èµ–è¿™ç§é»˜è®¤è¡Œä¸ºçš„ä»£ç éƒ½åº”è¯¥è¢«è®¤ä¸ºæ˜¯é”™è¯¯çš„ä»£ç ã€‚

- ä½¿ç”¨ wrapping_* æ–¹æ³•åœ¨æ‰€æœ‰æ¨¡å¼ä¸‹éƒ½æŒ‰ç…§è¡¥ç å¾ªç¯æº¢å‡ºè§„åˆ™å¤„ç†ï¼Œä¾‹å¦‚ wrapping_add
- å¦‚æœä½¿ç”¨ checked_* æ–¹æ³•æ—¶å‘ç”Ÿæº¢å‡ºï¼Œåˆ™è¿”å› None å€¼
- ä½¿ç”¨ overflowing_* æ–¹æ³•è¿”å›è¯¥å€¼å’Œä¸€ä¸ªæŒ‡ç¤ºæ˜¯å¦å­˜åœ¨æº¢å‡ºçš„å¸ƒå°”å€¼
- ä½¿ç”¨ saturating_* æ–¹æ³•ä½¿å€¼è¾¾åˆ°æœ€å°å€¼æˆ–æœ€å¤§å€¼
```rs
fn main() {
    let a : u8 = 255;
    let b = a.wrapping_add(20);
    println!("{}", b);  // 19
}
```
### æµ®ç‚¹ç±»å‹
æµ®ç‚¹æ•°å¾€å¾€æ˜¯ä½ æƒ³è¦æ•°å­—çš„è¿‘ä¼¼è¡¨è¾¾ æµ®ç‚¹æ•°ç±»å‹æ˜¯åŸºäºäºŒè¿›åˆ¶å®ç°çš„ï¼Œä½†æ˜¯æˆ‘ä»¬æƒ³è¦è®¡ç®—çš„æ•°å­—å¾€å¾€æ˜¯åŸºäºåè¿›åˆ¶ï¼Œä¾‹å¦‚ 0.1 åœ¨äºŒè¿›åˆ¶ä¸Šå¹¶ä¸å­˜åœ¨ç²¾ç¡®çš„è¡¨è¾¾å½¢å¼ï¼Œä½†æ˜¯åœ¨åè¿›åˆ¶ä¸Šå°±å­˜åœ¨ã€‚è¿™ç§ä¸åŒ¹é…æ€§å¯¼è‡´ä¸€å®šçš„æ­§ä¹‰æ€§ï¼Œæ›´å¤šçš„ï¼Œè™½ç„¶æµ®ç‚¹æ•°èƒ½ä»£è¡¨çœŸå®çš„æ•°å€¼ï¼Œä½†æ˜¯ç”±äºåº•å±‚æ ¼å¼é—®é¢˜ï¼Œå®ƒå¾€å¾€å—é™äºå®šé•¿çš„æµ®ç‚¹æ•°ç²¾åº¦ï¼Œå¦‚æœä½ æƒ³è¦è¡¨è¾¾å®Œå…¨ç²¾å‡†çš„çœŸå®æ•°å­—ï¼Œåªæœ‰ä½¿ç”¨æ— é™ç²¾åº¦çš„æµ®ç‚¹æ•°æ‰è¡Œ

æµ®ç‚¹æ•°åœ¨æŸäº›ç‰¹æ€§ä¸Šæ˜¯åç›´è§‰çš„ ä¾‹å¦‚å¤§å®¶éƒ½ä¼šè§‰å¾—æµ®ç‚¹æ•°å¯ä»¥è¿›è¡Œæ¯”è¾ƒ,æ˜¯çš„ï¼Œå®ƒä»¬ç¡®å®å¯ä»¥ä½¿ç”¨ >ï¼Œ>= ç­‰è¿›è¡Œæ¯”è¾ƒï¼Œä½†æ˜¯åœ¨æŸäº›åœºæ™¯ä¸‹ï¼Œè¿™ç§ç›´è§‰ä¸Šçš„æ¯”è¾ƒç‰¹æ€§åè€Œä¼šå®³äº†ä½ ã€‚å› ä¸º f32 ï¼Œ f64 ä¸Šçš„æ¯”è¾ƒè¿ç®—å®ç°çš„æ˜¯ std::cmp::PartialEq ç‰¹å¾(ç±»ä¼¼å…¶ä»–è¯­è¨€çš„æ¥å£)ï¼Œä½†æ˜¯å¹¶æ²¡æœ‰å®ç° std::cmp::Eq ç‰¹å¾ï¼Œä½†æ˜¯åè€…åœ¨å…¶å®ƒæ•°å€¼ç±»å‹ä¸Šéƒ½æœ‰å®šä¹‰
```rs
fn main() {
  // æ–­è¨€0.1 + 0.2ä¸0.3ç›¸ç­‰
  assert!(0.1 + 0.2 == 0.3);
}
```
ä½ å¯èƒ½ä»¥ä¸ºï¼Œè¿™æ®µä»£ç æ²¡å•¥é—®é¢˜å§ï¼Œå®é™…ä¸Šå®ƒä¼š panic(ç¨‹åºå´©æºƒï¼ŒæŠ›å‡ºå¼‚å¸¸)ï¼Œå› ä¸ºäºŒè¿›åˆ¶ç²¾åº¦é—®é¢˜ï¼Œå¯¼è‡´äº† 0.1 + 0.2 å¹¶ä¸ä¸¥æ ¼ç­‰äº 0.3ï¼Œå®ƒä»¬å¯èƒ½åœ¨å°æ•°ç‚¹ N ä½åå­˜åœ¨è¯¯å·®ã€‚
### æœ‰ç†æ•°å’Œå¤æ•°

Rust çš„æ ‡å‡†åº“ç›¸æ¯”å…¶å®ƒè¯­è¨€ï¼Œå‡†å…¥é—¨æ§›è¾ƒé«˜ï¼Œå› æ­¤æœ‰ç†æ•°å’Œå¤æ•°å¹¶æœªåŒ…å«åœ¨æ ‡å‡†åº“ä¸­ï¼š
    - æœ‰ç†æ•°å’Œå¤æ•°
    - ä»»æ„å¤§å°çš„æ•´æ•°å’Œä»»æ„ç²¾åº¦çš„æµ®ç‚¹æ•°
    - å›ºå®šç²¾åº¦çš„åè¿›åˆ¶å°æ•°ï¼Œå¸¸ç”¨äºè´§å¸ç›¸å…³çš„åœºæ™¯
å¥½åœ¨ç¤¾åŒºå·²ç»å¼€å‘å‡ºé«˜è´¨é‡çš„ Rust æ•°å€¼åº“ï¼šnumã€‚

### å­—ç¬¦
æ³¨æ„ï¼Œæˆ‘ä»¬è¿˜æ²¡å¼€å§‹è®²å­—ç¬¦ä¸²ï¼Œä½†æ˜¯è¿™é‡Œæå‰è¯´ä¸€ä¸‹ï¼Œå’Œä¸€äº›è¯­è¨€ä¸åŒï¼ŒRust çš„å­—ç¬¦åªèƒ½ç”¨ '' æ¥è¡¨ç¤ºï¼Œ "" æ˜¯ç•™ç»™å­—ç¬¦ä¸²çš„ã€‚
```rs
fn main() {
    let c = 'z';
    let z = 'â„¤';
    let g = 'å›½';
    let heart_eyed_cat = 'ğŸ˜»';
}
```

### å•å…ƒç±»å‹
 main å‡½æ•°å°±è¿”å›è¿™ä¸ªå•å…ƒç±»å‹ ()ï¼Œä½ ä¸èƒ½è¯´ main å‡½æ•°æ— è¿”å›å€¼ï¼Œå› ä¸ºæ²¡æœ‰è¿”å›å€¼çš„å‡½æ•°åœ¨ Rust ä¸­æ˜¯æœ‰å•ç‹¬çš„å®šä¹‰çš„ï¼šå‘æ•£å‡½æ•°( diverge function )ï¼Œé¡¾åæ€ä¹‰ï¼Œæ— æ³•æ”¶æ•›çš„å‡½æ•°ã€‚

ä¾‹å¦‚å¸¸è§çš„ println!() çš„è¿”å›å€¼ä¹Ÿæ˜¯å•å…ƒç±»å‹ ()ã€‚

å†æ¯”å¦‚ï¼Œä½ å¯ä»¥ç”¨ () ä½œä¸º map çš„å€¼ï¼Œè¡¨ç¤ºæˆ‘ä»¬ä¸å…³æ³¨å…·ä½“çš„å€¼ï¼Œåªå…³æ³¨ keyã€‚ è¿™ç§ç”¨æ³•å’Œ Go è¯­è¨€çš„ struct{} ç±»ä¼¼ï¼Œå¯ä»¥ä½œä¸ºä¸€ä¸ªå€¼ç”¨æ¥å ä½ï¼Œä½†æ˜¯å®Œå…¨ä¸å ç”¨ä»»ä½•å†…å­˜ã€‚
### è¯­å¥

## æ‰€æœ‰æƒå’Œå€Ÿç”¨
### æ‰€æœ‰æƒåŸåˆ™
- Rust ä¸­æ¯ä¸€ä¸ªå€¼éƒ½è¢«ä¸€ä¸ªå˜é‡æ‰€æ‹¥æœ‰ï¼Œè¯¥å˜é‡è¢«ç§°ä¸ºå€¼çš„æ‰€æœ‰è€…
- ä¸€ä¸ªå€¼åŒæ—¶åªèƒ½è¢«ä¸€ä¸ªå˜é‡æ‰€æ‹¥æœ‰ï¼Œæˆ–è€…è¯´ä¸€ä¸ªå€¼åªèƒ½æ‹¥æœ‰ä¸€ä¸ªæ‰€æœ‰è€…
- å½“æ‰€æœ‰è€…(å˜é‡)ç¦»å¼€ä½œç”¨åŸŸèŒƒå›´æ—¶ï¼Œè¿™ä¸ªå€¼å°†è¢«ä¸¢å¼ƒ(drop)

### å˜é‡ç»‘å®šèƒŒåçš„æ•°æ®äº¤äº’
```rs
let s1 = String::from("hello");
let s2 = s1;

```
å®é™…ä¸Šï¼Œ String ç±»å‹æ˜¯ä¸€ä¸ªå¤æ‚ç±»å‹ï¼Œç”±å­˜å‚¨åœ¨æ ˆä¸­çš„å †æŒ‡é’ˆã€å­—ç¬¦ä¸²é•¿åº¦ã€å­—ç¬¦ä¸²å®¹é‡å…±åŒç»„æˆï¼Œå…¶ä¸­å †æŒ‡é’ˆæ˜¯æœ€é‡è¦çš„ï¼Œå®ƒæŒ‡å‘äº†çœŸå®å­˜å‚¨å­—ç¬¦ä¸²å†…å®¹çš„å †å†…å­˜ï¼Œè‡³äºé•¿åº¦å’Œå®¹é‡ï¼Œå¦‚æœä½ æœ‰ Go è¯­è¨€çš„ç»éªŒï¼Œè¿™é‡Œå°±å¾ˆå¥½ç†è§£ï¼šå®¹é‡æ˜¯å †å†…å­˜åˆ†é…ç©ºé—´çš„å¤§å°ï¼Œé•¿åº¦æ˜¯ç›®å‰å·²ç»ä½¿ç”¨çš„å¤§å°ã€‚
```rs
let s1 = String::from("hello");
let s2 = s1;

println!("{}, world!", s1);

```
- Rust ä¸­æ¯ä¸€ä¸ªå€¼éƒ½è¢«ä¸€ä¸ªå˜é‡æ‰€æ‹¥æœ‰ï¼Œè¯¥å˜é‡è¢«ç§°ä¸ºå€¼çš„æ‰€æœ‰è€…
- ä¸€ä¸ªå€¼åŒæ—¶åªèƒ½è¢«ä¸€ä¸ªå˜é‡æ‰€æ‹¥æœ‰ï¼Œæˆ–è€…è¯´ä¸€ä¸ªå€¼åªèƒ½æ‹¥æœ‰ä¸€ä¸ªæ‰€æœ‰è€…
- å½“æ‰€æœ‰è€…(å˜é‡)ç¦»å¼€ä½œç”¨åŸŸèŒƒå›´æ—¶ï¼Œè¿™ä¸ªå€¼å°†è¢«ä¸¢å¼ƒ(drop)
### å‡½æ•°ä¼ å€¼ä¸è¿”å›
```rs
fn main() {
    let s = String::from("hello");  // s è¿›å…¥ä½œç”¨åŸŸ

    takes_ownership(s);             // s çš„å€¼ç§»åŠ¨åˆ°å‡½æ•°é‡Œ ...
                                    // ... æ‰€ä»¥åˆ°è¿™é‡Œä¸å†æœ‰æ•ˆ

    let x = 5;                      // x è¿›å…¥ä½œç”¨åŸŸ

    makes_copy(x);                  // x åº”è¯¥ç§»åŠ¨å‡½æ•°é‡Œï¼Œ
                                    // ä½† i32 æ˜¯ Copy çš„ï¼Œæ‰€ä»¥åœ¨åé¢å¯ç»§ç»­ä½¿ç”¨ x

} // è¿™é‡Œ, x å…ˆç§»å‡ºäº†ä½œç”¨åŸŸï¼Œç„¶åæ˜¯ sã€‚ä½†å› ä¸º s çš„å€¼å·²è¢«ç§»èµ°ï¼Œ
  // æ‰€ä»¥ä¸ä¼šæœ‰ç‰¹æ®Šæ“ä½œ

fn takes_ownership(some_string: String) { // some_string è¿›å…¥ä½œç”¨åŸŸ
    println!("{}", some_string);
} // è¿™é‡Œï¼Œsome_string ç§»å‡ºä½œç”¨åŸŸå¹¶è°ƒç”¨ `drop` æ–¹æ³•ã€‚å ç”¨çš„å†…å­˜è¢«é‡Šæ”¾

fn makes_copy(some_integer: i32) { // some_integer è¿›å…¥ä½œç”¨åŸŸ
    println!("{}", some_integer);
} // è¿™é‡Œï¼Œsome_integer ç§»å‡ºä½œç”¨åŸŸã€‚ä¸ä¼šæœ‰ç‰¹æ®Šæ“ä½œ
```
####  å¼•ç”¨ä¸å€Ÿç”¨
ä¸è¿‡å¯å˜å¼•ç”¨å¹¶ä¸æ˜¯éšå¿ƒæ‰€æ¬²ã€æƒ³ç”¨å°±ç”¨çš„ï¼Œå®ƒæœ‰ä¸€ä¸ªå¾ˆå¤§çš„é™åˆ¶ï¼š åŒä¸€ä½œç”¨åŸŸï¼Œç‰¹å®šæ•°æ®åªèƒ½æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼š

å¯å˜å¼•ç”¨ä¸ä¸å¯å˜å¼•ç”¨ä¸èƒ½åŒæ—¶å­˜åœ¨
```rs
let mut s = String::from("hello");

let r1 = &s; // æ²¡é—®é¢˜
let r2 = &s; // æ²¡é—®é¢˜
let r3 = &mut s; // å¤§é—®é¢˜

println!("{}, {}, and {}", r1, r2, r3);

```

**æ‚¬å‚å¼•ç”¨(Dangling References)**
```rs

fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");

    &s
}
```

## å¤åˆç±»å‹
### å­—ç¬¦ä¸²
#### åˆ‡ç‰‡(slice)
åˆ‡ç‰‡å¹¶ä¸æ˜¯ Rust ç‹¬æœ‰çš„æ¦‚å¿µï¼Œåœ¨ Go è¯­è¨€ä¸­å°±éå¸¸æµè¡Œï¼Œå®ƒå…è®¸ä½ å¼•ç”¨é›†åˆä¸­éƒ¨åˆ†è¿ç»­çš„å…ƒç´ åºåˆ—ï¼Œè€Œä¸æ˜¯å¼•ç”¨æ•´ä¸ªé›†åˆã€‚
```rs
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];

```
### å…ƒç»„
```rs
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```
### ç»“æ„ä½“
```rs

// æœ€ç®€
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
fn main() {
    let u1 = User {
        email: String::from("someone@example.com"),
        username: String::from("sunface"),
        active: true,
        sign_in_count: 1,
    };

    let u2 = set_email(u1);
} 

fn set_email(u: User) -> User {
    User {
        email: String::from("contact@im.dev"),
        ..u
    
    }
}

```

```rs
// æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ #[derive(Debug)] è®©ç»“æ„ä½“å˜æˆå¯æ‰“å°çš„.
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale), // print debug info to stderr and assign the value of  `30 * scale` to `width`
        height: 50,
    };

    dbg!(&rect1); // print debug info to stderr

    println!("{:?}", rect1); // print debug info to stdout
}
```
### æšä¸¾
<!-- æšä¸¾å˜ä½“å¯ä»¥é€šè¿‡â€œasâ€è½¬æ¢ä¸ºæ•´æ•° -->
```rs
enum PokerSuit {
  Clubs,
  Spades,
  Diamonds,
  Hearts,
}
```

```RS
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::Move { x: 1, y: 1 };  // åˆ›å»ºä¸€ä¸ªMoveå˜ä½“çš„Messageæšä¸¾å®ä¾‹ï¼ŒåŒ…å«xå’Œyå­—æ®µçš„å€¼
// ä½ ä½¿ç”¨if letè¯­æ³•æ¥è¿›è¡Œæ¨¡å¼åŒ¹é…ã€‚å¦‚æœmsgæ˜¯Message::Moveå˜ä½“ï¼Œå¹¶å°†å…¶è§£æ„ä¸ºx: aå’Œy: bï¼Œé‚£ä¹ˆå°±è¿›å…¥ifæ¡ä»¶åˆ†æ”¯ã€‚æ­¤
    if let Message::Move { x: a, y: b } = msg {
        // ä½¿ç”¨æ¨¡å¼åŒ¹é…è§£æ„Messageæšä¸¾
        // å¦‚æœmsgæ˜¯Moveå˜ä½“ï¼Œå¹¶å°†xå’Œyå­—æ®µè§£æ„ä¸ºaå’Œbå˜é‡
        // è¿›å…¥ifæ¡ä»¶åˆ†æ”¯
        assert_eq!(a, b);
    } else {
        panic!("NEVER LET THIS RUNï¼");
    }
}
```

å¤„ç†ç©ºå€¼
```RS
fn main() {
    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);

    if let Some(n) = six {
        println!("{}", n);
        return
    } 
    
    panic!("NEVER LET THIS RUNï¼");
} 

fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}
```
### æ•°ç»„

## æµç¨‹æ§åˆ¶
### if else
```rs
fn main() {
    let n = 6;

    if n % 4 == 0 {
        println!("number is divisible by 4");
    } else if n % 3 == 0 {
        println!("number is divisible by 3");
    } else if n % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
```
### for
|ä½¿ç”¨æ–¹æ³•|	ç­‰ä»·ä½¿ç”¨æ–¹å¼|	æ‰€æœ‰æƒ|
|------|-------|-------|
|for item in collection	|for item in IntoIterator::into_iter(collection)	|è½¬ç§»æ‰€æœ‰æƒ|
|for item in &collection	|for item in collection.iter()|	ä¸å¯å˜å€Ÿç”¨|
|for item in &mut collection	|for item in collection.iter_mut()|	å¯å˜å€Ÿç”¨|

åœ¨å¾ªç¯è·å–å…ƒç´ 
```rs
fn main() {
    let a = [4, 3, 2, 1];
    // `.iter()` æ–¹æ³•æŠŠ `a` æ•°ç»„å˜æˆä¸€ä¸ªè¿­ä»£å™¨
    for (i, v) in a.iter().enumerate() {
        println!("ç¬¬{}ä¸ªå…ƒç´ æ˜¯{}", i + 1, v);
    }
}
```
### loop å¾ªç¯
```rs
fn main() {
    loop {
        println!("again!");
    }
}
```
## æ¨¡å¼åŒ¹é…
### match å’Œ if let
#### match
```rs
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny =>  {
            println!("Lucky penny!");
            1
        },
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}

```

ç»‘å®šåŒ¹é…

```rs
enum Action {
    Say(String),
    MoveTo(i32, i32),
    ChangeColorRGB(u16, u16, u16),
}

fn main() {
    let actions = [
        Action::Say("Hello Rust".to_string()),
        Action::MoveTo(1,2),
        Action::ChangeColorRGB(255,255,0),
    ];
    for action in actions {
        match action {
            Action::Say(s) => {
                println!("{}", s);
            },
            Action::MoveTo(x, y) => {
                println!("point from (0, 0) move to ({}, {})", x, y);
            },
            Action::ChangeColorRGB(r, g, _) => {
                println!("change color into '(r:{}, g:{}, b:0)', 'b' has been ignored",
                    r, g,
                );
            }
        }
    }
}
```

```rs
v.iter().filter(|x| matches!(x, MyEnum::Foo));
```

#### if let åŒ¹é…
```rs
if let Some(3) = v {
    println!("three");
}

```
### è§£æ„ Option
```rs
enum Option<T> {
    Some(T),
    None,
}

```
### æ¨¡å¼é€‚ç”¨åœºæ™¯
æ¨¡å¼æ˜¯ Rust ä¸­çš„ç‰¹æ®Šè¯­æ³•ï¼Œå®ƒç”¨æ¥åŒ¹é…ç±»å‹ä¸­çš„ç»“æ„å’Œæ•°æ®ï¼Œå®ƒå¾€å¾€å’Œ match è¡¨è¾¾å¼è”ç”¨ï¼Œä»¥å®ç°å¼ºå¤§çš„æ¨¡å¼åŒ¹é…èƒ½åŠ›ã€‚æ¨¡å¼ä¸€èˆ¬ç”±ä»¥ä¸‹å†…å®¹ç»„åˆè€Œæˆï¼š
    - å­—é¢å€¼
    - è§£æ„çš„æ•°ç»„ã€æšä¸¾ã€ç»“æ„ä½“æˆ–è€…å…ƒç»„
    - å˜é‡
    - é€šé…ç¬¦
    - å ä½ç¬¦
### å…¨æ¨¡å¼åˆ—è¡¨
####      è§£æ„ç»“æ„ä½“
```rs
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}



fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } => println!("On the x axis at {}", x),
        Point { x: 0, y } => println!("On the y axis at {}", y),
        Point { x, y } => println!("On neither axis: ({}, {})", x, y),
    }
}



enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit => {
            println!("The Quit variant has no data to destructure.")
        }
        Message::Move { x, y } => {
            println!(
                "Move in the x direction {} and in the y direction {}",
                x,
                y
            );
        }
        Message::Write(text) => println!("Text message: {}", text),
        Message::ChangeColor(r, g, b) => {
            println!(
                "Change the color to red {}, green {}, and blue {}",
                r,
                g,
                b
            )
        }
    }
}




enum Color {
   Rgb(i32, i32, i32),
   Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) => {
            println!(
                "Change the color to red {}, green {}, and blue {}",
                r,
                g,
                b
            )
        }
        Message::ChangeColor(Color::Hsv(h, s, v)) => {
            println!(
                "Change the color to hue {}, saturation {}, and value {}",
                h,
                s,
                v
            )
        }
        _ => ()
    }
}
```

### @å‰ç»‘å®šåè§£æ„(Rust 1.56 æ–°å¢)
```rs
#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    // ç»‘å®šæ–°å˜é‡ `p`ï¼ŒåŒæ—¶å¯¹ `Point` è¿›è¡Œè§£æ„
    let p @ Point {x: px, y: py } = Point {x: 10, y: 23};
    println!("x: {}, y: {}", px, py);
    println!("{:?}", p);


    let point = Point {x: 10, y: 5};
    if let p @ Point {x: 10, y} = point {
        println!("x is 10 and y is {} in {:?}", y, p);
    } else {
        println!("x was not 10 :(");
    }
}
```
## æ–¹æ³•
å®šä¹‰æ–¹æ³•
- self è¡¨ç¤º Rectangle çš„æ‰€æœ‰æƒè½¬ç§»åˆ°è¯¥æ–¹æ³•ä¸­ï¼Œè¿™ç§å½¢å¼ç”¨çš„è¾ƒå°‘
- &self è¡¨ç¤ºè¯¥æ–¹æ³•å¯¹ Rectangle çš„ä¸å¯å˜å€Ÿç”¨
- &mut self è¡¨ç¤ºå¯å˜å€Ÿç”¨(åŸŸå†…å¯¹å¯å˜æ•°æ®è¿›è¡Œä¸´æ—¶ä¿®æ”¹çš„æœºåˆ¶)
```rs
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    // newæ˜¯Circleçš„å…³è”å‡½æ•°ï¼Œå› ä¸ºå®ƒçš„ç¬¬ä¸€ä¸ªå‚æ•°ä¸æ˜¯selfï¼Œä¸”newå¹¶ä¸æ˜¯å…³é”®å­—
    // è¿™ç§æ–¹æ³•å¾€å¾€ç”¨äºåˆå§‹åŒ–å½“å‰ç»“æ„ä½“çš„å®ä¾‹
    fn new(x: f64, y: f64, radius: f64) -> Circle {
        Circle {
            x: x,
            y: y,
            radius: radius,
        }
    }

    // Circleçš„æ–¹æ³•ï¼Œ&selfè¡¨ç¤ºå€Ÿç”¨å½“å‰çš„Circleç»“æ„ä½“
    fn area(&self) -> f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}
```

### ä¸ºæšä¸¾å®ç°æ–¹æ³•
```rs
#![allow(unused)]
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl Message {
    fn call(&self) {
        // åœ¨è¿™é‡Œå®šä¹‰æ–¹æ³•ä½“
    }
}

fn main() {
    let m = Message::Write(String::from("hello"));
    m.call();
}

```
##  æ³›å‹å’Œç‰¹å¾
### æ³›å‹ Genericsæ³›å‹

ä½¿ç”¨æ³›å‹å‚æ•°ï¼Œæœ‰ä¸€ä¸ªå…ˆå†³æ¡ä»¶ï¼Œå¿…éœ€åœ¨ä½¿ç”¨å‰å¯¹å…¶è¿›è¡Œå£°æ˜ï¼š
```rs
fn largest<T>(list: &[T]) -> T {
```

è¯¥æ³›å‹å‡½æ•°çš„ä½œç”¨æ˜¯ä»åˆ—è¡¨ä¸­æ‰¾å‡ºæœ€å¤§çš„å€¼ï¼Œå…¶ä¸­åˆ—è¡¨ä¸­çš„å…ƒç´ ç±»å‹ä¸º Tã€‚é¦–å…ˆ largest&lt;T> å¯¹æ³›å‹å‚æ•° T è¿›è¡Œäº†å£°æ˜ï¼Œç„¶åæ‰åœ¨å‡½æ•°å‚æ•°ä¸­è¿›è¡Œä½¿ç”¨è¯¥æ³›å‹å‚æ•° list: &[T] ã€‚



ä¸‹é¢æ˜¯ä¸€ä¸ªé”™è¯¯çš„æ³›å‹å‡½æ•°çš„å®ç°ï¼š
```rs
fn largest<T>(list: &[T]) -> T {
    let mut largest = list[0];

    for &item in list.iter() {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result);
}
```

è¿è¡ŒåæŠ¥é”™ï¼š
```shell
error[E0369]: binary operation `>` cannot be applied to type `T` // `>`æ“ä½œç¬¦ä¸èƒ½ç”¨äºç±»å‹`T`
 --> src/main.rs:5:17
  |
5 |         if item > largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
help: consider restricting type parameter `T` // è€ƒè™‘å¯¹Tè¿›è¡Œç±»å‹ä¸Šçš„é™åˆ¶ :
  |
1 | fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> T {
  |             ++++++++++++++++++++++
```

å› ä¸º T å¯ä»¥æ˜¯ä»»ä½•ç±»å‹ï¼Œä½†ä¸æ˜¯æ‰€æœ‰çš„ç±»å‹éƒ½èƒ½è¿›è¡Œæ¯”è¾ƒï¼Œå› æ­¤ä¸Šé¢çš„é”™è¯¯ä¸­ï¼Œç¼–è¯‘å™¨å»ºè®®æˆ‘ä»¬ç»™ T æ·»åŠ ä¸€ä¸ªç±»å‹é™åˆ¶ï¼šä½¿ç”¨ std::cmp::PartialOrd ç‰¹å¾ï¼ˆTraitï¼‰å¯¹ T è¿›è¡Œé™åˆ¶ï¼Œç‰¹å¾åœ¨ä¸‹ä¸€èŠ‚ä¼šè¯¦ç»†ä»‹ç»ï¼Œç°åœ¨ä½ åªè¦ç†è§£ï¼Œè¯¥ç‰¹å¾çš„ç›®çš„å°±æ˜¯è®©ç±»å‹å®ç°å¯æ¯”è¾ƒçš„åŠŸèƒ½ã€‚


#### ç»“æ„ä½“ä¸­ä½¿ç”¨æ³›å‹
ç»“æ„ä½“ä¸­çš„å­—æ®µç±»å‹ä¹Ÿå¯ä»¥ç”¨æ³›å‹æ¥å®šä¹‰ï¼Œä¸‹é¢ä»£ç å®šä¹‰äº†ä¸€ä¸ªåæ ‡ç‚¹ Pointï¼Œå®ƒå¯ä»¥å­˜æ”¾ä»»ä½•ç±»å‹çš„åæ ‡å€¼ï¼š
```rs
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
```

è¿™é‡Œæœ‰ä¸¤ç‚¹éœ€è¦ç‰¹åˆ«çš„æ³¨æ„ï¼š

- æå‰å£°æ˜ï¼Œè·Ÿæ³›å‹å‡½æ•°å®šä¹‰ç±»ä¼¼ï¼Œé¦–å…ˆæˆ‘ä»¬åœ¨ä½¿ç”¨æ³›å‹å‚æ•°ä¹‹å‰å¿…éœ€è¦è¿›è¡Œå£°æ˜ Point&lt;T>ï¼Œæ¥ç€å°±å¯ä»¥åœ¨ç»“æ„ä½“çš„å­—æ®µç±»å‹ä¸­ä½¿ç”¨ T æ¥æ›¿ä»£å…·ä½“çš„ç±»å‹
- x å’Œ y æ˜¯ç›¸åŒçš„ç±»å‹
ç¬¬äºŒç‚¹éå¸¸é‡è¦ï¼Œå¦‚æœä½¿ç”¨ä¸åŒçš„ç±»å‹ï¼Œé‚£ä¹ˆå®ƒä¼šå¯¼è‡´ä¸‹é¢ä»£ç çš„æŠ¥é”™ï¼š



å¦‚æœæƒ³è®© x å’Œ y æ—¢èƒ½ç±»å‹ç›¸åŒï¼Œåˆèƒ½ç±»å‹ä¸åŒï¼Œå°±éœ€è¦ä½¿ç”¨ä¸åŒçš„æ³›å‹å‚æ•°ï¼š
```rs
struct Point<T,U> {
    x: T,
    y: U,
}
fn main() {
    let p = Point{x: 1, y :1.1};
}
```

åˆ‡è®°ï¼Œæ‰€æœ‰çš„æ³›å‹å‚æ•°éƒ½è¦æå‰å£°æ˜.

#### æšä¸¾ä¸­ä½¿ç”¨æ³›å‹
æåˆ°æšä¸¾ç±»å‹ï¼ŒOption æ°¸è¿œæ˜¯ç¬¬ä¸€ä¸ªåº”è¯¥è¢«æƒ³èµ·æ¥çš„ï¼Œåœ¨ä¹‹å‰çš„ç« èŠ‚ä¸­ï¼Œå®ƒä¹Ÿå¤šæ¬¡å‡ºç°ï¼š
```rs
enum Option<T> {
    Some(T),
    None,
}
```

Option&lt;T> æ˜¯ä¸€ä¸ªæ‹¥æœ‰æ³›å‹ T çš„æšä¸¾ç±»å‹ï¼Œå®ƒç¬¬ä¸€ä¸ªæˆå‘˜æ˜¯ Some(T)ï¼Œå­˜æ”¾äº†ä¸€ä¸ªç±»å‹ä¸º T çš„å€¼ã€‚å¾—ç›Šäºæ³›å‹çš„å¼•å…¥ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ä»»ä½•ä¸€ä¸ªéœ€è¦è¿”å›å€¼çš„å‡½æ•°ä¸­ï¼Œå»ä½¿ç”¨ Option&lt;T> æšä¸¾ç±»å‹æ¥åšä¸ºè¿”å›å€¼ï¼Œç”¨äºè¿”å›ä¸€ä¸ªä»»æ„ç±»å‹çš„å€¼ Some(T)ï¼Œæˆ–è€…æ²¡æœ‰å€¼ Noneã€‚

```rs
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```


è¿™ä¸ªæšä¸¾å’Œ Option ä¸€æ ·ï¼Œä¸»è¦ç”¨äºå‡½æ•°è¿”å›å€¼ï¼Œä¸ Option ç”¨äºå€¼çš„å­˜åœ¨ä¸å¦ä¸åŒï¼ŒResult å…³æ³¨çš„ä¸»è¦æ˜¯å€¼çš„æ­£ç¡®æ€§ã€‚

å¦‚æœå‡½æ•°æ­£å¸¸è¿è¡Œï¼Œåˆ™æœ€åè¿”å›ä¸€ä¸ª Ok(T)ï¼ŒT æ˜¯å‡½æ•°å…·ä½“çš„è¿”å›å€¼ç±»å‹ï¼Œå¦‚æœå‡½æ•°å¼‚å¸¸è¿è¡Œï¼Œåˆ™è¿”å›ä¸€ä¸ª Err(E)ï¼ŒE æ˜¯é”™è¯¯ç±»å‹ã€‚ä¾‹å¦‚æ‰“å¼€ä¸€ä¸ªæ–‡ä»¶ï¼šå¦‚æœæˆåŠŸæ‰“å¼€æ–‡ä»¶ï¼Œåˆ™è¿”å› Ok(std::fs::File)ï¼Œå› æ­¤ T å¯¹åº”çš„æ˜¯ std::fs::File ç±»å‹ï¼›è€Œå½“æ‰“å¼€æ–‡ä»¶æ—¶å‡ºç°é—®é¢˜æ—¶ï¼Œè¿”å› Err(std::io::Error)ï¼ŒE å¯¹åº”çš„å°±æ˜¯ std::io::Error ç±»å‹ã€‚

#### æ–¹æ³•ä¸­ä½¿ç”¨æ³›å‹
æ–¹æ³•ä¸Šä¹Ÿå¯ä»¥ä½¿ç”¨æ³›å‹ï¼š
```rs
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}
fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
```



ä½¿ç”¨æ³›å‹å‚æ•°å‰ï¼Œä¾ç„¶éœ€è¦æå‰å£°æ˜ï¼šimpl&lt;T>ï¼Œåªæœ‰æå‰å£°æ˜äº†ï¼Œæˆ‘ä»¬æ‰èƒ½åœ¨Point&lt;T>ä¸­ä½¿ç”¨å®ƒï¼Œè¿™æ · Rust å°±çŸ¥é“ Point çš„å°–æ‹¬å·ä¸­çš„ç±»å‹æ˜¯æ³›å‹è€Œä¸æ˜¯å…·ä½“ç±»å‹ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™é‡Œçš„ Point&lt;T> ä¸å†æ˜¯æ³›å‹å£°æ˜ï¼Œè€Œæ˜¯ä¸€ä¸ªå®Œæ•´çš„ç»“æ„ä½“ç±»å‹ï¼Œå› ä¸ºæˆ‘ä»¬å®šä¹‰çš„ç»“æ„ä½“å°±æ˜¯ Point&lt;T> è€Œä¸å†æ˜¯ Pointã€‚

é™¤äº†ç»“æ„ä½“ä¸­çš„æ³›å‹å‚æ•°ï¼Œæˆ‘ä»¬è¿˜èƒ½åœ¨è¯¥ç»“æ„ä½“çš„æ–¹æ³•ä¸­å®šä¹‰é¢å¤–çš„æ³›å‹å‚æ•°ï¼Œå°±è·Ÿæ³›å‹å‡½æ•°ä¸€æ ·ï¼š
```rs
struct Point<T, U> {
    x: T,
    y: U,
}

impl<T, U> Point<T, U> {
    fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c'};

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}
```

è¿™ä¸ªä¾‹å­ä¸­ï¼ŒT,U æ˜¯å®šä¹‰åœ¨ç»“æ„ä½“ Point ä¸Šçš„æ³›å‹å‚æ•°ï¼ŒV,W æ˜¯å•ç‹¬å®šä¹‰åœ¨æ–¹æ³• mixup ä¸Šçš„æ³›å‹å‚æ•°ï¼Œå®ƒä»¬å¹¶ä¸å†²çªï¼Œè¯´ç™½äº†ï¼Œä½ å¯ä»¥ç†è§£ä¸ºï¼Œä¸€ä¸ªæ˜¯ç»“æ„ä½“æ³›å‹ï¼Œä¸€ä¸ªæ˜¯å‡½æ•°æ³›å‹ã€‚

#### ä¸ºå…·ä½“çš„æ³›å‹ç±»å‹å®ç°æ–¹æ³•
å¯¹äº Point&lt;T> ç±»å‹ï¼Œä½ ä¸ä»…èƒ½å®šä¹‰åŸºäº T çš„æ–¹æ³•ï¼Œè¿˜èƒ½é’ˆå¯¹ç‰¹å®šçš„å…·ä½“ç±»å‹ï¼Œè¿›è¡Œæ–¹æ³•å®šä¹‰ï¼š
```rs
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
```

è¿™æ®µä»£ç æ„å‘³ç€ Point&lt;f32> ç±»å‹ä¼šæœ‰ä¸€ä¸ªæ–¹æ³• distance_from_originï¼Œè€Œå…¶ä»– T ä¸æ˜¯ f32 ç±»å‹çš„ Point&lt;T> å®ä¾‹åˆ™æ²¡æœ‰å®šä¹‰æ­¤æ–¹æ³•ã€‚è¿™ä¸ªæ–¹æ³•è®¡ç®—ç‚¹å®ä¾‹ä¸åæ ‡(0.0, 0.0) ä¹‹é—´çš„è·ç¦»ï¼Œå¹¶ä½¿ç”¨äº†åªèƒ½ç”¨äºæµ®ç‚¹å‹çš„æ•°å­¦è¿ç®—ç¬¦ã€‚

#### const æ³›å‹
const æ³›å‹ï¼Œä¹Ÿå°±æ˜¯é’ˆå¯¹å€¼çš„æ³›å‹ï¼Œæ­£å¥½å¯ä»¥ç”¨äºå¤„ç†æ•°ç»„é•¿åº¦çš„é—®é¢˜ï¼š
```rs
fn display_array<T: std::fmt::Debug, const N: usize>(arr: [T; N]) {
    println!("{:?}", arr);
}
fn main() {
    let arr: [i32; 3] = [1, 2, 3];
    display_array(arr);

    let arr: [i32; 2] = [1, 2];
    display_array(arr);
}
```

å¦‚ä¸Šæ‰€ç¤ºï¼Œæˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªç±»å‹ä¸º [T; N] çš„æ•°ç»„ï¼Œå…¶ä¸­ T æ˜¯ä¸€ä¸ªåŸºäºç±»å‹çš„æ³›å‹å‚æ•°ï¼Œè¿™ä¸ªå’Œä¹‹å‰è®²çš„æ³›å‹æ²¡æœ‰åŒºåˆ«ï¼Œè€Œé‡ç‚¹åœ¨äº N è¿™ä¸ªæ³›å‹å‚æ•°ï¼Œå®ƒæ˜¯ä¸€ä¸ªåŸºäºå€¼çš„æ³›å‹å‚æ•°ï¼å› ä¸ºå®ƒç”¨æ¥æ›¿ä»£çš„æ˜¯æ•°ç»„çš„é•¿åº¦ã€‚

N å°±æ˜¯ const æ³›å‹ï¼Œå®šä¹‰çš„è¯­æ³•æ˜¯ const N: usizeï¼Œè¡¨ç¤º const æ³›å‹ N ï¼Œå®ƒåŸºäºçš„å€¼ç±»å‹æ˜¯ usizeã€‚

åœ¨æ³›å‹å‚æ•°ä¹‹å‰ï¼ŒRust å®Œå…¨ä¸é€‚åˆå¤æ‚çŸ©é˜µçš„è¿ç®—ï¼Œè‡ªä»æœ‰äº† const æ³›å‹ï¼Œä¸€åˆ‡å³å°†æ”¹å˜ã€‚

#### const æ³›å‹è¡¨è¾¾å¼
å‡è®¾æˆ‘ä»¬æŸæ®µä»£ç éœ€è¦åœ¨å†…å­˜å¾ˆå°çš„å¹³å°ä¸Šå·¥ä½œï¼Œå› æ­¤éœ€è¦é™åˆ¶å‡½æ•°å‚æ•°å ç”¨çš„å†…å­˜å¤§å°ï¼Œæ­¤æ—¶å°±å¯ä»¥ä½¿ç”¨ const æ³›å‹è¡¨è¾¾å¼æ¥å®ç°ï¼š
```rs
// ç›®å‰åªèƒ½åœ¨nightlyç‰ˆæœ¬ä¸‹ä½¿ç”¨
#![allow(incomplete_features)]
#![feature(generic_const_exprs)]

fn something<T>(val: T)
where
    Assert<{ core::mem::size_of::<T>() < 768 }>: IsTrue,
    //       ^-----------------------------^ è¿™é‡Œæ˜¯ä¸€ä¸ª const è¡¨è¾¾å¼ï¼Œæ¢æˆå…¶å®ƒçš„ const è¡¨è¾¾å¼ä¹Ÿå¯ä»¥
{
    //
}

fn main() {
    something([0u8; 0]); // ok
    something([0u8; 512]); // ok
    something([0u8; 1024]); // ç¼–è¯‘é”™è¯¯ï¼Œæ•°ç»„é•¿åº¦æ˜¯1024å­—èŠ‚ï¼Œè¶…è¿‡äº†768å­—èŠ‚çš„å‚æ•°é•¿åº¦é™åˆ¶
}

// ---

pub enum Assert<const CHECK: bool> {
    //
}

pub trait IsTrue {
    //
}

impl IsTrue for Assert<true> {
    //
}
```


### ç‰¹å¾ Trait
#### å®šä¹‰ç‰¹å¾
å¦‚æœä¸åŒçš„ç±»å‹å…·æœ‰ç›¸åŒçš„è¡Œä¸ºï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥å®šä¹‰ä¸€ä¸ªç‰¹å¾ï¼Œç„¶åä¸ºè¿™äº›ç±»å‹å®ç°è¯¥ç‰¹å¾ã€‚å®šä¹‰ç‰¹å¾æ˜¯æŠŠä¸€äº›æ–¹æ³•ç»„åˆåœ¨ä¸€èµ·ï¼Œç›®çš„æ˜¯å®šä¹‰ä¸€ä¸ªå®ç°æŸäº›ç›®æ ‡æ‰€å¿…éœ€çš„è¡Œä¸ºçš„é›†åˆã€‚

ä¾‹å¦‚ï¼Œæˆ‘ä»¬ç°åœ¨æœ‰æ–‡ç«  Post å’Œå¾®åš Weibo ä¸¤ç§å†…å®¹è½½ä½“ï¼Œè€Œæˆ‘ä»¬æƒ³å¯¹ç›¸åº”çš„å†…å®¹è¿›è¡Œæ€»ç»“ï¼Œä¹Ÿå°±æ˜¯æ— è®ºæ˜¯æ–‡ç« å†…å®¹ï¼Œè¿˜æ˜¯å¾®åšå†…å®¹ï¼Œéƒ½å¯ä»¥åœ¨æŸä¸ªæ—¶é—´ç‚¹è¿›è¡Œæ€»ç»“ï¼Œé‚£ä¹ˆæ€»ç»“è¿™ä¸ªè¡Œä¸ºå°±æ˜¯å…±äº«çš„ï¼Œå› æ­¤å¯ä»¥ç”¨ç‰¹å¾æ¥å®šä¹‰ï¼š
```rust
pub trait Summary {
    fn summarize(&self) -> String;
}
```

è¿™é‡Œä½¿ç”¨ trait å…³é”®å­—æ¥å£°æ˜ä¸€ä¸ªç‰¹å¾ï¼ŒSummary æ˜¯ç‰¹å¾åã€‚åœ¨å¤§æ‹¬å·ä¸­å®šä¹‰äº†è¯¥ç‰¹å¾çš„æ‰€æœ‰æ–¹æ³•ï¼Œåœ¨è¿™ä¸ªä¾‹å­ä¸­æ˜¯ï¼š fn summarize(&self) -> Stringã€‚

ç‰¹å¾åªå®šä¹‰è¡Œä¸ºçœ‹èµ·æ¥æ˜¯ä»€ä¹ˆæ ·çš„ï¼Œè€Œä¸å®šä¹‰è¡Œä¸ºå…·ä½“æ˜¯æ€ä¹ˆæ ·çš„ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åªå®šä¹‰ç‰¹å¾æ–¹æ³•çš„ç­¾åï¼Œè€Œä¸è¿›è¡Œå®ç°ï¼Œæ­¤æ—¶æ–¹æ³•ç­¾åç»“å°¾æ˜¯ ;ï¼Œè€Œä¸æ˜¯ä¸€ä¸ª {}ã€‚

#### ä¸ºç±»å‹å®ç°ç‰¹å¾
å› ä¸ºç‰¹å¾åªå®šä¹‰è¡Œä¸ºçœ‹èµ·æ¥æ˜¯ä»€ä¹ˆæ ·çš„ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦ä¸ºç±»å‹å®ç°å…·ä½“çš„ç‰¹å¾ï¼Œå®šä¹‰è¡Œä¸ºå…·ä½“æ˜¯æ€ä¹ˆæ ·çš„ã€‚

é¦–å…ˆæ¥ä¸º Post å’Œ Weibo å®ç° Summary ç‰¹å¾ï¼š
```rs
pub trait Summary {
    fn summarize(&self) -> String;
}
pub struct Post {
    pub title: String, // æ ‡é¢˜
    pub author: String, // ä½œè€…
    pub content: String, // å†…å®¹
}

impl Summary for Post {
    fn summarize(&self) -> String {
        format!("æ–‡ç« {}, ä½œè€…æ˜¯{}", self.title, self.author)
    }
}

pub struct Weibo {
    pub username: String,
    pub content: String
}

impl Summary for Weibo {
    fn summarize(&self) -> String {
        format!("{}å‘è¡¨äº†å¾®åš{}", self.username, self.content)
    }
}
```
å®ç°ç‰¹å¾çš„è¯­æ³•ä¸ä¸ºç»“æ„ä½“ã€æšä¸¾å®ç°æ–¹æ³•å¾ˆåƒï¼šimpl Summary for Postï¼Œè¯»ä½œâ€œä¸º Post ç±»å‹å®ç° Summary ç‰¹å¾â€ï¼Œç„¶ååœ¨ impl çš„èŠ±æ‹¬å·ä¸­å®ç°è¯¥ç‰¹å¾çš„å…·ä½“æ–¹æ³•ã€‚

æ¥ä¸‹æ¥å°±å¯ä»¥åœ¨è¿™ä¸ªç±»å‹ä¸Šè°ƒç”¨ç‰¹å¾çš„æ–¹æ³•ï¼š
```rust
fn main() {
    let post = Post{title: "Rustè¯­è¨€ç®€ä»‹".to_string(),author: "Sunface".to_string(), content: "Rustæ£’æäº†!".to_string()};
    let weibo = Weibo{username: "sunface".to_string(),content: "å¥½åƒå¾®åšæ²¡Tweetå¥½ç”¨".to_string()};

    println!("{}",post.summarize());
    println!("{}",weibo.summarize());
}
```
è¿è¡Œè¾“å‡ºï¼š
```shell
æ–‡ç«  Rust è¯­è¨€ç®€ä»‹, ä½œè€…æ˜¯Sunface
sunfaceå‘è¡¨äº†å¾®åšå¥½åƒå¾®åšæ²¡Tweetå¥½ç”¨
```

#### ç‰¹å¾å®šä¹‰ä¸å®ç°çš„ä½ç½®(å­¤å„¿è§„åˆ™)
ä¸Šé¢æˆ‘ä»¬å°† Summary å®šä¹‰æˆäº† pub å…¬å¼€çš„ã€‚è¿™æ ·ï¼Œå¦‚æœä»–äººæƒ³è¦ä½¿ç”¨æˆ‘ä»¬çš„ Summary ç‰¹å¾ï¼Œåˆ™å¯ä»¥å¼•å…¥åˆ°ä»–ä»¬çš„åŒ…ä¸­ï¼Œç„¶åå†è¿›è¡Œå®ç°ã€‚

å…³äºç‰¹å¾å®ç°ä¸å®šä¹‰çš„ä½ç½®ï¼Œæœ‰ä¸€æ¡éå¸¸é‡è¦çš„åŸåˆ™ï¼šå¦‚æœä½ æƒ³è¦ä¸ºç±»å‹ A å®ç°ç‰¹å¾ Tï¼Œé‚£ä¹ˆ A æˆ–è€… T è‡³å°‘æœ‰ä¸€ä¸ªæ˜¯åœ¨å½“å‰ä½œç”¨åŸŸä¸­å®šä¹‰çš„ï¼ ä¾‹å¦‚æˆ‘ä»¬å¯ä»¥ä¸ºä¸Šé¢çš„ Post ç±»å‹å®ç°æ ‡å‡†åº“ä¸­çš„ Display ç‰¹å¾ï¼Œè¿™æ˜¯å› ä¸º Post ç±»å‹å®šä¹‰åœ¨å½“å‰çš„ä½œç”¨åŸŸä¸­ã€‚åŒæ—¶ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥åœ¨å½“å‰åŒ…ä¸­ä¸º String ç±»å‹å®ç° Summary ç‰¹å¾ï¼Œå› ä¸º Summary å®šä¹‰åœ¨å½“å‰ä½œç”¨åŸŸä¸­ã€‚
#### é»˜è®¤å®ç°
ä½ å¯ä»¥åœ¨ç‰¹å¾ä¸­å®šä¹‰å…·æœ‰é»˜è®¤å®ç°çš„æ–¹æ³•ï¼Œè¿™æ ·å…¶å®ƒç±»å‹æ— éœ€å†å®ç°è¯¥æ–¹æ³•ï¼Œæˆ–è€…ä¹Ÿå¯ä»¥é€‰æ‹©é‡è½½è¯¥æ–¹æ³•ï¼š
```rsut
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(Read more...)")
    }
}
```

ä¸Šé¢ä¸º Summary å®šä¹‰äº†ä¸€ä¸ªé»˜è®¤å®ç°ï¼Œä¸‹é¢æˆ‘ä»¬ç¼–å†™æ®µä»£ç æ¥æµ‹è¯•ä¸‹ï¼š
```rust
impl Summary for Post {}

impl Summary for Weibo {
    fn summarize(&self) -> String {
        format!("{}å‘è¡¨äº†å¾®åš{}", self.username, self.content)
    }
}
```

å¯ä»¥çœ‹åˆ°ï¼ŒPost é€‰æ‹©äº†é»˜è®¤å®ç°ï¼Œè€Œ Weibo é‡è½½äº†è¯¥æ–¹æ³•ï¼Œè°ƒç”¨å’Œè¾“å‡ºå¦‚ä¸‹ï¼š
```rust
    println!("{}",post.summarize());
    println!("{}",weibo.summarize());

```
```shell
(Read more...)
sunfaceå‘è¡¨äº†å¾®åšå¥½åƒå¾®åšæ²¡Tweetå¥½ç”¨

```

é»˜è®¤å®ç°å…è®¸è°ƒç”¨ç›¸åŒç‰¹å¾ä¸­çš„å…¶ä»–æ–¹æ³•ï¼Œå“ªæ€•è¿™äº›æ–¹æ³•æ²¡æœ‰é»˜è®¤å®ç°ã€‚å¦‚æ­¤ï¼Œç‰¹å¾å¯ä»¥æä¾›å¾ˆå¤šæœ‰ç”¨çš„åŠŸèƒ½è€Œåªéœ€è¦å®ç°æŒ‡å®šçš„ä¸€å°éƒ¨åˆ†å†…å®¹ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰ Summary ç‰¹å¾ï¼Œä½¿å…¶å…·æœ‰ä¸€ä¸ªéœ€è¦å®ç°çš„ summarize_author æ–¹æ³•ï¼Œç„¶åå®šä¹‰ä¸€ä¸ª summarize æ–¹æ³•ï¼Œæ­¤æ–¹æ³•çš„é»˜è®¤å®ç°è°ƒç”¨ summarize_author æ–¹æ³•ï¼š
```rust
pub trait Summary {
    fn summarize_author(&self) -> String;

    fn summarize(&self) -> String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}
```

ä¸ºäº†ä½¿ç”¨ Summaryï¼Œåªéœ€è¦å®ç° summarize_author æ–¹æ³•å³å¯ï¼š
```rust
impl Summary for Weibo {
    fn summarize_author(&self) -> String {
        format!("@{}", self.username)
    }
}
println!("1 new weibo: {}", weibo.summarize());
```


weibo.summarize() ä¼šå…ˆè°ƒç”¨ Summary ç‰¹å¾é»˜è®¤å®ç°çš„ summarize æ–¹æ³•ï¼Œé€šè¿‡è¯¥æ–¹æ³•è¿›è€Œè°ƒç”¨ Weibo ä¸º Summary å®ç°çš„ summarize_author æ–¹æ³•ï¼Œæœ€ç»ˆè¾“å‡ºï¼š1 new weibo: (Read more from @horse_ebooks...)ã€‚
#### ä½¿ç”¨ç‰¹å¾ä½œä¸ºå‡½æ•°å‚æ•°
```rs
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
```

impl Summaryï¼Œåªèƒ½è¯´æƒ³å‡ºè¿™ä¸ªç±»å‹çš„äººçœŸçš„æ˜¯èµ·åé¬¼æ‰ï¼Œç®€ç›´å¤ªè´´åˆ‡äº†ï¼Œé¡¾åæ€ä¹‰ï¼Œå®ƒçš„æ„æ€æ˜¯ å®ç°äº†Summaryç‰¹å¾ çš„ item å‚æ•°ã€‚

ä½ å¯ä»¥ä½¿ç”¨ä»»ä½•å®ç°äº† Summary ç‰¹å¾çš„ç±»å‹ä½œä¸ºè¯¥å‡½æ•°çš„å‚æ•°ï¼ŒåŒæ—¶åœ¨å‡½æ•°ä½“å†…ï¼Œè¿˜å¯ä»¥è°ƒç”¨è¯¥ç‰¹å¾çš„æ–¹æ³•ï¼Œä¾‹å¦‚ summarize æ–¹æ³•ã€‚å…·ä½“çš„è¯´ï¼Œå¯ä»¥ä¼ é€’ Post æˆ– Weibo çš„å®ä¾‹æ¥ä½œä¸ºå‚æ•°ï¼Œè€Œå…¶å®ƒç±»å¦‚ String æˆ–è€… i32 çš„ç±»å‹åˆ™ä¸èƒ½ç”¨åšè¯¥å‡½æ•°çš„å‚æ•°ï¼Œå› ä¸ºå®ƒä»¬æ²¡æœ‰å®ç° Summary ç‰¹å¾ã€‚

#### ç‰¹å¾çº¦æŸ(trait bound)
è™½ç„¶ impl Trait è¿™ç§è¯­æ³•éå¸¸å¥½ç†è§£ï¼Œä½†æ˜¯å®é™…ä¸Šå®ƒåªæ˜¯ä¸€ä¸ªè¯­æ³•ç³–ï¼š
```rust
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
```
çœŸæ­£çš„å®Œæ•´ä¹¦å†™å½¢å¼å¦‚ä¸Šæ‰€è¿°ï¼Œå½¢å¦‚ T: Summary è¢«ç§°ä¸ºç‰¹å¾çº¦æŸã€‚

åœ¨ç®€å•çš„åœºæ™¯ä¸‹ impl Trait è¿™ç§è¯­æ³•ç³–å°±è¶³å¤Ÿä½¿ç”¨ï¼Œä½†æ˜¯å¯¹äºå¤æ‚çš„åœºæ™¯ï¼Œç‰¹å¾çº¦æŸå¯ä»¥è®©æˆ‘ä»¬æ‹¥æœ‰æ›´å¤§çš„çµæ´»æ€§å’Œè¯­æ³•è¡¨ç°èƒ½åŠ›ï¼Œä¾‹å¦‚ä¸€ä¸ªå‡½æ•°æ¥å—ä¸¤ä¸ª impl Summary çš„å‚æ•°ï¼š
```rust
pub fn notify(item1: &impl Summary, item2: &impl Summary) {}
```

å¦‚æœå‡½æ•°ä¸¤ä¸ªå‚æ•°æ˜¯ä¸åŒçš„ç±»å‹ï¼Œé‚£ä¹ˆä¸Šé¢çš„æ–¹æ³•å¾ˆå¥½ï¼Œåªè¦è¿™ä¸¤ä¸ªç±»å‹éƒ½å®ç°äº† Summary ç‰¹å¾å³å¯ã€‚ä½†æ˜¯å¦‚æœæˆ‘ä»¬æƒ³è¦å¼ºåˆ¶å‡½æ•°çš„ä¸¤ä¸ªå‚æ•°æ˜¯åŒä¸€ç±»å‹å‘¢ï¼Ÿä¸Šé¢çš„è¯­æ³•å°±æ— æ³•åšåˆ°è¿™ç§é™åˆ¶ï¼Œæ­¤æ—¶æˆ‘ä»¬åªèƒ½ä½¿ç‰¹å¾çº¦æŸæ¥å®ç°ï¼š
```rust
pub fn notify<T: Summary>(item1: &T, item2: &T) {}
```

æ³›å‹ç±»å‹ T è¯´æ˜äº† item1 å’Œ item2 å¿…é¡»æ‹¥æœ‰åŒæ ·çš„ç±»å‹ï¼ŒåŒæ—¶ T: Summary è¯´æ˜äº† T å¿…é¡»å®ç° Summary ç‰¹å¾ã€‚

##### å¤šé‡çº¦æŸ
é™¤äº†å•ä¸ªçº¦æŸæ¡ä»¶ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥æŒ‡å®šå¤šä¸ªçº¦æŸæ¡ä»¶ï¼Œä¾‹å¦‚é™¤äº†è®©å‚æ•°å®ç° Summary ç‰¹å¾å¤–ï¼Œè¿˜å¯ä»¥è®©å‚æ•°å®ç° Display ç‰¹å¾ä»¥æ§åˆ¶å®ƒçš„æ ¼å¼åŒ–è¾“å‡ºï¼š
```rust
pub fn notify(item: &(impl Summary + Display)) {}
```

é™¤äº†ä¸Šè¿°çš„è¯­æ³•ç³–å½¢å¼ï¼Œè¿˜èƒ½ä½¿ç”¨ç‰¹å¾çº¦æŸçš„å½¢å¼ï¼š
```rust
pub fn notify<T: Summary + Display>(item: &T) {}
```
é€šè¿‡è¿™ä¸¤ä¸ªç‰¹å¾ï¼Œå°±å¯ä»¥ä½¿ç”¨ item.summarize æ–¹æ³•ï¼Œä»¥åŠé€šè¿‡ println!("{}", item) æ¥æ ¼å¼åŒ–è¾“å‡º itemã€‚

##### Where çº¦æŸ
å½“ç‰¹å¾çº¦æŸå˜å¾—å¾ˆå¤šæ—¶ï¼Œå‡½æ•°çš„ç­¾åå°†å˜å¾—å¾ˆå¤æ‚ï¼š
```rust
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {}
```

ä¸¥æ ¼æ¥è¯´ï¼Œä¸Šé¢çš„ä¾‹å­è¿˜æ˜¯ä¸å¤Ÿå¤æ‚ï¼Œä½†æ˜¯æˆ‘ä»¬è¿˜æ˜¯èƒ½å¯¹å…¶åšä¸€äº›å½¢å¼ä¸Šçš„æ”¹è¿›ï¼Œé€šè¿‡ whereï¼š
```rust
fn some_function<T, U>(t: &T, u: &U) -> i32
    where T: Display + Clone,
          U: Clone + Debug
{}
```

##### ä½¿ç”¨ç‰¹å¾çº¦æŸæœ‰æ¡ä»¶åœ°å®ç°æ–¹æ³•æˆ–ç‰¹å¾
ç‰¹å¾çº¦æŸï¼Œå¯ä»¥è®©æˆ‘ä»¬åœ¨æŒ‡å®šç±»å‹ + æŒ‡å®šç‰¹å¾çš„æ¡ä»¶ä¸‹å»å®ç°æ–¹æ³•ï¼Œä¾‹å¦‚ï¼š
```rust
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self {
            x,
            y,
        }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}

```

cmp_display æ–¹æ³•ï¼Œå¹¶ä¸æ˜¯æ‰€æœ‰çš„ Pair&lt;T> ç»“æ„ä½“å¯¹è±¡éƒ½å¯ä»¥æ‹¥æœ‰ï¼Œåªæœ‰ T åŒæ—¶å®ç°äº† Display + PartialOrd çš„ Pair&lt;T> æ‰å¯ä»¥æ‹¥æœ‰æ­¤æ–¹æ³•ã€‚ è¯¥å‡½æ•°å¯è¯»æ€§ä¼šæ›´å¥½ï¼Œå› ä¸ºæ³›å‹å‚æ•°ã€å‚æ•°ã€è¿”å›å€¼éƒ½åœ¨ä¸€èµ·ï¼Œå¯ä»¥å¿«é€Ÿçš„é˜…è¯»ï¼ŒåŒæ—¶æ¯ä¸ªæ³›å‹å‚æ•°çš„ç‰¹å¾ä¹Ÿåœ¨æ–°çš„ä»£ç è¡Œä¸­é€šè¿‡ç‰¹å¾çº¦æŸè¿›è¡Œäº†çº¦æŸã€‚

ä¹Ÿå¯ä»¥æœ‰æ¡ä»¶åœ°å®ç°ç‰¹å¾, ä¾‹å¦‚ï¼Œæ ‡å‡†åº“ä¸ºä»»ä½•å®ç°äº† Display ç‰¹å¾çš„ç±»å‹å®ç°äº† ToString ç‰¹å¾ï¼š
```rust
impl<T: Display> ToString for T {
    // --snip--
}
```

æˆ‘ä»¬å¯ä»¥å¯¹ä»»ä½•å®ç°äº† Display ç‰¹å¾çš„ç±»å‹è°ƒç”¨ç”± ToString å®šä¹‰çš„ to_string æ–¹æ³•ã€‚ä¾‹å¦‚ï¼Œå¯ä»¥å°†æ•´å‹è½¬æ¢ä¸ºå¯¹åº”çš„ String å€¼ï¼Œå› ä¸ºæ•´å‹å®ç°äº† Displayï¼š
```rust
let s = 3.to_string();
```

#### å‡½æ•°è¿”å›ä¸­çš„ impl Trait
å¯ä»¥é€šè¿‡ impl Trait æ¥è¯´æ˜ä¸€ä¸ªå‡½æ•°è¿”å›äº†ä¸€ä¸ªç±»å‹ï¼Œè¯¥ç±»å‹å®ç°äº†æŸä¸ªç‰¹å¾ï¼š
```rust
fn returns_summarizable() -> impl Summary {
    Weibo {
        username: String::from("sunface"),
        content: String::from(
            "m1 maxå¤ªå‰å®³äº†ï¼Œç”µè„‘å†ä¹Ÿä¸ä¼šå¡",
        )
    }
}
```

å› ä¸º Weibo å®ç°äº† Summaryï¼Œå› æ­¤è¿™é‡Œå¯ä»¥ç”¨å®ƒæ¥ä½œä¸ºè¿”å›å€¼ã€‚è¦æ³¨æ„çš„æ˜¯ï¼Œè™½ç„¶æˆ‘ä»¬çŸ¥é“è¿™é‡Œæ˜¯ä¸€ä¸ª Weibo ç±»å‹ï¼Œä½†æ˜¯å¯¹äº returns_summarizable çš„è°ƒç”¨è€…è€Œè¨€ï¼Œä»–åªçŸ¥é“è¿”å›äº†ä¸€ä¸ªå®ç°äº† Summary ç‰¹å¾çš„å¯¹è±¡ï¼Œä½†æ˜¯å¹¶ä¸çŸ¥é“è¿”å›äº†ä¸€ä¸ª Weibo ç±»å‹ã€‚

è¿™ç§ impl Trait å½¢å¼çš„è¿”å›å€¼ï¼Œåœ¨ä¸€ç§åœºæ™¯ä¸‹éå¸¸éå¸¸æœ‰ç”¨ï¼Œé‚£å°±æ˜¯è¿”å›çš„çœŸå®ç±»å‹éå¸¸å¤æ‚ï¼Œä½ ä¸çŸ¥é“è¯¥æ€ä¹ˆå£°æ˜æ—¶(æ¯•ç«Ÿ Rust è¦æ±‚ä½ å¿…é¡»æ ‡å‡ºæ‰€æœ‰çš„ç±»å‹)ï¼Œæ­¤æ—¶å°±å¯ä»¥ç”¨ impl Trait çš„æ–¹å¼ç®€å•è¿”å›ã€‚ä¾‹å¦‚ï¼Œé—­åŒ…å’Œè¿­ä»£å™¨å°±æ˜¯å¾ˆå¤æ‚ï¼Œåªæœ‰ç¼–è¯‘å™¨æ‰çŸ¥é“é‚£ç©æ„çš„çœŸå®ç±»å‹ï¼Œå¦‚æœè®©ä½ å†™å‡ºæ¥å®ƒä»¬çš„å…·ä½“ç±»å‹ï¼Œä¼°è®¡å†…å¿ƒæœ‰ä¸€ä¸‡åªè‰æ³¥é©¬å¥”è…¾ï¼Œå¥½åœ¨ä½ å¯ä»¥ç”¨ impl Iterator æ¥å‘Šè¯‰è°ƒç”¨è€…ï¼Œè¿”å›äº†ä¸€ä¸ªè¿­ä»£å™¨ï¼Œå› ä¸ºæ‰€æœ‰è¿­ä»£å™¨éƒ½ä¼šå®ç° Iterator ç‰¹å¾ã€‚

ä½†æ˜¯è¿™ç§è¿”å›å€¼æ–¹å¼æœ‰ä¸€ä¸ªå¾ˆå¤§çš„é™åˆ¶ï¼šåªèƒ½æœ‰ä¸€ä¸ªå…·ä½“çš„ç±»å‹ï¼Œä¾‹å¦‚ï¼š
```rust
fn returns_summarizable(switch: bool) -> impl Summary {
    if switch {
        Post {
            title: String::from(
                "Penguins win the Stanley Cup Championship!",
            ),
            author: String::from("Iceburgh"),
            content: String::from(
                "The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.",
            ),
        }
    } else {
        Weibo {
            username: String::from("horse_ebooks"),
            content: String::from(
                "of course, as you probably already know, people",
            ),
        }
    }
}
```

#### é€šè¿‡ derive æ´¾ç”Ÿç‰¹å¾
å½¢å¦‚ #[derive(Debug)] çš„ä»£ç å·²ç»å‡ºç°äº†å¾ˆå¤šæ¬¡ï¼Œè¿™ç§æ˜¯ä¸€ç§ç‰¹å¾æ´¾ç”Ÿè¯­æ³•ï¼Œè¢« derive æ ‡è®°çš„å¯¹è±¡ä¼šè‡ªåŠ¨å®ç°å¯¹åº”çš„é»˜è®¤ç‰¹å¾ä»£ç ï¼Œç»§æ‰¿ç›¸åº”çš„åŠŸèƒ½ã€‚

ä¾‹å¦‚ Debug ç‰¹å¾ï¼Œå®ƒæœ‰ä¸€å¥—è‡ªåŠ¨å®ç°çš„é»˜è®¤ä»£ç ï¼Œå½“ä½ ç»™ä¸€ä¸ªç»“æ„ä½“æ ‡è®°åï¼Œå°±å¯ä»¥ä½¿ç”¨ println!("{:?}", s) çš„å½¢å¼æ‰“å°è¯¥ç»“æ„ä½“çš„å¯¹è±¡ã€‚

å†å¦‚ Copy ç‰¹å¾ï¼Œå®ƒä¹Ÿæœ‰ä¸€å¥—è‡ªåŠ¨å®ç°çš„é»˜è®¤ä»£ç ï¼Œå½“æ ‡è®°åˆ°ä¸€ä¸ªç±»å‹ä¸Šæ—¶ï¼Œå¯ä»¥è®©è¿™ä¸ªç±»å‹è‡ªåŠ¨å®ç° Copy ç‰¹å¾ï¼Œè¿›è€Œå¯ä»¥è°ƒç”¨ copy æ–¹æ³•ï¼Œè¿›è¡Œè‡ªæˆ‘å¤åˆ¶ã€‚

æ€»ä¹‹ï¼Œderive æ´¾ç”Ÿå‡ºæ¥çš„æ˜¯ Rust é»˜è®¤ç»™æˆ‘ä»¬æä¾›çš„ç‰¹å¾ï¼Œåœ¨å¼€å‘è¿‡ç¨‹ä¸­æå¤§çš„ç®€åŒ–äº†è‡ªå·±æ‰‹åŠ¨å®ç°ç›¸åº”ç‰¹å¾çš„éœ€æ±‚ï¼Œå½“ç„¶ï¼Œå¦‚æœä½ æœ‰ç‰¹æ®Šçš„éœ€æ±‚ï¼Œè¿˜å¯ä»¥è‡ªå·±æ‰‹åŠ¨é‡è½½è¯¥å®ç°ã€‚

#### è°ƒç”¨æ–¹æ³•éœ€è¦å¼•å…¥ç‰¹å¾
åœ¨ä¸€äº›åœºæ™¯ä¸­ï¼Œä½¿ç”¨ as å…³é”®å­—åšç±»å‹è½¬æ¢ä¼šæœ‰æ¯”è¾ƒå¤§çš„é™åˆ¶ï¼Œå› ä¸ºä½ æƒ³è¦åœ¨ç±»å‹è½¬æ¢ä¸Šæ‹¥æœ‰å®Œå…¨çš„æ§åˆ¶ï¼Œä¾‹å¦‚å¤„ç†è½¬æ¢é”™è¯¯ï¼Œé‚£ä¹ˆä½ å°†éœ€è¦ TryIntoï¼š
```rs
use std::convert::TryInto;

fn main() {
  let a: i32 = 10;
  let b: u16 = 100;

  let b_ = b.try_into()
            .unwrap();

  if a < b_ {
    println!("Ten is less than one hundred.");
  }
}
```

### ç‰¹å¾å¯¹è±¡
```rs
pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&self) {
        // ç»˜åˆ¶æŒ‰é’®çš„ä»£ç 
    }
}

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec<String>,
}

impl Draw for SelectBox {
    fn draw(&self) {
        // ç»˜åˆ¶SelectBoxçš„ä»£ç 
    }
}



```
### æ·±å…¥äº†è§£ç‰¹å¾

#### å…³è”ç±»å‹

å…³è”ç±»å‹æ˜¯åœ¨ç‰¹å¾å®šä¹‰çš„è¯­å¥å—ä¸­ï¼Œç”³æ˜ä¸€ä¸ªè‡ªå®šä¹‰ç±»å‹ï¼Œè¿™æ ·å°±å¯ä»¥åœ¨ç‰¹å¾çš„æ–¹æ³•ç­¾åä¸­ä½¿ç”¨è¯¥ç±»å‹ï¼š
```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;
}
```

ä»¥ä¸Šæ˜¯æ ‡å‡†åº“ä¸­çš„è¿­ä»£å™¨ç‰¹å¾ Iteratorï¼Œå®ƒæœ‰ä¸€ä¸ª Item å…³è”ç±»å‹ï¼Œç”¨äºæ›¿ä»£éå†çš„å€¼çš„ç±»å‹ã€‚

åŒæ—¶ï¼Œnext æ–¹æ³•ä¹Ÿè¿”å›äº†ä¸€ä¸ª Item ç±»å‹ï¼Œä¸è¿‡ä½¿ç”¨ Option æšä¸¾è¿›è¡Œäº†åŒ…è£¹ï¼Œå‡å¦‚è¿­ä»£å™¨ä¸­çš„å€¼æ˜¯ i32 ç±»å‹ï¼Œé‚£ä¹ˆè°ƒç”¨ next æ–¹æ³•å°±å°†è·å–ä¸€ä¸ª Option&lt;i32> çš„å€¼ã€‚

ï¼š
```rust
impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        // --snip--
    }
}

fn main() {
    let c = Counter{..}
    c.next()
}
```

åœ¨ä¸Šè¿°ä»£ç ä¸­ï¼Œæˆ‘ä»¬ä¸º Counter ç±»å‹å®ç°äº† Iterator ç‰¹å¾ï¼Œå˜é‡ c æ˜¯ç‰¹å¾ Iterator çš„å®ä¾‹ï¼Œä¹Ÿæ˜¯ next æ–¹æ³•çš„è°ƒç”¨è€…ã€‚ ç»“åˆä¹‹å‰çš„é»‘ä½“å†…å®¹å¯ä»¥å¾—å‡ºï¼šå¯¹äº next æ–¹æ³•è€Œè¨€ï¼ŒSelf æ˜¯è°ƒç”¨è€… c çš„å…·ä½“ç±»å‹ï¼š Counterï¼Œè€Œ Self::Item æ˜¯ Counter ä¸­å®šä¹‰çš„ Item ç±»å‹: u32ã€‚


```rust
pub trait Iterator<Item> {
    fn next(&mut self) -> Option<Item>;
}
```

ç­”æ¡ˆå…¶å®å¾ˆç®€å•ï¼Œä¸ºäº†ä»£ç çš„å¯è¯»æ€§ï¼Œå½“ä½ ä½¿ç”¨äº†æ³›å‹åï¼Œä½ éœ€è¦åœ¨æ‰€æœ‰åœ°æ–¹éƒ½å†™ Iterator&lt;Item>ï¼Œè€Œä½¿ç”¨äº†å…³è”ç±»å‹ï¼Œä½ åªéœ€è¦å†™ Iteratorï¼Œå½“ç±»å‹å®šä¹‰å¤æ‚æ—¶ï¼Œè¿™ç§å†™æ³•å¯ä»¥æå¤§çš„å¢åŠ å¯è¯»æ€§ï¼š
```rust
pub trait CacheableItem: Clone + Default + fmt::Debug + Decodable + Encodable {
  type Address: AsRef<[u8]> + Clone + fmt::Debug + Eq + Hash;
  fn is_null(&self) -> bool;
}
```

ä¾‹å¦‚ä¸Šé¢çš„ä»£ç ï¼ŒAddress çš„å†™æ³•è‡ªç„¶è¿œæ¯” AsRef<[u8]> + Clone + fmt::Debug + Eq + Hash è¦ç®€å•çš„å¤šï¼Œè€Œä¸”å«ä¹‰æ¸…æ™°ã€‚

å†ä¾‹å¦‚ï¼Œå¦‚æœä½¿ç”¨æ³›å‹ï¼Œä½ å°†å¾—åˆ°ä»¥ä¸‹çš„ä»£ç ï¼š
```rust
trait Container<A,B> {
    fn contains(&self,a: A,b: B) -> bool;
}

fn difference<A,B,C>(container: &C) -> i32
  where
    C : Container<A,B> {...}
```

å¯ä»¥çœ‹åˆ°ï¼Œç”±äºä½¿ç”¨äº†æ³›å‹ï¼Œå¯¼è‡´å‡½æ•°å¤´éƒ¨ä¹Ÿå¿…é¡»å¢åŠ æ³›å‹çš„å£°æ˜ï¼Œè€Œä½¿ç”¨å…³è”ç±»å‹ï¼Œå°†å¾—åˆ°å¯è¯»æ€§å¥½å¾—å¤šçš„ä»£ç ï¼š
```rust
trait Container{
    type A;
    type B;
    fn contains(&self, a: &Self::A, b: &Self::B) -> bool;
}

fn difference<C: Container>(container: &C) {}
```

#### é»˜è®¤æ³›å‹ç±»å‹å‚æ•°
å½“ä½¿ç”¨æ³›å‹ç±»å‹å‚æ•°æ—¶ï¼Œå¯ä»¥ä¸ºå…¶æŒ‡å®šä¸€ä¸ªé»˜è®¤çš„å…·ä½“ç±»å‹ï¼Œä¾‹å¦‚æ ‡å‡†åº“ä¸­çš„ std::ops::Add ç‰¹å¾ï¼š
```rust
trait Add<RHS=Self> {
    type Output;

    fn add(self, rhs: RHS) -> Self::Output;
}
```

å®ƒæœ‰ä¸€ä¸ªæ³›å‹å‚æ•° RHSï¼Œä½†æ˜¯ä¸æˆ‘ä»¬ä»¥å¾€çš„ç”¨æ³•ä¸åŒï¼Œè¿™é‡Œå®ƒç»™ RHS ä¸€ä¸ªé»˜è®¤å€¼ï¼Œä¹Ÿå°±æ˜¯å½“ç”¨æˆ·ä¸æŒ‡å®š RHS æ—¶ï¼Œé»˜è®¤ä½¿ç”¨ä¸¤ä¸ªåŒæ ·ç±»å‹çš„å€¼è¿›è¡Œç›¸åŠ ï¼Œç„¶åè¿”å›ä¸€ä¸ªå…³è”ç±»å‹ Outputã€‚

å¯èƒ½ä¸Šé¢é‚£æ®µä¸å¤ªå¥½ç†è§£ï¼Œä¸‹é¢æˆ‘ä»¬ç”¨ä»£ç æ¥ä¸¾ä¾‹ï¼š
```rust
use std::ops::Add;

#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -> Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
               Point { x: 3, y: 3 });
}
```

ä¸Šé¢çš„ä»£ç ä¸»è¦å¹²äº†ä¸€ä»¶äº‹ï¼Œå°±æ˜¯ä¸º Point ç»“æ„ä½“æä¾› + çš„èƒ½åŠ›ï¼Œè¿™å°±æ˜¯è¿ç®—ç¬¦é‡è½½ï¼Œä¸è¿‡ Rust å¹¶ä¸æ”¯æŒåˆ›å»ºè‡ªå®šä¹‰è¿ç®—ç¬¦ï¼Œä½ ä¹Ÿæ— æ³•ä¸ºæ‰€æœ‰è¿ç®—ç¬¦è¿›è¡Œé‡è½½ï¼Œç›®å‰æ¥è¯´ï¼Œåªæœ‰å®šä¹‰åœ¨ std::ops ä¸­çš„è¿ç®—ç¬¦æ‰èƒ½è¿›è¡Œé‡è½½ã€‚

è·Ÿ + å¯¹åº”çš„ç‰¹å¾æ˜¯ std::ops::Addï¼Œæˆ‘ä»¬åœ¨ä¹‹å‰ä¹Ÿçœ‹è¿‡å®ƒçš„å®šä¹‰ trait Add&lt;RHS=Self>ï¼Œä½†æ˜¯ä¸Šé¢çš„ä¾‹å­ä¸­å¹¶æ²¡æœ‰ä¸º Point å®ç° Add&lt;RHS> ç‰¹å¾ï¼Œè€Œæ˜¯å®ç°äº† Add ç‰¹å¾ï¼ˆæ²¡æœ‰é»˜è®¤æ³›å‹ç±»å‹å‚æ•°ï¼‰ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬ä½¿ç”¨äº† RHS çš„é»˜è®¤ç±»å‹ï¼Œä¹Ÿå°±æ˜¯ Selfã€‚æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬è¿™é‡Œå®šä¹‰çš„æ˜¯ä¸¤ä¸ªç›¸åŒçš„ Point ç±»å‹ç›¸åŠ ï¼Œå› æ­¤æ— éœ€æŒ‡å®š RHSã€‚

ä¸ä¸Šé¢çš„ä¾‹å­ç›¸åï¼Œä¸‹é¢çš„ä¾‹å­ï¼Œæˆ‘ä»¬æ¥åˆ›å»ºä¸¤ä¸ªä¸åŒç±»å‹çš„ç›¸åŠ ï¼š
```rust
use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add<Meters> for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -> Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
```

è¿™é‡Œï¼Œæ˜¯è¿›è¡Œ Millimeters + Meters ä¸¤ç§æ•°æ®ç±»å‹çš„ + æ“ä½œï¼Œå› æ­¤æ­¤æ—¶ä¸èƒ½å†ä½¿ç”¨é»˜è®¤çš„ RHSï¼Œå¦åˆ™å°±ä¼šå˜æˆ Millimeters + Millimeters çš„å½¢å¼ã€‚ä½¿ç”¨ Add&lt;Meters> å¯ä»¥å°† RHS æŒ‡å®šä¸º Metersï¼Œé‚£ä¹ˆ fn add(self, rhs: RHS) è‡ªç„¶è€Œè¨€çš„å˜æˆäº† Millimeters å’Œ Meters çš„ç›¸åŠ ã€‚

é»˜è®¤ç±»å‹å‚æ•°ä¸»è¦ç”¨äºä¸¤ä¸ªæ–¹é¢ï¼š

1. å‡å°‘å®ç°çš„æ ·æ¿ä»£ç 
2. æ‰©å±•ç±»å‹ä½†æ˜¯æ— éœ€å¤§å¹…ä¿®æ”¹ç°æœ‰çš„ä»£ç 




#### è°ƒç”¨åŒåçš„æ–¹æ³•
ä¸åŒç‰¹å¾æ‹¥æœ‰åŒåçš„æ–¹æ³•æ˜¯å¾ˆæ­£å¸¸çš„äº‹æƒ…ï¼Œä½ æ²¡æœ‰ä»»ä½•åŠæ³•é˜»æ­¢è¿™ä¸€ç‚¹ï¼›ç”šè‡³é™¤äº†ç‰¹å¾ä¸Šçš„åŒåæ–¹æ³•å¤–ï¼Œåœ¨ä½ çš„ç±»å‹ä¸Šï¼Œä¹Ÿæœ‰åŒåæ–¹æ³•ï¼š
```rust
trait Pilot {
    fn fly(&self);
}

trait Wizard {
    fn fly(&self);
}

struct Human;

impl Pilot for Human {
    fn fly(&self) {
        println!("This is your captain speaking.");
    }
}

impl Wizard for Human {
    fn fly(&self) {
        println!("Up!");
    }
}

impl Human {
    fn fly(&self) {
        println!("*waving arms furiously*");
    }
}

```

è¿™é‡Œï¼Œä¸ä»…ä»…ä¸¤ä¸ªç‰¹å¾ Pilot å’Œ Wizard æœ‰ fly æ–¹æ³•ï¼Œå°±è¿å®ç°é‚£ä¸¤ä¸ªç‰¹å¾çš„ Human å•å…ƒç»“æ„ä½“ï¼Œä¹Ÿæ‹¥æœ‰ä¸€ä¸ªåŒåæ–¹æ³• fly 
##### ä¼˜å…ˆè°ƒç”¨ç±»å‹ä¸Šçš„æ–¹æ³•
å½“è°ƒç”¨ Human å®ä¾‹çš„ fly æ—¶ï¼Œç¼–è¯‘å™¨é»˜è®¤è°ƒç”¨è¯¥ç±»å‹ä¸­å®šä¹‰çš„æ–¹æ³•ï¼š
```rust
fn main() {
    let person = Human;
    person.fly();
}
```

è¿™æ®µä»£ç ä¼šæ‰“å° *waving arms furiously*ï¼Œè¯´æ˜ç›´æ¥è°ƒç”¨äº†ç±»å‹ä¸Šå®šä¹‰çš„æ–¹æ³•ã€‚

##### è°ƒç”¨ç‰¹å¾ä¸Šçš„æ–¹æ³•
ä¸ºäº†èƒ½å¤Ÿè°ƒç”¨ä¸¤ä¸ªç‰¹å¾çš„æ–¹æ³•ï¼Œéœ€è¦ä½¿ç”¨æ˜¾å¼è°ƒç”¨çš„è¯­æ³•ï¼š
```rust
fn main() {
    let person = Human;
    Pilot::fly(&person); // è°ƒç”¨Pilotç‰¹å¾ä¸Šçš„æ–¹æ³•
    Wizard::fly(&person); // è°ƒç”¨Wizardç‰¹å¾ä¸Šçš„æ–¹æ³•
    person.fly(); // è°ƒç”¨Humanç±»å‹è‡ªèº«çš„æ–¹æ³•
}

```

è¿è¡Œåä¾æ¬¡è¾“å‡ºï¼š
```shell
This is your captain speaking.
Up!
*waving arms furiously*
```

å› ä¸º fly æ–¹æ³•çš„å‚æ•°æ˜¯ selfï¼Œå½“æ˜¾å¼è°ƒç”¨æ—¶ï¼Œç¼–è¯‘å™¨å°±å¯ä»¥æ ¹æ®è°ƒç”¨çš„ç±»å‹( self çš„ç±»å‹)å†³å®šå…·ä½“è°ƒç”¨å“ªä¸ªæ–¹æ³•ã€‚

è¿™ä¸ªæ—¶å€™é—®é¢˜åˆæ¥äº†ï¼Œå¦‚æœæ–¹æ³•æ²¡æœ‰ self å‚æ•°å‘¢ï¼Ÿç¨ç­‰ï¼Œä¼°è®¡æœ‰è¯»è€…ä¼šé—®ï¼šè¿˜æœ‰æ–¹æ³•æ²¡æœ‰ self å‚æ•°ï¼Ÿ

```rust
trait Animal {
    fn baby_name() -> String;
}

struct Dog;

impl Dog {
    fn baby_name() -> String {
        String::from("Spot")
    }
}

impl Animal for Dog {
    fn baby_name() -> String {
        String::from("puppy")
    }
}

fn main() {
    println!("A baby dog is called a {}", Dog::baby_name());
}
```




Dog::baby_name() çš„è°ƒç”¨æ–¹å¼æ˜¾ç„¶ä¸è¡Œï¼Œå› ä¸ºè¿™åªæ˜¯ç‹—å¦ˆå¦ˆå¯¹å®å®çš„çˆ±ç§°ï¼Œå¯èƒ½ä½ ä¼šæƒ³åˆ°é€šè¿‡ä¸‹é¢çš„æ–¹å¼æŸ¥è¯¢å…¶ä»–åŠ¨ç‰©å¯¹ç‹—ç‹—çš„ç§°å‘¼ï¼š
```rust
fn main() {
    println!("A baby dog is called a {}", Animal::baby_name());
}
```

```shell
error[E0283]: type annotations needed // éœ€è¦ç±»å‹æ³¨é‡Š
  --> src/main.rs:20:43
   |
20 |     println!("A baby dog is called a {}", Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^ cannot infer type // æ— æ³•æ¨æ–­ç±»å‹
   |
   = note: cannot satisfy `_: Animal`

```

#### å®Œå…¨é™å®šè¯­æ³•
å®Œå…¨é™å®šè¯­æ³•æ˜¯è°ƒç”¨å‡½æ•°æœ€ä¸ºæ˜ç¡®çš„æ–¹å¼ï¼š
```rust
fn main() {
    println!("A baby dog is called a {}", <Dog as Animal>::baby_name());
}
```

åœ¨å°–æ‹¬å·ä¸­ï¼Œé€šè¿‡ as å…³é”®å­—ï¼Œæˆ‘ä»¬å‘ Rust ç¼–è¯‘å™¨æä¾›äº†ç±»å‹æ³¨è§£ï¼Œä¹Ÿå°±æ˜¯ Animal å°±æ˜¯ Dogï¼Œè€Œä¸æ˜¯å…¶ä»–åŠ¨ç‰©ï¼Œå› æ­¤æœ€ç»ˆä¼šè°ƒç”¨ impl Animal for Dog ä¸­çš„æ–¹æ³•ï¼Œè·å–åˆ°å…¶å®ƒåŠ¨ç‰©å¯¹ç‹—å®å®çš„ç§°å‘¼ï¼špuppyã€‚


#### ç‰¹å¾å®šä¹‰ä¸­çš„ç‰¹å¾çº¦æŸ
æœ‰æ—¶ï¼Œæˆ‘ä»¬ä¼šéœ€è¦è®©æŸä¸ªç‰¹å¾ A èƒ½ä½¿ç”¨å¦ä¸€ä¸ªç‰¹å¾ B çš„åŠŸèƒ½(å¦ä¸€ç§å½¢å¼çš„ç‰¹å¾çº¦æŸ)ï¼Œè¿™ç§æƒ…å†µä¸‹ï¼Œä¸ä»…ä»…è¦ä¸ºç±»å‹å®ç°ç‰¹å¾ Aï¼Œè¿˜è¦ä¸ºç±»å‹å®ç°ç‰¹å¾ B æ‰è¡Œï¼Œè¿™å°±æ˜¯ supertrait (å®åœ¨ä¸çŸ¥é“è¯¥å¦‚ä½•ç¿»è¯‘ï¼Œæœ‰å¤§ä½¬æŒ‡å¯¼ä¸‹å˜›ï¼Ÿ)

ä¾‹å¦‚æœ‰ä¸€ä¸ªç‰¹å¾ OutlinePrintï¼Œå®ƒæœ‰ä¸€ä¸ªæ–¹æ³•ï¼Œèƒ½å¤Ÿå¯¹å½“å‰çš„å®ç°ç±»å‹è¿›è¡Œæ ¼å¼åŒ–è¾“å‡ºï¼š
```rust
use std::fmt::Display;

trait OutlinePrint: Display {
    fn outline_print(&self) {
        let output = self.to_string();
        let len = output.len();
        println!("{}", "*".repeat(len + 4));
        println!("*{}*", " ".repeat(len + 2));
        println!("* {} *", output);
        println!("*{}*", " ".repeat(len + 2));
        println!("{}", "*".repeat(len + 4));
    }
}
```

ç­‰ç­‰ï¼Œè¿™é‡Œæœ‰ä¸€ä¸ªçœ¼ç†Ÿçš„è¯­æ³•: OutlinePrint: Displayï¼Œæ„Ÿè§‰å¾ˆåƒä¹‹å‰è®²è¿‡çš„ç‰¹å¾çº¦æŸï¼Œåªä¸è¿‡ç”¨åœ¨äº†ç‰¹å¾å®šä¹‰ä¸­è€Œä¸æ˜¯å‡½æ•°çš„å‚æ•°ä¸­ï¼Œæ˜¯çš„ï¼Œåœ¨æŸç§æ„ä¹‰ä¸Šæ¥è¯´ï¼Œè¿™å’Œç‰¹å¾çº¦æŸéå¸¸ç±»ä¼¼ï¼Œéƒ½ç”¨æ¥è¯´æ˜ä¸€ä¸ªç‰¹å¾éœ€è¦å®ç°å¦ä¸€ä¸ªç‰¹å¾ï¼Œè¿™é‡Œå°±æ˜¯ï¼šå¦‚æœä½ æƒ³è¦å®ç° OutlinePrint ç‰¹å¾ï¼Œé¦–å…ˆä½ éœ€è¦å®ç° Display ç‰¹å¾ã€‚

æƒ³è±¡ä¸€ä¸‹ï¼Œå‡å¦‚æ²¡æœ‰è¿™ä¸ªç‰¹å¾çº¦æŸï¼Œé‚£ä¹ˆ self.to_string è¿˜èƒ½å¤Ÿè°ƒç”¨å—ï¼ˆ to_string æ–¹æ³•ä¼šä¸ºå®ç° Display ç‰¹å¾çš„ç±»å‹è‡ªåŠ¨å®ç°ï¼‰ï¼Ÿç¼–è¯‘å™¨è‚¯å®šæ˜¯ä¸æ„¿æ„çš„ï¼Œä¼šæŠ¥é”™è¯´å½“å‰ä½œç”¨åŸŸä¸­æ‰¾ä¸åˆ°ç”¨äº &Self ç±»å‹çš„æ–¹æ³• to_string ï¼š
```rust
struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
```


å› ä¸º Point æ²¡æœ‰å®ç° Display ç‰¹å¾ï¼Œä¼šå¾—åˆ°ä¸‹é¢çš„æŠ¥é”™ï¼š
```shell
error[E0277]: the trait bound `Point: std::fmt::Display` is not satisfied
  --> src/main.rs:20:6
   |
20 | impl OutlinePrint for Point {}
   |      ^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter;
try using `:?` instead if you are using a format string
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
```

æ—¢ç„¶æˆ‘ä»¬æœ‰æ±‚äºç¼–è¯‘å™¨ï¼Œé‚£åªèƒ½é€‰æ‹©æ»¡è¶³å®ƒå’¯ï¼š
```rust
use std::fmt;

impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}
```

ä¸Šé¢ä»£ç ä¸º Point å®ç°äº† Display ç‰¹å¾ï¼Œé‚£ä¹ˆ to_string æ–¹æ³•ä¹Ÿå°†è‡ªåŠ¨å®ç°ï¼šæœ€ç»ˆè·å¾—å­—ç¬¦ä¸²æ˜¯é€šè¿‡è¿™é‡Œçš„ fmt æ–¹æ³•è·å¾—çš„ã€‚

#### åœ¨å¤–éƒ¨ç±»å‹ä¸Šå®ç°å¤–éƒ¨ç‰¹å¾(newtype)
æœ‰æåˆ°å­¤å„¿è§„åˆ™ï¼Œç®€å•æ¥è¯´ï¼Œå°±æ˜¯ç‰¹å¾æˆ–è€…ç±»å‹å¿…éœ€è‡³å°‘æœ‰ä¸€ä¸ªæ˜¯æœ¬åœ°çš„ï¼Œæ‰èƒ½åœ¨æ­¤ç±»å‹ä¸Šå®šä¹‰ç‰¹å¾ã€‚

è¿™é‡Œæä¾›ä¸€ä¸ªåŠæ³•æ¥ç»•è¿‡å­¤å„¿è§„åˆ™ï¼Œé‚£å°±æ˜¯ä½¿ç”¨newtype æ¨¡å¼ï¼Œç®€è€Œè¨€ä¹‹ï¼šå°±æ˜¯ä¸ºä¸€ä¸ªå…ƒç»„ç»“æ„ä½“åˆ›å»ºæ–°ç±»å‹ã€‚è¯¥å…ƒç»„ç»“æ„ä½“å°è£…æœ‰ä¸€ä¸ªå­—æ®µï¼Œè¯¥å­—æ®µå°±æ˜¯å¸Œæœ›å®ç°ç‰¹å¾çš„å…·ä½“ç±»å‹ã€‚

è¯¥å°è£…ç±»å‹æ˜¯æœ¬åœ°çš„ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ä¸ºæ­¤ç±»å‹å®ç°å¤–éƒ¨çš„ç‰¹å¾ã€‚

newtype ä¸ä»…ä»…èƒ½å®ç°ä»¥ä¸Šçš„åŠŸèƒ½ï¼Œè€Œä¸”å®ƒåœ¨è¿è¡Œæ—¶æ²¡æœ‰ä»»ä½•æ€§èƒ½æŸè€—ï¼Œå› ä¸ºåœ¨ç¼–è¯‘æœŸï¼Œè¯¥ç±»å‹ä¼šè¢«è‡ªåŠ¨å¿½ç•¥ã€‚

```rust
use std::fmt;

struct Wrapper(Vec<String>);

impl fmt::Display for Wrapper {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}

fn main() {
    let w = Wrapper(vec![String::from("hello"), String::from("world")]);
    println!("w = {}", w);
}
```

å…¶ä¸­ï¼Œstruct Wrapper(Vec&lt;String>) å°±æ˜¯ä¸€ä¸ªå…ƒç»„ç»“æ„ä½“ï¼Œå®ƒå®šä¹‰äº†ä¸€ä¸ªæ–°ç±»å‹ Wrapperï¼Œä»£ç å¾ˆç®€å•ï¼Œç›¸ä¿¡å¤§å®¶ä¹Ÿå¾ˆå®¹æ˜“çœ‹æ‡‚ã€‚

æ—¢ç„¶ new type æœ‰è¿™ä¹ˆå¤šå¥½å¤„ï¼Œå®ƒæœ‰æ²¡æœ‰ä¸å¥½çš„åœ°æ–¹å‘¢ï¼Ÿç­”æ¡ˆæ˜¯è‚¯å®šçš„ã€‚æ³¨æ„åˆ°æˆ‘ä»¬æ€ä¹ˆè®¿é—®é‡Œé¢çš„æ•°ç»„å—ï¼Ÿself.0.join(", ")ï¼Œæ˜¯çš„ï¼Œå¾ˆå•°å—¦ï¼Œå› ä¸ºéœ€è¦å…ˆä» Wrapper ä¸­å–å‡ºæ•°ç»„: self.0ï¼Œç„¶åæ‰èƒ½æ‰§è¡Œ join æ–¹æ³•ã€‚

ç±»ä¼¼çš„ï¼Œä»»ä½•æ•°ç»„ä¸Šçš„æ–¹æ³•ï¼Œä½ éƒ½æ— æ³•ç›´æ¥è°ƒç”¨ï¼Œéœ€è¦å…ˆç”¨ self.0 å–å‡ºæ•°ç»„ï¼Œç„¶åå†è¿›è¡Œè°ƒç”¨ã€‚

å½“ç„¶ï¼Œè§£å†³åŠæ³•è¿˜æ˜¯æœ‰çš„ï¼Œè¦ä¸æ€ä¹ˆè¯´ Rust æ˜¯æå…¶å¼ºå¤§çµæ´»çš„ç¼–ç¨‹è¯­è¨€ï¼Rust æä¾›äº†ä¸€ä¸ªç‰¹å¾å« Derefï¼Œå®ç°è¯¥ç‰¹å¾åï¼Œå¯ä»¥è‡ªåŠ¨åšä¸€å±‚ç±»ä¼¼ç±»å‹è½¬æ¢çš„æ“ä½œï¼Œå¯ä»¥å°† Wrapper å˜æˆ Vec&lt;String> æ¥ä½¿ç”¨ã€‚è¿™æ ·å°±ä¼šåƒç›´æ¥ä½¿ç”¨æ•°ç»„é‚£æ ·å»ä½¿ç”¨ Wrapperï¼Œè€Œæ— éœ€ä¸ºæ¯ä¸€ä¸ªæ“ä½œéƒ½æ·»åŠ ä¸Š self.0ã€‚

åŒæ—¶ï¼Œå¦‚æœä¸æƒ³ Wrapper æš´éœ²åº•å±‚æ•°ç»„çš„æ‰€æœ‰æ–¹æ³•ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥ä¸º Wrapper å»é‡è½½è¿™äº›æ–¹æ³•ï¼Œå®ç°éšè—çš„ç›®çš„ã€‚

## é›†åˆç±»å‹
### åŠ¨æ€æ•°ç»„ Vector

### KV å­˜å‚¨ HashMap
```rs
use std::collections::HashMap;

// åˆ›å»ºä¸€ä¸ªHashMapï¼Œç”¨äºå­˜å‚¨å®çŸ³ç§ç±»å’Œå¯¹åº”çš„æ•°é‡
let mut my_gems = HashMap::new();

// å°†å®çŸ³ç±»å‹å’Œå¯¹åº”çš„æ•°é‡å†™å…¥è¡¨ä¸­
my_gems.insert("çº¢å®çŸ³", 1);
my_gems.insert("è“å®çŸ³", 2);
my_gems.insert("æ²³è¾¹æ¡çš„è¯¯ä»¥ä¸ºæ˜¯å®çŸ³çš„ç ´çŸ³å¤´", 18);






fn main() {
    use std::collections::HashMap;

    let teams_list = vec![
        ("ä¸­å›½é˜Ÿ".to_string(), 100),
        ("ç¾å›½é˜Ÿ".to_string(), 10),
        ("æ—¥æœ¬é˜Ÿ".to_string(), 50),
    ];

    let teams_map: HashMap<_,_> = teams_list.into_iter().collect();
    
    println!("{:?}",teams_map)
}


fn main() {
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert("Blue", 10);

    // è¦†ç›–å·²æœ‰çš„å€¼
    let old = scores.insert("Blue", 20);
    assert_eq!(old, Some(10));

    // æŸ¥è¯¢æ–°æ’å…¥çš„å€¼
    let new = scores.get("Blue");
    assert_eq!(new, Some(&20));

    // æŸ¥è¯¢Yellowå¯¹åº”çš„å€¼ï¼Œè‹¥ä¸å­˜åœ¨åˆ™æ’å…¥æ–°å€¼
    let v = scores.entry("Yellow").or_insert(5);
    assert_eq!(*v, 5); // ä¸å­˜åœ¨ï¼Œæ’å…¥5

    // æŸ¥è¯¢Yellowå¯¹åº”çš„å€¼ï¼Œè‹¥ä¸å­˜åœ¨åˆ™æ’å…¥æ–°å€¼
    let v = scores.entry("Yellow").or_insert(50);
    assert_eq!(*v, 5); // å·²ç»å­˜åœ¨ï¼Œå› æ­¤50æ²¡æœ‰æ’å…¥
}
```
## è®¤è¯†ç”Ÿå‘½å‘¨æœŸ
åœ¨å­˜åœ¨å¤šä¸ªå¼•ç”¨æ—¶ï¼Œç¼–è¯‘å™¨æœ‰æ—¶ä¼šæ— æ³•è‡ªåŠ¨æ¨å¯¼ç”Ÿå‘½å‘¨æœŸï¼Œæ­¤æ—¶å°±éœ€è¦æˆ‘ä»¬æ‰‹åŠ¨å»æ ‡æ³¨ï¼Œé€šè¿‡ä¸ºå‚æ•°æ ‡æ³¨åˆé€‚çš„ç”Ÿå‘½å‘¨æœŸæ¥å¸®åŠ©ç¼–è¯‘å™¨è¿›è¡Œå€Ÿç”¨æ£€æŸ¥çš„åˆ†æã€‚

```rs
{
    let r;

    {
        let x = 5;
        r = &x;
    }

    println!("r: {}", r);
}
```
- let r; çš„å£°æ˜æ–¹å¼è²Œä¼¼å­˜åœ¨ä½¿ç”¨ null çš„é£é™©ï¼Œå®é™…ä¸Šï¼Œå½“æˆ‘ä»¬ä¸åˆå§‹åŒ–å®ƒå°±ä½¿ç”¨æ—¶ï¼Œç¼–è¯‘å™¨ä¼šç»™äºˆæŠ¥é”™
- r å¼•ç”¨äº†å†…éƒ¨èŠ±æ‹¬å·ä¸­çš„ x å˜é‡ï¼Œä½†æ˜¯ x ä¼šåœ¨å†…éƒ¨èŠ±æ‹¬å· \} å¤„è¢«é‡Šæ”¾ï¼Œå› æ­¤å›åˆ°å¤–éƒ¨èŠ±æ‹¬å·åï¼Œr ä¼šå¼•ç”¨ä¸€ä¸ªæ— æ•ˆçš„ x

&i32        // ä¸€ä¸ªå¼•ç”¨
&'a i32     // å…·æœ‰æ˜¾å¼ç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨
&'a mut i32 // å…·æœ‰æ˜¾å¼ç”Ÿå‘½å‘¨æœŸçš„å¯å˜å¼•ç”¨


```rs
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}


// åœ¨å­˜åœ¨å¤šä¸ªå¼•ç”¨æ—¶ï¼Œç¼–è¯‘å™¨æœ‰æ—¶ä¼šæ— æ³•è‡ªåŠ¨æ¨å¯¼ç”Ÿå‘½å‘¨æœŸï¼Œæ­¤æ—¶å°±éœ€è¦æˆ‘ä»¬æ‰‹åŠ¨å»æ ‡æ³¨ï¼Œé€šè¿‡ä¸ºå‚æ•°æ ‡æ³¨åˆé€‚çš„ç”Ÿå‘½å‘¨æœŸæ¥å¸®åŠ©ç¼–è¯‘å™¨è¿›è¡Œå€Ÿç”¨æ£€æŸ¥çš„åˆ†æã€‚
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

// æ­£ç¡®ä»£ç 
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

```
é”™è¯¯ä»£ç ä¼šå‡ºç°ä¸‹é¢çš„æŠ¥é”™
```cmd
  --> main.rs:11:33
   |
11 | fn longest(x: &str, y: &str) -> &str {
   |               ----     ----     ^ expected named lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
help: consider introducing a named lifetime parameter
   |
11 | fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
   |           ++++     ++          ++          ++
```

### ç»“æ„ä½“ä¸­çš„ç”Ÿå‘½å‘¨æœŸ
```rs
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
```
è¯¥ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨è¯´æ˜ï¼Œç»“æ„ä½“ ImportantExcerpt æ‰€å¼•ç”¨çš„å­—ç¬¦ä¸² str å¿…é¡»æ¯”è¯¥ç»“æ„ä½“æ´»å¾—æ›´ä¹…ã€‚
### ç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤
- æ¯ä¸€ä¸ªå¼•ç”¨å‚æ•°éƒ½ä¼šè·å¾—ç‹¬è‡ªçš„ç”Ÿå‘½å‘¨æœŸ

ä¾‹å¦‚ä¸€ä¸ªå¼•ç”¨å‚æ•°çš„å‡½æ•°å°±æœ‰ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸæ ‡æ³¨: fn foo<'a>(x: &'a i32)ï¼Œä¸¤ä¸ªå¼•ç”¨å‚æ•°çš„æœ‰ä¸¤ä¸ªç”Ÿå‘½å‘¨æœŸæ ‡æ³¨:fn foo<'a, 'b>(x: &'a i32, y: &'b i32), ä¾æ­¤ç±»æ¨ã€‚

- è‹¥åªæœ‰ä¸€ä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸ(å‡½æ•°å‚æ•°ä¸­åªæœ‰ä¸€ä¸ªå¼•ç”¨ç±»å‹)ï¼Œé‚£ä¹ˆè¯¥ç”Ÿå‘½å‘¨æœŸä¼šè¢«èµ‹ç»™æ‰€æœ‰çš„è¾“å‡ºç”Ÿå‘½å‘¨æœŸï¼Œä¹Ÿå°±æ˜¯æ‰€æœ‰è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸéƒ½ç­‰äºè¯¥è¾“å…¥ç”Ÿå‘½å‘¨æœŸ

ä¾‹å¦‚å‡½æ•° fn foo(x: &i32) -> &i32ï¼Œx å‚æ•°çš„ç”Ÿå‘½å‘¨æœŸä¼šè¢«è‡ªåŠ¨èµ‹ç»™è¿”å›å€¼ &i32ï¼Œå› æ­¤è¯¥å‡½æ•°ç­‰åŒäº fn foo<'a>(x: &'a i32) -> &'a i32

- è‹¥å­˜åœ¨å¤šä¸ªè¾“å…¥ç”Ÿå‘½å‘¨æœŸï¼Œä¸”å…¶ä¸­ä¸€ä¸ªæ˜¯ &self æˆ– &mut selfï¼Œåˆ™ &self çš„ç”Ÿå‘½å‘¨æœŸè¢«èµ‹ç»™æ‰€æœ‰çš„è¾“å‡ºç”Ÿå‘½å‘¨æœŸ
æ‹¥æœ‰ &self å½¢å¼çš„å‚æ•°ï¼Œè¯´æ˜è¯¥å‡½æ•°æ˜¯ä¸€ä¸ª æ–¹æ³•ï¼Œè¯¥è§„åˆ™è®©æ–¹æ³•çš„ä½¿ç”¨ä¾¿åˆ©åº¦å¤§å¹…æå‡ã€‚
```rs
struct ImportantExcerpt<'a> {
    part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}
```
- impl ä¸­å¿…é¡»ä½¿ç”¨ç»“æ„ä½“çš„å®Œæ•´åç§°ï¼ŒåŒ…æ‹¬ <'a>ï¼Œå› ä¸ºç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ä¹Ÿæ˜¯ç»“æ„ä½“ç±»å‹çš„ä¸€éƒ¨åˆ†ï¼
- æ–¹æ³•ç­¾åä¸­ï¼Œå¾€å¾€ä¸éœ€è¦æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸï¼Œå¾—ç›Šäºç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤çš„ç¬¬ä¸€å’Œç¬¬ä¸‰è§„åˆ™

## è¿”å›å€¼å’Œé”™è¯¯å¤„ç†
### panic æ·±å…¥å‰–æ
#### ä¸»åŠ¨è°ƒç”¨
```rs
fn main() {
    panic!("crash and burn");
}
```
#### backtrace æ ˆå±•å¼€

#### panic æ—¶çš„ä¸¤ç§ç»ˆæ­¢æ–¹å¼
å½“å‡ºç° panic! æ—¶ï¼Œç¨‹åºæä¾›äº†ä¸¤ç§æ–¹å¼æ¥å¤„ç†ç»ˆæ­¢æµç¨‹ï¼šæ ˆå±•å¼€å’Œç›´æ¥ç»ˆæ­¢

#### ä½•æ—¶è¯¥ä½¿ç”¨ panic!
å…ˆæ¥ä¸€ç‚¹èƒŒæ™¯çŸ¥è¯†ï¼Œåœ¨å‰é¢ç« èŠ‚æˆ‘ä»¬ç²—ç•¥è®²è¿‡ Result<T, E> è¿™ä¸ªæšä¸¾ç±»å‹ï¼Œå®ƒæ˜¯ç”¨æ¥è¡¨ç¤ºå‡½æ•°çš„è¿”å›ç»“æœï¼š
```rs
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```
å½“æ²¡æœ‰é”™è¯¯å‘ç”Ÿæ—¶ï¼Œå‡½æ•°è¿”å›ä¸€ä¸ªç”¨ Result ç±»å‹åŒ…è£¹çš„å€¼ Ok(T)ï¼Œå½“é”™è¯¯æ—¶ï¼Œè¿”å›ä¸€ä¸ª Err(E)ã€‚å¯¹äº Result è¿”å›æˆ‘ä»¬æœ‰å¾ˆå¤šå¤„ç†æ–¹æ³•ï¼Œæœ€ç®€å•ç²—æš´çš„å°±æ˜¯ unwrap å’Œ expectï¼Œè¿™ä¸¤ä¸ªå‡½æ•°éå¸¸ç±»ä¼¼ï¼Œæˆ‘ä»¬ä»¥ unwrap ä¸¾ä¾‹ï¼š
```rs
use std::net::IpAddr;
let home: IpAddr = "127.0.0.1".parse().unwrap();
```


### è¿”å›å€¼å’Œ?
#### å¯¹è¿”å›çš„é”™è¯¯è¿›è¡Œå¤„ç†
```rs
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open("hello.txt");

    let f = match f {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {:?}", e),
            },
            other_error => panic!("Problem opening the file: {:?}", other_error),
        },
    };
}
```
ä¸Šé¢ä»£ç åœ¨åŒ¹é…å‡º error åï¼Œåˆå¯¹ error è¿›è¡Œäº†è¯¦ç»†çš„åŒ¹é…è§£æï¼Œæœ€ç»ˆç»“æœï¼š

 - å¦‚æœæ˜¯æ–‡ä»¶ä¸å­˜åœ¨é”™è¯¯ ErrorKind::NotFoundï¼Œå°±åˆ›å»ºæ–‡ä»¶ï¼Œè¿™é‡Œåˆ›å»ºæ–‡ä»¶File::create ä¹Ÿæ˜¯è¿”å› Resultï¼Œå› æ­¤ç»§ç»­ç”¨ match å¯¹å…¶ç»“æœè¿›è¡Œå¤„ç†ï¼šåˆ›å»ºæˆåŠŸï¼Œå°†æ–°çš„æ–‡ä»¶å¥æŸ„èµ‹å€¼ç»™ fï¼Œå¦‚æœå¤±è´¥ï¼Œåˆ™ panic
å‰©ä¸‹çš„é”™è¯¯ï¼Œä¸€å¾‹ panic
 - expect è·Ÿ unwrap å¾ˆåƒï¼Œä¹Ÿæ˜¯é‡åˆ°é”™è¯¯ç›´æ¥ panic, ä½†æ˜¯ä¼šå¸¦ä¸Šè‡ªå®šä¹‰çš„é”™è¯¯æç¤ºä¿¡æ¯ï¼Œç›¸å½“äºé‡è½½äº†é”™è¯¯æ‰“å°çš„å‡½æ•°ï¼š

#### å¤±è´¥å°± panic: unwrap å’Œ expect 
åœ¨ä¸éœ€è¦å¤„ç†é”™è¯¯çš„åœºæ™¯ï¼Œä¾‹å¦‚å†™åŸå‹ã€ç¤ºä¾‹æ—¶ï¼Œæˆ‘ä»¬ä¸æƒ³ä½¿ç”¨ match å»åŒ¹é… Result<T, E> ä»¥è·å–å…¶ä¸­çš„ T å€¼ï¼Œå› ä¸º match çš„ç©·å°½åŒ¹é…ç‰¹æ€§ï¼Œä½ æ€»è¦å»å¤„ç†ä¸‹ Err åˆ†æ”¯ã€‚é‚£ä¹ˆæœ‰æ²¡æœ‰åŠæ³•ç®€åŒ–è¿™ä¸ªè¿‡ç¨‹ï¼Ÿæœ‰ï¼Œç­”æ¡ˆå°±æ˜¯ unwrap å’Œ expectã€‚
```rs
use std::fs::File;

fn main() {
    let f = File::open("hello.txt").expect("Failed to open hello.txt");
}

```
å¦‚æœè°ƒç”¨è¿™æ®µä»£ç æ—¶ hello.txt æ–‡ä»¶ä¸å­˜åœ¨ï¼Œé‚£ä¹ˆ unwrap å°±å°†ç›´æ¥ panicï¼š

```shell
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Os { code: 2, kind: NotFound, message: "No such file or directory" }', src/main.rs:4:37
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```
expect è·Ÿ unwrap å¾ˆåƒï¼Œä¹Ÿæ˜¯é‡åˆ°é”™è¯¯ç›´æ¥ panic, ä½†æ˜¯ä¼šå¸¦ä¸Šè‡ªå®šä¹‰çš„é”™è¯¯æç¤ºä¿¡æ¯ï¼Œç›¸å½“äºé‡è½½äº†é”™è¯¯æ‰“å°çš„å‡½æ•°ï¼š
```rs
use std::fs::File;

fn main() {
    let f = File::open("hello.txt").expect("Failed to open hello.txt");
}
```
æŠ¥é”™å¦‚ä¸‹ï¼š
```shell
thread 'main' panicked at 'Failed to open hello.txt: Os { code: 2, kind: NotFound, message: "No such file or directory" }', src/main.rs:4:37
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

```

#### ä¼ æ’­é”™è¯¯
ç¨‹åºå‡ ä¹ä¸å¤ªå¯èƒ½åªæœ‰ A->B å½¢å¼çš„å‡½æ•°è°ƒç”¨ï¼Œä¸€ä¸ªè®¾è®¡è‰¯å¥½çš„ç¨‹åºï¼Œä¸€ä¸ªåŠŸèƒ½æ¶‰åŠåå‡ å±‚çš„å‡½æ•°è°ƒç”¨éƒ½æœ‰å¯èƒ½ã€‚è€Œé”™è¯¯å¤„ç†ä¹Ÿå¾€å¾€ä¸æ˜¯å“ªé‡Œè°ƒç”¨å‡ºé”™ï¼Œå°±åœ¨å“ªé‡Œå¤„ç†ï¼Œå®é™…åº”ç”¨ä¸­ï¼Œå¤§æ¦‚ç‡ä¼šæŠŠé”™è¯¯å±‚å±‚ä¸Šä¼ ç„¶åäº¤ç»™è°ƒç”¨é“¾çš„ä¸Šæ¸¸å‡½æ•°è¿›è¡Œå¤„ç†ï¼Œé”™è¯¯ä¼ æ’­å°†æä¸ºå¸¸è§ã€‚

ä¾‹å¦‚ä»¥ä¸‹å‡½æ•°ä»æ–‡ä»¶ä¸­è¯»å–ç”¨æˆ·åï¼Œç„¶åå°†ç»“æœè¿›è¡Œè¿”å›ï¼š
```rs
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    // æ‰“å¼€æ–‡ä»¶ï¼Œfæ˜¯`Result<æ–‡ä»¶å¥æŸ„,io::Error>`
    let f = File::open("hello.txt");

    let mut f = match f {
        // æ‰“å¼€æ–‡ä»¶æˆåŠŸï¼Œå°†fileå¥æŸ„èµ‹å€¼ç»™f
        Ok(file) => file,
        // æ‰“å¼€æ–‡ä»¶å¤±è´¥ï¼Œå°†é”™è¯¯è¿”å›(å‘ä¸Šä¼ æ’­)
        Err(e) => return Err(e),
    };
    // åˆ›å»ºåŠ¨æ€å­—ç¬¦ä¸²s
    let mut s = String::new();
    // ä»fæ–‡ä»¶å¥æŸ„è¯»å–æ•°æ®å¹¶å†™å…¥sä¸­
    match f.read_to_string(&mut s) {
        // è¯»å–æˆåŠŸï¼Œè¿”å›Okå°è£…çš„å­—ç¬¦ä¸²
        Ok(_) => Ok(s),
        // å°†é”™è¯¯å‘ä¸Šä¼ æ’­
        Err(e) => Err(e),
    }
}
```

æœ‰å‡ ç‚¹å€¼å¾—æ³¨æ„ï¼š

- è¯¥å‡½æ•°è¿”å›ä¸€ä¸ª Result<String, io::Error> ç±»å‹ï¼Œå½“è¯»å–ç”¨æˆ·åæˆåŠŸæ—¶ï¼Œè¿”å› Ok(String)ï¼Œå¤±è´¥æ—¶ï¼Œè¿”å› Err(io:Error)
- File::open å’Œ f.read_to_string è¿”å›çš„ Result<T, E> ä¸­çš„ E å°±æ˜¯ io::Error
ç”±æ­¤å¯è§ï¼Œè¯¥å‡½æ•°å°† io::Error çš„é”™è¯¯å¾€ä¸Šè¿›è¡Œä¼ æ’­ï¼Œè¯¥å‡½æ•°çš„è°ƒç”¨è€…æœ€ç»ˆä¼šå¯¹ Result<String,io::Error> è¿›è¡Œå†å¤„ç†ï¼Œè‡³äºæ€ä¹ˆå¤„ç†å°±æ˜¯è°ƒç”¨è€…çš„äº‹ï¼Œå¦‚æœæ˜¯é”™è¯¯ï¼Œå®ƒå¯ä»¥é€‰æ‹©ç»§ç»­å‘ä¸Šä¼ æ’­é”™è¯¯ï¼Œä¹Ÿå¯ä»¥ç›´æ¥ panicï¼Œäº¦æˆ–å°†å…·ä½“çš„é”™è¯¯åŸå› åŒ…è£…åå†™å…¥ socket ä¸­å‘ˆç°ç»™ç»ˆç«¯ç”¨æˆ·ã€‚

ã€‚

ä¼ æ’­ç•Œçš„å¤§æ˜æ˜Ÿ: ?

```rs
use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -> Result<String, io::Error> {
    let mut f = File::open("hello.txt")?;
    let mut s = String::new();
    f.read_to_string(&mut s)?;
    Ok(s)
}
```

çœ‹åˆ°æ²¡ï¼Œè¿™å°±æ˜¯æ’é¢ï¼Œç›¸æ¯”å‰é¢çš„ match å¤„ç†é”™è¯¯çš„å‡½æ•°ï¼Œä»£ç ç›´æ¥å‡å°‘äº†ä¸€åŠä¸æ­¢.

å…¶å® ? å°±æ˜¯ä¸€ä¸ªå®ï¼Œå®ƒçš„ä½œç”¨è·Ÿä¸Šé¢çš„ match å‡ ä¹ä¸€æ¨¡ä¸€æ ·ï¼š
```rs
let mut f = match f {
    // æ‰“å¼€æ–‡ä»¶æˆåŠŸï¼Œå°†fileå¥æŸ„èµ‹å€¼ç»™f
    Ok(file) => file,
    // æ‰“å¼€æ–‡ä»¶å¤±è´¥ï¼Œå°†é”™è¯¯è¿”å›(å‘ä¸Šä¼ æ’­)
    Err(e) => return Err(e),
};
```

å¦‚æœç»“æœæ˜¯ Ok(T)ï¼Œåˆ™æŠŠ T èµ‹å€¼ç»™ fï¼Œå¦‚æœç»“æœæ˜¯ Err(E)ï¼Œåˆ™è¿”å›è¯¥é”™è¯¯ï¼Œæ‰€ä»¥ ? ç‰¹åˆ«é€‚åˆç”¨æ¥ä¼ æ’­é”™è¯¯ã€‚

è™½ç„¶ ? å’Œ match åŠŸèƒ½ä¸€è‡´ï¼Œä½†æ˜¯äº‹å®ä¸Š ? ä¼šæ›´èƒœä¸€ç­¹ã€‚

æƒ³è±¡ä¸€ä¸‹ï¼Œä¸€ä¸ªè®¾è®¡è‰¯å¥½çš„ç³»ç»Ÿä¸­ï¼Œè‚¯å®šæœ‰è‡ªå®šä¹‰çš„é”™è¯¯ç‰¹å¾ï¼Œé”™è¯¯ä¹‹é—´å¾ˆå¯èƒ½ä¼šå­˜åœ¨ä¸Šä¸‹çº§å…³ç³»ï¼Œä¾‹å¦‚æ ‡å‡†åº“ä¸­çš„ std::io::Error å’Œ std::error::Errorï¼Œå‰è€…æ˜¯ IO ç›¸å…³çš„é”™è¯¯ç»“æ„ä½“ï¼Œåè€…æ˜¯ä¸€ä¸ªæœ€æœ€é€šç”¨çš„æ ‡å‡†é”™è¯¯ç‰¹å¾ï¼ŒåŒæ—¶å‰è€…å®ç°äº†åè€…ï¼Œå› æ­¤ std::io::Error å¯ä»¥è½¬æ¢ä¸º std:error::Errorã€‚

æ˜ç™½äº†ä»¥ä¸Šçš„é”™è¯¯è½¬æ¢ï¼Œ? çš„æ›´èƒœä¸€ç­¹å°±å¾ˆå¥½ç†è§£äº†ï¼Œå®ƒå¯ä»¥è‡ªåŠ¨è¿›è¡Œç±»å‹æå‡ï¼ˆè½¬æ¢ï¼‰ï¼š
```rs
fn open_file() -> Result<File, Box<dyn std::error::Error>> {
    let mut f = File::open("hello.txt")?;
    Ok(f)
}
```

ä¸Šé¢ä»£ç ä¸­ File::open æŠ¥é”™æ—¶è¿”å›çš„é”™è¯¯æ˜¯ std::io::Error ç±»å‹ï¼Œä½†æ˜¯ open_file å‡½æ•°è¿”å›çš„é”™è¯¯ç±»å‹æ˜¯ std::error::Error çš„ç‰¹å¾å¯¹è±¡ï¼Œå¯ä»¥çœ‹åˆ°ä¸€ä¸ªé”™è¯¯ç±»å‹é€šè¿‡ ? è¿”å›åï¼Œå˜æˆäº†å¦ä¸€ä¸ªé”™è¯¯ç±»å‹ï¼Œè¿™å°±æ˜¯ ? çš„ç¥å¥‡ä¹‹å¤„ã€‚

æ ¹æœ¬åŸå› æ˜¯åœ¨äºæ ‡å‡†åº“ä¸­å®šä¹‰çš„ From ç‰¹å¾ï¼Œè¯¥ç‰¹å¾æœ‰ä¸€ä¸ªæ–¹æ³• fromï¼Œç”¨äºæŠŠä¸€ä¸ªç±»å‹è½¬æˆå¦å¤–ä¸€ä¸ªç±»å‹ï¼Œ? å¯ä»¥è‡ªåŠ¨è°ƒç”¨è¯¥æ–¹æ³•ï¼Œç„¶åè¿›è¡Œéšå¼ç±»å‹è½¬æ¢ã€‚å› æ­¤åªè¦å‡½æ•°è¿”å›çš„é”™è¯¯ ReturnError å®ç°äº† From<OtherError> ç‰¹å¾ï¼Œé‚£ä¹ˆ ? å°±ä¼šè‡ªåŠ¨æŠŠ OtherError è½¬æ¢ä¸º ReturnErrorã€‚

è¿™ç§è½¬æ¢éå¸¸å¥½ç”¨ï¼Œæ„å‘³ç€ä½ å¯ä»¥ç”¨ä¸€ä¸ªå¤§è€Œå…¨çš„ ReturnError æ¥è¦†ç›–æ‰€æœ‰é”™è¯¯ç±»å‹ï¼Œåªéœ€è¦ä¸ºå„ç§å­é”™è¯¯ç±»å‹å®ç°è¿™ç§è½¬æ¢å³å¯ã€‚

```rs
use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -> Result<String, io::Error> {
    let mut s = String::new();

    File::open("hello.txt")?.read_to_string(&mut s)?;

    Ok(s)
}
```


ï¼Ÿ ? è¿˜èƒ½å®ç°é“¾å¼è°ƒç”¨ï¼ŒFile::open é‡åˆ°é”™è¯¯å°±è¿”å›ï¼Œæ²¡æœ‰é”™è¯¯å°±å°† Ok ä¸­çš„å€¼å–å‡ºæ¥ç”¨äºä¸‹ä¸€ä¸ªæ–¹æ³•è°ƒç”¨ï¼Œç®€ç›´å¤ªç²¾å¦™äº†.

```rs
use std::fs;
use std::io;

fn read_username_from_file() -> Result<String, io::Error> {
    // read_to_stringæ˜¯å®šä¹‰åœ¨std::ioä¸­çš„æ–¹æ³•ï¼Œå› æ­¤éœ€è¦åœ¨ä¸Šé¢è¿›è¡Œå¼•ç”¨
    fs::read_to_string("hello.txt")
}
```

ä»æ–‡ä»¶è¯»å–æ•°æ®åˆ°å­—ç¬¦ä¸²ä¸­ï¼Œæ˜¯æ¯”è¾ƒå¸¸è§çš„æ“ä½œï¼Œå› æ­¤ Rust æ ‡å‡†åº“ä¸ºæˆ‘ä»¬æä¾›äº† fs::read_to_string å‡½æ•°ï¼Œè¯¥å‡½æ•°å†…éƒ¨ä¼šæ‰“å¼€ä¸€ä¸ªæ–‡ä»¶ã€åˆ›å»º Stringã€è¯»å–æ–‡ä»¶å†…å®¹æœ€åå†™å…¥å­—ç¬¦ä¸²å¹¶è¿”å›ï¼Œå› ä¸ºè¯¥å‡½æ•°å…¶å®ä¸æœ¬ç« è®²çš„å†…å®¹å…³ç³»ä¸å¤§ï¼Œå› æ­¤æ”¾åœ¨æœ€åæ¥è®²ï¼Œå…¶å®åªæ˜¯æˆ‘æƒ³éœ‡ä½ ä»¬ä¸€ä¸‹ :

##### ? ç”¨äº Option çš„è¿”å›
? ä¸ä»…ä»…å¯ä»¥ç”¨äº Result çš„ä¼ æ’­ï¼Œè¿˜èƒ½ç”¨äº Option çš„ä¼ æ’­ï¼Œå†æ¥å›å¿†ä¸‹ Option çš„å®šä¹‰ï¼š
```rs
pub enum Option<T> {
    Some(T),
    None
}
```

Result é€šè¿‡ ? è¿”å›é”™è¯¯ï¼Œé‚£ä¹ˆ Option å°±é€šè¿‡ ? è¿”å› Noneï¼š
```rs
fn first(arr: &[i32]) -> Option<&i32> {
   let v = arr.get(0)?;
   Some(v)
}
```


##### æ–°æ‰‹ç”¨ ? å¸¸ä¼šçŠ¯çš„é”™è¯¯
åˆå­¦è€…åœ¨ç”¨ ? æ—¶ï¼Œè€æ˜¯ä¼šçŠ¯é”™ï¼Œä¾‹å¦‚å†™å‡ºè¿™æ ·çš„ä»£ç ï¼š
```rs
fn first(arr: &[i32]) -> Option<&i32> {
   arr.get(0)?
}
```

è¿™æ®µä»£ç æ— æ³•é€šè¿‡ç¼–è¯‘ï¼Œåˆ‡è®°ï¼š? æ“ä½œç¬¦éœ€è¦ä¸€ä¸ªå˜é‡æ¥æ‰¿è½½æ­£ç¡®çš„å€¼ï¼Œè¿™ä¸ªå‡½æ•°åªä¼šè¿”å› Some(&i32) æˆ–è€… Noneï¼Œåªæœ‰é”™è¯¯å€¼èƒ½ç›´æ¥è¿”å›ï¼Œæ­£ç¡®çš„å€¼ä¸è¡Œï¼Œæ‰€ä»¥å¦‚æœæ•°ç»„ä¸­å­˜åœ¨ 0 å·å…ƒç´ ï¼Œé‚£ä¹ˆå‡½æ•°ç¬¬äºŒè¡Œä½¿ç”¨ ? åçš„è¿”å›ç±»å‹ä¸º &i32 è€Œä¸æ˜¯ Some(&i32)ã€‚å› æ­¤ ? åªèƒ½ç”¨äºä»¥ä¸‹å½¢å¼ï¼š
```rs
let v = xxx()?;
xxx()?.yyy()?;
```

##### å¸¦è¿”å›å€¼çš„ main å‡½æ•°
åœ¨äº†è§£äº† ? çš„ä½¿ç”¨é™åˆ¶åï¼Œè¿™æ®µä»£ç ä½ å¾ˆå®¹æ˜“çœ‹å‡ºå®ƒæ— æ³•ç¼–è¯‘ï¼š
```rs
use std::fs::File;

fn main() {
    let f = File::open("hello.txt")?;
}
```

è¿è¡Œåä¼šæŠ¥é”™:
```shell
$ cargo run
   ...
   the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
 --> src/main.rs:4:48
  |
3 | fn main() {
  | --------- this function should return `Result` or `Option` to accept `?`
4 |     let greeting_file = File::open("hello.txt")?;
  |                                                ^ cannot use the `?` operator in a function that returns `()`
  |
  = help: the trait `FromResidual<Result<Infallible, std::io::Error>>` is not implemented for `()`
```

å› ä¸º ? è¦æ±‚ Result<T, E> å½¢å¼çš„è¿”å›å€¼ï¼Œè€Œ main å‡½æ•°çš„è¿”å›æ˜¯ ()ï¼Œå› æ­¤æ— æ³•æ»¡è¶³ï¼Œé‚£æ˜¯ä¸æ˜¯å°±æ— è§£äº†å‘¢ï¼Ÿ

å®é™…ä¸Š Rust è¿˜æ”¯æŒå¦å¤–ä¸€ç§å½¢å¼çš„ main å‡½æ•°ï¼š
```rs
use std::error::Error;
use std::fs::File;

fn main() -> Result<(), Box<dyn Error>> {
    let f = File::open("hello.txt")?;

    Ok(())
}
```

è¿™æ ·å°±èƒ½ä½¿ç”¨ ? æå‰è¿”å›äº†ï¼ŒåŒæ—¶æˆ‘ä»¬åˆä¸€æ¬¡çœ‹åˆ°äº†Box<dyn Error> ç‰¹å¾å¯¹è±¡ï¼Œå› ä¸º std::error:Error æ˜¯ Rust ä¸­æŠ½è±¡å±‚æ¬¡æœ€é«˜çš„é”™è¯¯ï¼Œå…¶å®ƒæ ‡å‡†åº“ä¸­çš„é”™è¯¯éƒ½å®ç°äº†è¯¥ç‰¹å¾ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ç”¨è¯¥ç‰¹å¾å¯¹è±¡ä»£è¡¨ä¸€åˆ‡é”™è¯¯ï¼Œå°±ç®— main å‡½æ•°ä¸­è°ƒç”¨ä»»ä½•æ ‡å‡†åº“å‡½æ•°å‘ç”Ÿé”™è¯¯ï¼Œéƒ½å¯ä»¥é€šè¿‡ Box&lt;dyn Error> è¿™ä¸ªç‰¹å¾å¯¹è±¡è¿›è¡Œè¿”å›ã€‚




## åŒ…å’Œæ¨¡å—
### åŒ…å’Œ Package
#### åŒ… Crate

å¯¹äº Rust è€Œè¨€ï¼ŒåŒ…æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„å¯ç¼–è¯‘å•å…ƒï¼Œå®ƒç¼–è¯‘åä¼šç”Ÿæˆä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶æˆ–è€…ä¸€ä¸ªåº“ã€‚

ä¸€ä¸ªåŒ…ä¼šå°†ç›¸å…³è”çš„åŠŸèƒ½æ‰“åŒ…åœ¨ä¸€èµ·ï¼Œä½¿å¾—è¯¥åŠŸèƒ½å¯ä»¥å¾ˆæ–¹ä¾¿çš„åœ¨å¤šä¸ªé¡¹ç›®ä¸­åˆ†äº«ã€‚ä¾‹å¦‚æ ‡å‡†åº“ä¸­æ²¡æœ‰æä¾›ä½†æ˜¯åœ¨ä¸‰æ–¹åº“ä¸­æä¾›çš„ rand åŒ…ï¼Œå®ƒæä¾›äº†éšæœºæ•°ç”Ÿæˆçš„åŠŸèƒ½ï¼Œæˆ‘ä»¬åªéœ€è¦å°†è¯¥åŒ…é€šè¿‡ use rand; å¼•å…¥åˆ°å½“å‰é¡¹ç›®çš„ä½œç”¨åŸŸä¸­ï¼Œå°±å¯ä»¥åœ¨é¡¹ç›®ä¸­ä½¿ç”¨ rand çš„åŠŸèƒ½ï¼šrand::XXXã€‚
#### é¡¹ç›® Package
ç”±äº Package å°±æ˜¯ä¸€ä¸ªé¡¹ç›®ï¼Œå› æ­¤å®ƒåŒ…å«æœ‰ç‹¬ç«‹çš„ Cargo.toml æ–‡ä»¶ï¼Œä»¥åŠå› ä¸ºåŠŸèƒ½æ€§è¢«ç»„ç»‡åœ¨ä¸€èµ·çš„ä¸€ä¸ªæˆ–å¤šä¸ªåŒ…ã€‚ä¸€ä¸ª Package åªèƒ½åŒ…å«ä¸€ä¸ªåº“(library)ç±»å‹çš„åŒ…ï¼Œä½†æ˜¯å¯ä»¥åŒ…å«å¤šä¸ªäºŒè¿›åˆ¶å¯æ‰§è¡Œç±»å‹çš„åŒ…ã€‚


åªè¦ä½ ç‰¢è®° Package æ˜¯ä¸€ä¸ªé¡¹ç›®å·¥ç¨‹ï¼Œè€ŒåŒ…åªæ˜¯ä¸€ä¸ªç¼–è¯‘å•å…ƒï¼ŒåŸºæœ¬ä¸Šä¹Ÿå°±ä¸ä¼šæ··æ·†è¿™ä¸ªä¸¤ä¸ªæ¦‚å¿µäº†ï¼šsrc/main.rs å’Œ src/lib.rs éƒ½æ˜¯ç¼–è¯‘å•å…ƒï¼Œå› æ­¤å®ƒä»¬éƒ½æ˜¯åŒ…ã€‚


### æ¨¡å— Module
ä½¿ç”¨ cargo new --lib restaurant åˆ›å»ºä¸€ä¸ªå°é¤é¦†ï¼Œæ³¨æ„ï¼Œè¿™é‡Œåˆ›å»ºçš„æ˜¯ä¸€ä¸ªåº“ç±»å‹çš„ Packageï¼Œç„¶åå°†ä»¥ä¸‹ä»£ç æ”¾å…¥ src/lib.rs ä¸­ï¼š
```rs
// é¤å…å‰å…ï¼Œç”¨äºåƒé¥­
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
```
- ä½¿ç”¨ mod å…³é”®å­—æ¥åˆ›å»ºæ–°æ¨¡å—ï¼Œåé¢ç´§è·Ÿç€æ¨¡å—åç§°
- æ¨¡å—å¯ä»¥åµŒå¥—ï¼Œè¿™é‡ŒåµŒå¥—çš„åŸå› æ˜¯æ‹›å¾…å®¢äººå’ŒæœåŠ¡éƒ½å‘ç”Ÿåœ¨å‰å…ï¼Œå› æ­¤æˆ‘ä»¬çš„ä»£ç æ¨¡æ‹Ÿäº†çœŸå®åœºæ™¯
- æ¨¡å—ä¸­å¯ä»¥å®šä¹‰å„ç§ Rust ç±»å‹ï¼Œä¾‹å¦‚å‡½æ•°ã€ç»“æ„ä½“ã€æšä¸¾ã€ç‰¹å¾ç­‰
- æ‰€æœ‰æ¨¡å—å‡å®šä¹‰åœ¨åŒä¸€ä¸ªæ–‡ä»¶ä¸­

### ä½¿ç”¨ use åŠå—é™å¯è§æ€§
#### åŸºæœ¬å¼•å…¥æ–¹å¼
##### ç»å¯¹è·¯å¾„å¼•å…¥æ¨¡å—
```rs
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}

```
è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨ use å’Œç»å¯¹è·¯å¾„çš„æ–¹å¼ï¼Œå°† hosting æ¨¡å—å¼•å…¥åˆ°å½“å‰ä½œç”¨åŸŸä¸­ï¼Œç„¶ååªéœ€é€šè¿‡ hosting::add_to_waitlist çš„æ–¹å¼ï¼Œå³å¯è°ƒç”¨ç›®æ ‡æ¨¡å—ä¸­çš„å‡½æ•°
##### ç›¸å¯¹è·¯å¾„å¼•å…¥æ¨¡å—ä¸­çš„å‡½æ•°
```rs
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
    add_to_waitlist();
    add_to_waitlist();
}

```
## æ³¨é‡Šå’Œæ–‡æ¡£
### æ–‡æ¡£æ³¨é‡Š
cargo doc --open

Rust æä¾›äº† cargo doc çš„å‘½ä»¤ï¼Œå¯ä»¥ç”¨äºæŠŠè¿™äº›æ–‡æ¡£æ³¨é‡Šè½¬æ¢æˆ HTML ç½‘é¡µæ–‡ä»¶ï¼Œæœ€ç»ˆå±•ç¤ºç»™ç”¨æˆ·æµè§ˆï¼Œè¿™æ ·ç”¨æˆ·å°±çŸ¥é“è¿™ä¸ªåŒ…æ˜¯åšä»€ä¹ˆçš„ä»¥åŠè¯¥å¦‚ä½•ä½¿ç”¨ã€‚

```rs
/// `add_one` å°†æŒ‡å®šå€¼åŠ 1
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -> i32 {
    x + 1
}

```
- æ–‡æ¡£æ³¨é‡Šéœ€è¦ä½äº lib ç±»å‹çš„åŒ…ä¸­ï¼Œä¾‹å¦‚ src/lib.rs ä¸­
- æ–‡æ¡£æ³¨é‡Šå¯ä»¥ä½¿ç”¨ markdownè¯­æ³•ï¼ä¾‹å¦‚ # Examples çš„æ ‡é¢˜ï¼Œä»¥åŠä»£ç å—é«˜äº®
- è¢«æ³¨é‡Šçš„å¯¹è±¡éœ€è¦ä½¿ç”¨ pub å¯¹å¤–å¯è§ï¼Œè®°ä½ï¼šæ–‡æ¡£æ³¨é‡Šæ˜¯ç»™ç”¨æˆ·çœ‹çš„ï¼Œå†…éƒ¨å®ç°ç»†èŠ‚ä¸åº”è¯¥è¢«æš´éœ²å‡ºå»
### æ–‡æ¡£æµ‹è¯•(Doc Test)
```rs
/// `add_one` å°†æŒ‡å®šå€¼åŠ 1
///
/// # Examples11
///
/// ```
/// let arg = 5;
/// let answer = world_hello::compute::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -> i32 {
    x + 1
}

```
ä»¥ä¸Šçš„æ³¨é‡Šä¸ä»…ä»…æ˜¯æ–‡æ¡£ï¼Œè¿˜å¯ä»¥ä½œä¸ºå•å…ƒæµ‹è¯•çš„ç”¨ä¾‹è¿è¡Œï¼Œä½¿ç”¨ cargo test è¿è¡Œæµ‹è¯•ï¼š

## æ ¼å¼åŒ–è¾“å‡º


 # è‡ªåŠ¨åŒ–æµ‹è¯•
## ç¼–å†™æµ‹è¯•åŠæ§åˆ¶æ‰§è¡Œ
### æµ‹è¯•å‡½æ•°
å½“ä½¿ç”¨ Cargo åˆ›å»ºä¸€ä¸ª lib ç±»å‹çš„åŒ…æ—¶ï¼Œå®ƒä¼šä¸ºæˆ‘ä»¬è‡ªåŠ¨ç”Ÿæˆä¸€ä¸ªæµ‹è¯•æ¨¡å—ã€‚å…ˆæ¥åˆ›å»ºä¸€ä¸ª lib ç±»å‹çš„ adder åŒ…ï¼š
```cmd
$ cargo new adder --lib
     Created library `adder` project 
$ cd adder
```
**cargo testå¯ä»¥æ‰§è¡ŒåŒ…ä¸‹é¢å…¨éƒ¨çš„æµ‹è¯•**
åˆ›å»ºæˆåŠŸåï¼Œåœ¨ src/lib.rs æ–‡ä»¶ä¸­å¯ä»¥å‘ç°å¦‚ä¸‹ä»£ç :
```rs
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
```
### è‡ªå®šä¹‰å¤±è´¥ä¿¡æ¯
```rs
pub fn greeting(name: &str) -> String {
    format!("Hello {}!", name)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
    let result = greeting("Sunface");
    let target = "å­™é£";
    assert!(
        result.contains(target),
        "ä½ çš„é—®å€™ä¸­å¹¶æ²¡æœ‰åŒ…å«ç›®æ ‡å§“å {} ï¼Œä½ çš„é—®å€™æ˜¯ `{}`",
        target,
        result
    );
}

}

```
### æµ‹è¯• panic
```rs
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}
```
### æµ‹è¯•panic
```rs
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}

```


```rs
// --snip--
impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 {
            panic!(
                "Guess value must be greater than or equal to 1, got {}.",
                value
            );
        } else if value > 100 {
            panic!(
                "Guess value must be less than or equal to 100, got {}.",
                value
            );
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = "Guess value must be less than or equal to 100")]
    fn greater_than_100() {
        Guess::new(200);
    }
}
```
### ä½¿ç”¨ Result<T, E>
```rs
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -> Result<(), String> {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from("two plus two does not equal four"))
        }
    }
}

```
## å•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•
### å•å…ƒæµ‹è¯•
æ¡ä»¶ç¼–è¯‘ #[cfg(test)]
ä¸Šé¢ä»£ç ä¸­çš„ #[cfg(test)] æ ‡æ³¨å¯ä»¥å‘Šè¯‰ Rust åªæœ‰åœ¨ cargo test æ—¶æ‰ç¼–è¯‘å’Œè¿è¡Œæ¨¡å— testsï¼Œå…¶å®ƒæ—¶å€™å½“è¿™æ®µä»£ç æ˜¯ç©ºæ°”å³å¯ï¼Œä¾‹å¦‚åœ¨ cargo build æ—¶ã€‚è¿™ä¹ˆåšæœ‰å‡ ä¸ªå¥½å¤„ï¼š

### é›†æˆæµ‹è¯•
tests ç›®å½•
ä¸€ä¸ªæ ‡å‡†çš„ Rust é¡¹ç›®ï¼Œåœ¨å®ƒçš„æ ¹ç›®å½•ä¸‹ä¼šæœ‰ä¸€ä¸ª tests ç›®å½•ï¼Œå¤§åé¼é¼çš„ ripgrep ä¹Ÿä¸èƒ½å…ä¿—ã€‚

# è¿›é˜¶
## ç”Ÿå‘½å‘¨æœŸ
### æ·±å…¥ç”Ÿå‘½å‘¨æœŸ


## å‡½æ•°å¼ç¼–ç¨‹
### é—­åŒ…
é—­åŒ…æ˜¯ä¸€ç§åŒ¿åå‡½æ•°ï¼Œå®ƒå¯ä»¥èµ‹å€¼ç»™å˜é‡ä¹Ÿå¯ä»¥ä½œä¸ºå‚æ•°ä¼ é€’ç»™å…¶å®ƒå‡½æ•°ï¼Œä¸åŒäºå‡½æ•°çš„æ˜¯ï¼Œå®ƒå…è®¸æ•è·è°ƒç”¨è€…ä½œç”¨åŸŸä¸­çš„å€¼ï¼Œä¾‹å¦‚ï¼š
```rs
fn main() {
   let x = 1;
   let sum = |y| x + y;

    assert_eq!(3, sum(2));
}
```

ä¸Šé¢çš„ä»£ç å±•ç¤ºäº†éå¸¸ç®€å•çš„é—­åŒ… sumï¼Œå®ƒæ‹¥æœ‰ä¸€ä¸ªå…¥å‚ yï¼ŒåŒæ—¶æ•è·äº†ä½œç”¨åŸŸä¸­çš„ x çš„å€¼ï¼Œå› æ­¤è°ƒç”¨ sum(2) æ„å‘³ç€å°† 2ï¼ˆå‚æ•° yï¼‰è·Ÿ 1ï¼ˆxï¼‰è¿›è¡Œç›¸åŠ ,æœ€ç»ˆè¿”å›å®ƒä»¬çš„å’Œï¼š3ã€‚

å¯ä»¥çœ‹åˆ° sum éå¸¸ç¬¦åˆé—­åŒ…çš„å®šä¹‰ï¼šå¯ä»¥èµ‹å€¼ç»™å˜é‡ï¼Œå…è®¸æ•è·è°ƒç”¨è€…ä½œç”¨åŸŸä¸­çš„å€¼ã€‚
#### ä½¿ç”¨é—­åŒ…æ¥ç®€åŒ–ä»£ç 
##### ä¼ ç»Ÿå‡½æ•°å®ç°
æƒ³è±¡ä¸€ä¸‹ï¼Œæˆ‘ä»¬è¦è¿›è¡Œå¥èº«ï¼Œç”¨ä»£ç æ€ä¹ˆå®ç°,è¿™é‡Œæ˜¯æˆ‘çš„æƒ³æ³•ï¼š
```rs
use std::thread;
use std::time::Duration;

// å¼€å§‹å¥èº«ï¼Œå¥½ç´¯ï¼Œæˆ‘å¾—å‘å‡ºå£°éŸ³ï¼šmuuuu...
fn muuuuu(intensity: u32) -> u32 {
    println!("muuuu.....");
    thread::sleep(Duration::from_secs(2));
    intensity
}

fn workout(intensity: u32, random_number: u32) {
    if intensity < 25 {
        println!(
            "ä»Šå¤©æ´»åŠ›æ»¡æ»¡ï¼Œå…ˆåš {} ä¸ªä¿¯å§æ’‘!",
            muuuuu(intensity)
        );
        println!(
            "æ—è¾¹æœ‰å¦¹å­åœ¨çœ‹ï¼Œä¿¯å§æ’‘å¤ªlowï¼Œå†æ¥ {} ç»„å§æ¨!",
            muuuuu(intensity)
        );
    } else if random_number == 3 {
        println!("æ˜¨å¤©ç»ƒè¿‡åº¦äº†ï¼Œä»Šå¤©è¿˜æ˜¯ä¼‘æ¯ä¸‹å§ï¼");
    } else {
        println!(
            "æ˜¨å¤©ç»ƒè¿‡åº¦äº†ï¼Œä»Šå¤©å¹²å¹²æœ‰æ°§ï¼Œè·‘æ­¥ {} åˆ†é’Ÿ!",
            muuuuu(intensity)
        );
    }
}

fn main() {
    // å¼ºåº¦
    let intensity = 10;
    // éšæœºå€¼ç”¨æ¥å†³å®šæŸä¸ªé€‰æ‹©
    let random_number = 7;

    // å¼€å§‹å¥èº«
    workout(intensity, random_number);
}
```

å¯ä»¥çœ‹åˆ°ï¼Œåœ¨å¥èº«æ—¶æˆ‘ä»¬æ ¹æ®æƒ³è¦çš„å¼ºåº¦æ¥è°ƒæ•´å…·ä½“çš„åŠ¨ä½œï¼Œç„¶åè°ƒç”¨ muuuuu å‡½æ•°æ¥å¼€å§‹å¥èº«ã€‚è¿™ä¸ªç¨‹åºæœ¬èº«å¾ˆç®€å•ï¼Œæ²¡å•¥å¥½è¯´çš„ï¼Œä½†æ˜¯å‡å¦‚æœªæ¥ä¸ç”¨ muuuuu å‡½æ•°äº†ï¼Œæ˜¯ä¸æ˜¯å¾—æŠŠæ‰€æœ‰ muuuuu éƒ½æ›¿æ¢æˆï¼Œæ¯”å¦‚è¯´ woooo ï¼Ÿå¦‚æœ muuuuu å‡ºç°äº†å‡ åæ¬¡ï¼Œé‚£æ„å‘³ç€æˆ‘ä»¬è¦ä¿®æ”¹å‡ åå¤„åœ°æ–¹ã€‚
#### é—­åŒ…å®ç°

```rs
use std::thread;
use std::time::Duration;

fn workout(intensity: u32, random_number: u32) {
    let action = || {
        println!("muuuu.....");
        thread::sleep(Duration::from_secs(2));
        intensity
    };

    if intensity < 25 {
        println!(
            "ä»Šå¤©æ´»åŠ›æ»¡æ»¡ï¼Œå…ˆåš {} ä¸ªä¿¯å§æ’‘!",
            action()
        );
        println!(
            "æ—è¾¹æœ‰å¦¹å­åœ¨çœ‹ï¼Œä¿¯å§æ’‘å¤ªlowï¼Œå†æ¥ {} ç»„å§æ¨!",
            action()
        );
    } else if random_number == 3 {
        println!("æ˜¨å¤©ç»ƒè¿‡åº¦äº†ï¼Œä»Šå¤©è¿˜æ˜¯ä¼‘æ¯ä¸‹å§ï¼");
    } else {
        println!(
            "æ˜¨å¤©ç»ƒè¿‡åº¦äº†ï¼Œä»Šå¤©å¹²å¹²æœ‰æ°§ï¼Œè·‘æ­¥ {} åˆ†é’Ÿ!",
            action()
        );
    }
}

fn main() {
    // åŠ¨ä½œæ¬¡æ•°
    let intensity = 10;
    // éšæœºå€¼ç”¨æ¥å†³å®šæŸä¸ªé€‰æ‹©
    let random_number = 7;
FnOnceï¼Œè¯¥ç±»å‹çš„é—­åŒ…ä¼šæ‹¿èµ°è¢«æ•è·å˜é‡çš„æ‰€æœ‰æƒã€‚Once é¡¾åæ€ä¹‰ï¼Œè¯´æ˜è¯¥é—­åŒ…åªèƒ½è¿è¡Œä¸€æ¬¡ï¼š
    // å¼€å§‹å¥èº«
    workout(intensity, random_number);
}
```
åœ¨ä¸Šé¢ä»£ç ä¸­ï¼Œæ— è®ºä½ è¦ä¿®æ”¹ä»€ä¹ˆï¼Œåªè¦ä¿®æ”¹é—­åŒ… action çš„å®ç°å³å¯ï¼Œå…¶å®ƒåœ°æ–¹åªè´Ÿè´£è°ƒç”¨ï¼Œå®Œç¾è§£å†³äº†æˆ‘ä»¬çš„é—®é¢˜ï¼

Rust é—­åŒ…åœ¨å½¢å¼ä¸Šå€Ÿé‰´äº† Smalltalk å’Œ Ruby è¯­è¨€ï¼Œä¸å‡½æ•°æœ€å¤§çš„ä¸åŒå°±æ˜¯å®ƒçš„å‚æ•°æ˜¯é€šè¿‡ |parm1| çš„å½¢å¼è¿›è¡Œå£°æ˜ï¼Œå¦‚æœæ˜¯å¤šä¸ªå‚æ•°å°± |param1, param2,...|ï¼Œ ä¸‹é¢ç»™å‡ºé—­åŒ…çš„å½¢å¼å®šä¹‰ï¼š
```rs
|param1, param2,...| {
    è¯­å¥1;
    è¯­å¥2;
    è¿”å›è¡¨è¾¾å¼
}
```

#### é—­åŒ…çš„ç±»å‹æ¨å¯¼
ä¸å‡½æ•°ç›¸åï¼Œé—­åŒ…å¹¶ä¸ä¼šä½œä¸º API å¯¹å¤–æä¾›ï¼Œå› æ­¤å®ƒå¯ä»¥äº«å—ç¼–è¯‘å™¨çš„ç±»å‹æ¨å¯¼èƒ½åŠ›ï¼Œæ— éœ€æ ‡æ³¨å‚æ•°å’Œè¿”å›å€¼çš„ç±»å‹ã€‚
ä¸‹é¢å±•ç¤ºäº†åŒä¸€ä¸ªåŠŸèƒ½çš„å‡½æ•°å’Œé—­åŒ…å®ç°å½¢å¼ï¼š
```rs
fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
```
è™½ç„¶ç±»å‹æ¨å¯¼å¾ˆå¥½ç”¨ï¼Œä½†æ˜¯å®ƒä¸æ˜¯æ³›å‹ï¼Œå½“ç¼–è¯‘å™¨æ¨å¯¼å‡ºä¸€ç§ç±»å‹åï¼Œå®ƒå°±ä¼šä¸€ç›´ä½¿ç”¨è¯¥ç±»å‹ï¼š
```rs
let example_closure = |x| x;

let s = example_closure(String::from("hello"));
let n = example_closure(5);
```

é¦–å…ˆï¼Œåœ¨ s ä¸­ï¼Œç¼–è¯‘å™¨ä¸º x æ¨å¯¼å‡ºç±»å‹ Stringï¼Œä½†æ˜¯ç´§æ¥ç€ n è¯•å›¾ç”¨ 5 è¿™ä¸ªæ•´å‹å»è°ƒç”¨é—­åŒ…ï¼Œè·Ÿç¼–è¯‘å™¨ä¹‹å‰æ¨å¯¼çš„ String ç±»å‹ä¸ç¬¦ï¼Œå› æ­¤æŠ¥é”™ï¼š
```shell
error[E0308]: mismatched types
 --> src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |                             ^
  |                             |
  |                             expected struct `String`, found integer // æœŸå¾…Stringç±»å‹ï¼Œå´å‘ç°ä¸€ä¸ªæ•´æ•°
  |                             help: try using a conversion method: `5.to_string()`

```


#### ç»“æ„ä½“ä¸­çš„é—­åŒ…
å‡è®¾æˆ‘ä»¬è¦å®ç°ä¸€ä¸ªç®€æ˜“ç¼“å­˜ï¼ŒåŠŸèƒ½æ˜¯è·å–ä¸€ä¸ªå€¼ï¼Œç„¶åå°†å…¶ç¼“å­˜èµ·æ¥ï¼Œé‚£ä¹ˆå¯ä»¥è¿™æ ·è®¾è®¡ï¼š
- ä¸€ä¸ªé—­åŒ…ç”¨äºè·å–å€¼
- ä¸€ä¸ªå˜é‡ï¼Œç”¨äºå­˜å‚¨è¯¥å€¼
å¯ä»¥ä½¿ç”¨ç»“æ„ä½“æ¥ä»£è¡¨ç¼“å­˜å¯¹è±¡ï¼Œæœ€ç»ˆè®¾è®¡å¦‚ä¸‹ï¼š
```rs
struct Cacher<T>
where
    T: Fn(u32) -> u32,
{
    query: T,
    value: Option<u32>,
}
```
ç‰¹å¾ Fn(u32) -> u32 ä»è¡¨é¢æ¥çœ‹ï¼Œå°±å¯¹é—­åŒ…å½¢å¼è¿›è¡Œäº†æ˜¾è€Œæ˜“è§çš„é™åˆ¶ï¼šè¯¥é—­åŒ…æ‹¥æœ‰ä¸€ä¸ªu32ç±»å‹çš„å‚æ•°ï¼ŒåŒæ—¶è¿”å›ä¸€ä¸ªu32ç±»å‹çš„å€¼ã€‚

æ¥ç€ï¼Œä¸ºç¼“å­˜å®ç°æ–¹æ³•ï¼š
```rs
impl<T> Cacher<T>
where
    T: Fn(u32) -> u32,
{
    fn new(query: T) -> Cacher<T> {
        Cacher {
            query,
            value: None,
        }
    }

    // å…ˆæŸ¥è¯¢ç¼“å­˜å€¼ `self.value`ï¼Œè‹¥ä¸å­˜åœ¨ï¼Œåˆ™è°ƒç”¨ `query` åŠ è½½
    fn value(&mut self, arg: u32) -> u32 {
        match self.value {
            Some(v) => v,
            None => {
                let v = (self.query)(arg);
                self.value = Some(v);
                v
            }
        }
    }
}

```

ä¸Šé¢çš„ç¼“å­˜æœ‰ä¸€ä¸ªå¾ˆå¤§çš„é—®é¢˜ï¼šåªæ”¯æŒ u32 ç±»å‹çš„å€¼ï¼Œè‹¥æˆ‘ä»¬æƒ³è¦ç¼“å­˜ &str ç±»å‹ï¼Œæ˜¾ç„¶å°±è¡Œä¸é€šäº†ï¼Œå› æ­¤éœ€è¦å°† u32 æ›¿æ¢æˆæ³›å‹ Eï¼Œè¯¥ç»ƒä¹ å°±ç•™ç»™è¯»è€…è‡ªå·±å®Œæˆï¼Œå…·ä½“ä»£ç å¯ä»¥å‚è€ƒè¿™é‡Œ

#### æ•è·ä½œç”¨åŸŸä¸­çš„å€¼

åœ¨ä¹‹å‰ä»£ç ä¸­ï¼Œæˆ‘ä»¬ä¸€ç›´åœ¨ç”¨é—­åŒ…çš„åŒ¿åå‡½æ•°ç‰¹æ€§ï¼ˆèµ‹å€¼ç»™å˜é‡ï¼‰ï¼Œç„¶è€Œé—­åŒ…è¿˜æ‹¥æœ‰ä¸€é¡¹å‡½æ•°æ‰€ä¸å…·å¤‡çš„ç‰¹æ€§ï¼šæ•è·ä½œç”¨åŸŸä¸­çš„å€¼ã€‚

```rs
fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}
```

ä¸Šé¢ä»£ç ä¸­ï¼Œx å¹¶ä¸æ˜¯é—­åŒ… equal_to_x çš„å‚æ•°ï¼Œä½†æ˜¯å®ƒä¾ç„¶å¯ä»¥å»ä½¿ç”¨ xï¼Œå› ä¸º equal_to_x åœ¨ x çš„ä½œç”¨åŸŸèŒƒå›´å†…ã€‚

å¯¹äºå‡½æ•°æ¥è¯´ï¼Œå°±ç®—ä½ æŠŠå‡½æ•°å®šä¹‰åœ¨ main å‡½æ•°ä½“ä¸­ï¼Œå®ƒä¹Ÿä¸èƒ½è®¿é—® xï¼š
```rs
fn main() {
    let x = 4;

    fn equal_to_x(z: i32) -> bool {
        z == x
    }

    let y = 4;

    assert!(equal_to_x(y));
}
```

æŠ¥é”™å¦‚ä¸‹ï¼š
```shell
error[E0434]: can't capture dynamic environment in a fn item // åœ¨å‡½æ•°ä¸­æ— æ³•æ•è·åŠ¨æ€çš„ç¯å¢ƒ
 --> src/main.rs:5:14
  |
5 |         z == x
  |              ^
  |
  = help: use the `|| { ... }` closure form instead // ä½¿ç”¨
```

#### ä¸‰ç§ Fn ç‰¹å¾
1. **FnOnce**ï¼Œè¯¥ç±»å‹çš„é—­åŒ…ä¼šæ‹¿èµ°è¢«æ•è·å˜é‡çš„æ‰€æœ‰æƒã€‚Once é¡¾åæ€ä¹‰ï¼Œè¯´æ˜è¯¥é—­åŒ…åªèƒ½è¿è¡Œä¸€æ¬¡ï¼š
```rs
fn fn_once<F>(func: F)
where
    F: FnOnce(usize) -> bool,
{
    println!("{}", func(3));
    println!("{}", func(4));
}

fn main() {
    let x = vec![1, 2, 3];
    fn_once(|z|{z == x.len()})
}
```
2. **FnMut**ï¼Œå®ƒä»¥å¯å˜å€Ÿç”¨çš„æ–¹å¼æ•è·äº†ç¯å¢ƒä¸­çš„å€¼ï¼Œå› æ­¤å¯ä»¥ä¿®æ”¹è¯¥å€¼ï¼š
```rs
fn main() {
    let mut s = String::new();

    let update_string =  |str| s.push_str(str);
    update_string("hello");

    println!("{:?}",s);
}
```
3. **Fn** ç‰¹å¾ï¼Œå®ƒä»¥ä¸å¯å˜å€Ÿç”¨çš„æ–¹å¼æ•è·ç¯å¢ƒä¸­çš„å€¼ è®©æˆ‘ä»¬æŠŠä¸Šé¢çš„ä»£ç ä¸­ exec çš„ F æ³›å‹å‚æ•°ç±»å‹ä¿®æ”¹ä¸º Fn(&'a str)ï¼š
```rs
fn main() {
    let mut s = String::new();

    let update_string =  |str| s.push_str(str);

    exec(update_string);

    println!("{:?}",s);
}

fn exec<'a, F: Fn(&'a str)>(mut f: F)  {
    f("hello")
}
```
#### é—­åŒ…ä½œä¸ºå‡½æ•°è¿”å›å€¼
ä½†æ˜¯å¦‚æœè¦ä½¿ç”¨é—­åŒ…ä½œä¸ºå‡½æ•°è¿”å›å€¼ï¼Œè¯¥å¦‚ä½•åšï¼Ÿ

å…ˆæ¥çœ‹ä¸€æ®µä»£ç ï¼š
```rs
fn factory() -> Fn(i32) -> i32 {
    let num = 5;

    |x| x + num
}

let f = factory();

let answer = f(1);
assert_eq!(6, answer);
```

ä¸Šé¢è¿™æ®µä»£ç çœ‹èµ·æ¥è¿˜æ˜¯è›®æ­£å¸¸çš„ï¼Œç”¨ Fn(i32) -> i32 ç‰¹å¾æ¥ä»£è¡¨ |x| x + numï¼Œéå¸¸åˆç†å˜›ï¼Œè‚¯å®šå¯ä»¥ç¼–è¯‘é€šè¿‡, å¯æƒœç†æƒ³æ€»æ˜¯éš¾ä»¥ç…§è¿›ç°å®ï¼Œç¼–è¯‘å™¨ç»™æˆ‘ä»¬æŠ¥äº†ä¸€å¤§å †é”™è¯¯ï¼Œå…ˆæŒ‘å‡ ä¸ªé‡ç‚¹æ¥çœ‹çœ‹ï¼š
```shell
fn factory<T>() -> Fn(i32) -> i32 {
  |                    ^^^^^^^^^^^^^^ doesn't have a size known at compile-time // è¯¥ç±»å‹åœ¨ç¼–è¯‘å™¨æ²¡æœ‰å›ºå®šçš„å¤§å°
```

Rust è¦æ±‚å‡½æ•°çš„å‚æ•°å’Œè¿”å›ç±»å‹ï¼Œå¿…é¡»æœ‰å›ºå®šçš„å†…å­˜å¤§å°ï¼Œä¾‹å¦‚ i32 å°±æ˜¯ 4 ä¸ªå­—èŠ‚ï¼Œå¼•ç”¨ç±»å‹æ˜¯ 8 ä¸ªå­—èŠ‚ï¼Œæ€»ä¹‹ï¼Œç»å¤§éƒ¨åˆ†ç±»å‹éƒ½æœ‰å›ºå®šçš„å¤§å°ï¼Œä½†æ˜¯ä¸åŒ…æ‹¬ç‰¹å¾ï¼Œå› ä¸ºç‰¹å¾ç±»ä¼¼æ¥å£ï¼Œå¯¹äºç¼–è¯‘å™¨æ¥è¯´ï¼Œæ— æ³•çŸ¥é“å®ƒåé¢è—çš„çœŸå®ç±»å‹æ˜¯ä»€ä¹ˆï¼Œå› ä¸ºä¹Ÿæ— æ³•å¾—çŸ¥å…·ä½“çš„å¤§å°ã€‚

åŒæ ·ï¼Œæˆ‘ä»¬ä¹Ÿæ— æ³•çŸ¥é“é—­åŒ…çš„å…·ä½“ç±»å‹ï¼Œè¯¥æ€ä¹ˆåŠå‘¢ï¼Ÿå†çœ‹çœ‹æŠ¥é”™æç¤ºï¼š
```shell
help: use `impl Fn(i32) -> i32` as the return type, as all return paths are of type `[closure@src/main.rs:11:5: 11:21]`, which implements `Fn(i32) -> i32`
  |
8 | fn factory<T>() -> impl Fn(i32) -> i32 {
```

å—¯ï¼Œç¼–è¯‘å™¨æç¤ºæˆ‘ä»¬åŠ ä¸€ä¸ª impl å…³é”®å­—ï¼Œå“¦ï¼Œè¿™æ ·ä¸€è¯´ï¼Œè¯»è€…å¯èƒ½å°±æƒ³èµ·æ¥äº†ï¼Œimpl Trait å¯ä»¥ç”¨æ¥è¿”å›ä¸€ä¸ªå®ç°äº†æŒ‡å®šç‰¹å¾çš„ç±»å‹ï¼Œé‚£ä¹ˆè¿™é‡Œ impl Fn(i32) -> i32 çš„è¿”å›å€¼å½¢å¼ï¼Œè¯´æ˜æˆ‘ä»¬è¦è¿”å›ä¸€ä¸ªé—­åŒ…ç±»å‹ï¼Œå®ƒå®ç°äº† Fn(i32) -> i32 ç‰¹å¾ã€‚

å®Œç¾è§£å†³ï¼Œä½†æ˜¯ï¼Œåœ¨ç‰¹å¾é‚£ä¸€ç« ï¼Œæˆ‘ä»¬æåˆ°è¿‡ï¼Œimpl Trait çš„è¿”å›æ–¹å¼æœ‰ä¸€ä¸ªéå¸¸å¤§çš„å±€é™ï¼Œå°±æ˜¯ä½ åªèƒ½è¿”å›åŒæ ·çš„ç±»å‹ï¼Œä¾‹å¦‚ï¼š
```rs
fn factory(x:i32) -> impl Fn(i32) -> i32 {

    let num = 5;

    if x > 1{
        move |x| x + num
    } else {
        move |x| x - num
    }
}
```

è¿è¡Œåï¼Œç¼–è¯‘å™¨æŠ¥é”™ï¼š
```shell
error[E0308]: `if` and `else` have incompatible types
  --> src/main.rs:15:9
   |
12 | /     if x > 1{
13 | |         move |x| x + num
   | |         ---------------- expected because of this
14 | |     } else {
15 | |         move |x| x - num
   | |         ^^^^^^^^^^^^^^^^ expected closure, found a different closure
16 | |     }
   | |_____- `if` and `else` have incompatible types
   |
```

å—¯ï¼Œæç¤ºå¾ˆæ¸…æ™°ï¼šif å’Œ else åˆ†æ”¯ä¸­è¿”å›äº†ä¸åŒçš„é—­åŒ…ç±»å‹ï¼Œè¿™å°±å¾ˆå¥‡æ€ªäº†ï¼Œæ˜æ˜è¿™ä¸¤ä¸ªé—­åŒ…é•¿çš„ä¸€æ ·çš„ï¼Œå¥½åœ¨ç»†å¿ƒçš„è¯»è€…åº”è¯¥å›æƒ³èµ·æ¥ï¼Œæœ¬ç« èŠ‚å‰é¢å’±ä»¬æœ‰æåˆ°ï¼šå°±ç®—ç­¾åä¸€æ ·çš„é—­åŒ…ï¼Œç±»å‹ä¹Ÿæ˜¯ä¸åŒçš„ï¼Œå› æ­¤åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå°±æ— æ³•å†ä½¿ç”¨ impl Trait çš„æ–¹å¼å»è¿”å›é—­åŒ…ã€‚

åªéœ€è¦ç”¨ Box çš„æ–¹å¼å³å¯å®ç°ï¼š
```rs
fn factory(x:i32) -> Box<dyn Fn(i32) -> i32> {
    let num = 5;

    if x > 1{
        Box::new(move |x| x + num)
    } else {
        Box::new(move |x| x - num)
    }
}

```

è‡³æ­¤ï¼Œé—­åŒ…ä½œä¸ºå‡½æ•°è¿”å›å€¼å°±å·²å®Œç¾è§£å†³ï¼Œè‹¥ä»¥åä½ å†é‡åˆ°æŠ¥é”™æ—¶ï¼Œä¸€å®šè¦ä»”ç»†é˜…è¯»ç¼–è¯‘å™¨çš„æç¤ºï¼Œå¾ˆå¤šæ—¶å€™ï¼Œè½¬è§’éƒ½èƒ½é‡åˆ°çˆ±ã€‚

### è¿­ä»£å™¨ Iterator
è¿­ä»£å™¨å…è®¸æˆ‘ä»¬è¿­ä»£ä¸€ä¸ªè¿ç»­çš„é›†åˆï¼Œä¾‹å¦‚æ•°ç»„ã€åŠ¨æ€æ•°ç»„ Vecã€HashMap ç­‰ï¼Œåœ¨æ­¤è¿‡ç¨‹ä¸­ï¼Œåªéœ€å…³å¿ƒé›†åˆä¸­çš„å…ƒç´ å¦‚ä½•å¤„ç†ï¼Œè€Œæ— éœ€å…³å¿ƒå¦‚ä½•å¼€å§‹ã€å¦‚ä½•ç»“æŸã€æŒ‰ç…§ä»€ä¹ˆæ ·çš„ç´¢å¼•å»è®¿é—®ç­‰é—®é¢˜ã€‚

#### For å¾ªç¯ä¸è¿­ä»£å™¨
ä»ç”¨é€”æ¥çœ‹ï¼Œè¿­ä»£å™¨è·Ÿ for å¾ªç¯é¢‡ä¸ºç›¸ä¼¼ï¼Œéƒ½æ˜¯å»éå†ä¸€ä¸ªé›†åˆï¼Œä½†æ˜¯å®é™…ä¸Šå®ƒä»¬å­˜åœ¨ä¸å°çš„å·®åˆ«ï¼Œå…¶ä¸­æœ€ä¸»è¦çš„å·®åˆ«å°±æ˜¯ï¼šæ˜¯å¦é€šè¿‡ç´¢å¼•æ¥è®¿é—®é›†åˆã€‚
 Rust ä¸­çš„ forï¼š
```rs
let arr = [1, 2, 3];
for v in arr {
    println!("{}",v);
}

Rustä¸­æ²¡æœ‰ä½¿ç”¨ç´¢å¼•ï¼Œå®ƒæŠŠ arr æ•°ç»„å½“æˆä¸€ä¸ªè¿­ä»£å™¨ï¼Œç›´æ¥å»éå†å…¶ä¸­çš„å…ƒç´ ï¼Œä»å“ªé‡Œå¼€å§‹ï¼Œä»å“ªé‡Œç»“æŸï¼Œéƒ½æ— éœ€æ“å¿ƒã€‚

#### æƒ°æ€§åˆå§‹åŒ–
åœ¨ Rust ä¸­ï¼Œè¿­ä»£å™¨æ˜¯æƒ°æ€§çš„ï¼Œæ„å‘³ç€å¦‚æœä½ ä¸ä½¿ç”¨å®ƒï¼Œé‚£ä¹ˆå®ƒå°†ä¸ä¼šå‘ç”Ÿä»»ä½•äº‹ï¼š
```rs
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println!("{}", val);
}
```
åœ¨ for å¾ªç¯ä¹‹å‰ï¼Œæˆ‘ä»¬åªæ˜¯ç®€å•çš„åˆ›å»ºäº†ä¸€ä¸ªè¿­ä»£å™¨ v1_iterï¼Œæ­¤æ—¶ä¸ä¼šå‘ç”Ÿä»»ä½•è¿­ä»£è¡Œä¸ºï¼Œåªæœ‰åœ¨ for å¾ªç¯å¼€å§‹åï¼Œè¿­ä»£å™¨æ‰ä¼šå¼€å§‹è¿­ä»£å…¶ä¸­çš„å…ƒç´ ï¼Œæœ€åæ‰“å°å‡ºæ¥ã€‚



#### next æ–¹æ³•


for å¾ªç¯é€šè¿‡ä¸åœè°ƒç”¨è¿­ä»£å™¨ä¸Šçš„ next æ–¹æ³•ï¼Œæ¥è·å–è¿­ä»£å™¨ä¸­çš„å…ƒç´ ã€‚

```rs

fn main() {
    let arr = [1, 2, 3];
    let mut arr_iter = arr.into_iter();

    assert_eq!(arr_iter.next(), Some(1));
    assert_eq!(arr_iter.next(), Some(2));
    assert_eq!(arr_iter.next(), Some(3));
    assert_eq!(arr_iter.next(), None);
}
```
æœä¸å…¶ç„¶ï¼Œå°† arr è½¬æ¢æˆè¿­ä»£å™¨åï¼Œé€šè¿‡è°ƒç”¨å…¶ä¸Šçš„ next æ–¹æ³•ï¼Œæˆ‘ä»¬è·å–äº† arr ä¸­çš„å…ƒç´ ï¼Œæœ‰ä¸¤ç‚¹éœ€è¦æ³¨æ„ï¼š
next æ–¹æ³•è¿”å›çš„æ˜¯ **Option**ç±»å‹ï¼Œå½“æœ‰å€¼æ—¶è¿”å› Some(i32)ï¼Œæ— å€¼æ—¶è¿”å› None
éå†æ˜¯æŒ‰ç…§è¿­ä»£å™¨ä¸­å…ƒç´ çš„æ’åˆ—é¡ºåºä¾æ¬¡è¿›è¡Œçš„ï¼Œå› æ­¤æˆ‘ä»¬ä¸¥æ ¼æŒ‰ç…§æ•°ç»„ä¸­å…ƒç´ çš„é¡ºåºå–å‡ºäº† Some(1)ï¼ŒSome(2)ï¼ŒSome(3)



#### æ¶ˆè´¹è€…ä¸é€‚é…å™¨
æ¶ˆè´¹è€…æ˜¯è¿­ä»£å™¨ä¸Šçš„æ–¹æ³•ï¼Œå®ƒä¼šæ¶ˆè´¹æ‰è¿­ä»£å™¨ä¸­çš„å…ƒç´ ï¼Œç„¶åè¿”å›å…¶ç±»å‹çš„å€¼ï¼Œè¿™äº›æ¶ˆè´¹è€…éƒ½æœ‰ä¸€ä¸ªå…±åŒçš„ç‰¹ç‚¹ï¼šåœ¨å®ƒä»¬çš„å®šä¹‰ä¸­ï¼Œéƒ½ä¾èµ– next æ–¹æ³•æ¥æ¶ˆè´¹å…ƒç´ .

##### æ¶ˆè´¹è€…é€‚é…å™¨
åªè¦è¿­ä»£å™¨ä¸Šçš„æŸä¸ªæ–¹æ³• A åœ¨å…¶å†…éƒ¨è°ƒç”¨äº† next æ–¹æ³•ï¼Œé‚£ä¹ˆ A å°±è¢«ç§°ä¸ºæ¶ˆè´¹æ€§é€‚é…å™¨ï¼šå› ä¸º next æ–¹æ³•ä¼šæ¶ˆè€—æ‰è¿­ä»£å™¨ä¸Šçš„å…ƒç´ ï¼Œæ‰€ä»¥æ–¹æ³• A çš„è°ƒç”¨ä¹Ÿä¼šæ¶ˆè€—æ‰è¿­ä»£å™¨ä¸Šçš„å…ƒç´ ã€‚

å…¶ä¸­ä¸€ä¸ªä¾‹å­æ˜¯ sum æ–¹æ³•ï¼Œå®ƒä¼šæ‹¿èµ°è¿­ä»£å™¨çš„æ‰€æœ‰æƒï¼Œç„¶åé€šè¿‡ä¸æ–­è°ƒç”¨ next æ–¹æ³•å¯¹é‡Œé¢çš„å…ƒç´ è¿›è¡Œæ±‚å’Œï¼š
```rs
fn main() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    let total: i32 = v1_iter.sum();

    assert_eq!(total, 6);

    // v1_iter æ˜¯å€Ÿç”¨äº† v1ï¼Œå› æ­¤ v1 å¯ä»¥ç…§å¸¸ä½¿ç”¨
    println!("{:?}",v1);

    // ä»¥ä¸‹ä»£ç ä¼šæŠ¥é”™ï¼Œå› ä¸º `sum` æ‹¿åˆ°äº†è¿­ä»£å™¨ `v1_iter` çš„æ‰€æœ‰æƒ
    // println!("{:?}",v1_iter);
}
```


##### è¿­ä»£å™¨é€‚é…å™¨
æ—¢ç„¶æ¶ˆè´¹è€…é€‚é…å™¨æ˜¯æ¶ˆè´¹æ‰è¿­ä»£å™¨ï¼Œç„¶åè¿”å›ä¸€ä¸ªå€¼ã€‚é‚£ä¹ˆè¿­ä»£å™¨é€‚é…å™¨ï¼Œé¡¾åæ€ä¹‰ï¼Œä¼šè¿”å›ä¸€ä¸ªæ–°çš„è¿­ä»£å™¨ï¼Œè¿™æ˜¯å®ç°é“¾å¼æ–¹æ³•è°ƒç”¨çš„å…³é”®ï¼šv.iter().map().filter()...ã€‚

ä¸æ¶ˆè´¹è€…é€‚é…å™¨ä¸åŒï¼Œè¿­ä»£å™¨é€‚é…å™¨æ˜¯æƒ°æ€§çš„ï¼Œæ„å‘³ç€ä½ éœ€è¦ä¸€ä¸ªæ¶ˆè´¹è€…é€‚é…å™¨æ¥æ”¶å°¾ï¼Œæœ€ç»ˆå°†è¿­ä»£å™¨è½¬æ¢æˆä¸€ä¸ªå…·ä½“çš„å€¼ï¼š
```rs
let v1: Vec<i32> = vec![1, 2, 3];

v1.iter().map(|x| x + 1);
```
è¿è¡Œåè¾“å‡º:
```rs
warning: unused `Map` that must be used
 --> src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: iterators are lazy and do nothing unless consumed // è¿­ä»£å™¨ map æ˜¯æƒ°æ€§çš„ï¼Œè¿™é‡Œä¸äº§ç”Ÿä»»ä½•æ•ˆæœ
  ```
å¦‚ä¸Šè¿°ä¸­æ–‡æ³¨é‡Šæ‰€è¯´ï¼Œè¿™é‡Œçš„ map æ–¹æ³•æ˜¯ä¸€ä¸ªè¿­ä»£è€…é€‚é…å™¨ï¼Œå®ƒæ˜¯æƒ°æ€§çš„ï¼Œä¸äº§ç”Ÿä»»ä½•è¡Œä¸ºï¼Œå› æ­¤æˆ‘ä»¬è¿˜éœ€è¦ä¸€ä¸ªæ¶ˆè´¹è€…é€‚é…å™¨è¿›è¡Œæ”¶å°¾ï¼š
```rs
let v1: Vec<i32> = vec![1, 2, 3];

let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);
```
##### collect
ä½¿ç”¨äº† collect æ–¹æ³•ï¼Œè¯¥æ–¹æ³•å°±æ˜¯ä¸€ä¸ªæ¶ˆè´¹è€…é€‚é…å™¨ï¼Œä½¿ç”¨å®ƒå¯ä»¥å°†ä¸€ä¸ªè¿­ä»£å™¨ä¸­çš„å…ƒç´ æ”¶é›†åˆ°æŒ‡å®šç±»å‹ä¸­ï¼Œè¿™é‡Œæˆ‘ä»¬ä¸º v2 æ ‡æ³¨äº† Vec<_> ç±»å‹ï¼Œå°±æ˜¯ä¸ºäº†å‘Šè¯‰ collectï¼šè¯·æŠŠè¿­ä»£å™¨ä¸­çš„å…ƒç´ æ¶ˆè´¹æ‰ï¼Œç„¶åæŠŠå€¼æ”¶é›†æˆ Vec<_> ç±»å‹ï¼Œè‡³äºä¸ºä½•ä½¿ç”¨ _ï¼Œå› ä¸ºç¼–è¯‘å™¨ä¼šå¸®æˆ‘ä»¬è‡ªåŠ¨æ¨å¯¼ã€‚

æ˜¯å› ä¸ºè¯¥æ–¹æ³•å…¶å®å¾ˆå¼ºå¤§ï¼Œå¯ä»¥æ”¶é›†æˆå¤šç§ä¸åŒçš„é›†åˆç±»å‹ï¼ŒVec<T> ä»…ä»…æ˜¯å…¶ä¸­ä¹‹ä¸€ï¼Œå› æ­¤æˆ‘ä»¬å¿…é¡»æ˜¾å¼çš„å‘Šè¯‰ç¼–è¯‘å™¨æˆ‘ä»¬æƒ³è¦æ”¶é›†æˆçš„é›†åˆç±»å‹ã€‚

è¿˜æœ‰ä¸€ç‚¹å€¼å¾—æ³¨æ„ï¼Œmap ä¼šå¯¹è¿­ä»£å™¨ä¸­çš„æ¯ä¸€ä¸ªå€¼è¿›è¡Œä¸€ç³»åˆ—æ“ä½œï¼Œç„¶åæŠŠè¯¥å€¼è½¬æ¢æˆå¦å¤–ä¸€ä¸ªæ–°å€¼ï¼Œè¯¥æ“ä½œæ˜¯é€šè¿‡é—­åŒ… |x| x + 1 æ¥å®Œæˆï¼šæœ€ç»ˆè¿­ä»£å™¨ä¸­çš„æ¯ä¸ªå€¼éƒ½å¢åŠ äº† 1ï¼Œä» [1, 2, 3] å˜ä¸º [2, 3, 4]ã€‚

å†æ¥çœ‹çœ‹å¦‚ä½•ä½¿ç”¨ collect æ”¶é›†æˆ HashMap é›†åˆï¼š
```rs
use std::collections::HashMap;
fn main() {
    let names = ["sunface", "sunfei"];
    let ages = [18, 18];
    let folks: HashMap<_, _> = names.into_iter().zip(ages.into_iter()).collect();

    println!("{:?}",folks);
}
```

zip æ˜¯ä¸€ä¸ªè¿­ä»£å™¨é€‚é…å™¨ï¼Œå®ƒçš„ä½œç”¨å°±æ˜¯å°†ä¸¤ä¸ªè¿­ä»£å™¨çš„å†…å®¹å‹ç¼©åˆ°ä¸€èµ·ï¼Œå½¢æˆ Iterator<Item=(ValueFromA, ValueFromB)> è¿™æ ·çš„æ–°çš„è¿­ä»£å™¨ï¼Œåœ¨æ­¤å¤„å°±æ˜¯å½¢å¦‚ [(name1, age1), (name2, age2)] çš„è¿­ä»£å™¨ã€‚

ç„¶åå†é€šè¿‡ collect å°†æ–°è¿­ä»£å™¨ä¸­(K, V) å½¢å¼çš„å€¼æ”¶é›†æˆ HashMap<K, V>ï¼ŒåŒæ ·çš„ï¼Œè¿™é‡Œå¿…é¡»æ˜¾å¼å£°æ˜ç±»å‹ï¼Œç„¶å HashMap å†…éƒ¨çš„ KV ç±»å‹å¯ä»¥äº¤ç»™ç¼–è¯‘å™¨å»æ¨å¯¼ï¼Œæœ€ç»ˆç¼–è¯‘å™¨ä¼šæ¨å¯¼å‡º HashMap<&str, i32>ï¼Œå®Œå…¨æ­£ç¡®ï¼

##### é—­åŒ…ä½œä¸ºé€‚é…å™¨å‚æ•°
ä¹‹å‰çš„ map æ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨é—­åŒ…æ¥ä½œä¸ºè¿­ä»£å™¨é€‚é…å™¨çš„å‚æ•°ï¼Œå®ƒæœ€å¤§çš„å¥½å¤„ä¸ä»…åœ¨äºå¯ä»¥å°±åœ°å®ç°è¿­ä»£å™¨ä¸­å…ƒç´ çš„å¤„ç†ï¼Œè¿˜åœ¨äºå¯ä»¥æ•è·ç¯å¢ƒå€¼ï¼š
```rs
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}
```
filter æ˜¯è¿­ä»£å™¨é€‚é…å™¨ï¼Œç”¨äºå¯¹è¿­ä»£å™¨ä¸­çš„æ¯ä¸ªå€¼è¿›è¡Œè¿‡æ»¤ã€‚ å®ƒä½¿ç”¨é—­åŒ…ä½œä¸ºå‚æ•°ï¼Œè¯¥é—­åŒ…çš„å‚æ•° s æ˜¯æ¥è‡ªè¿­ä»£å™¨ä¸­çš„å€¼ï¼Œç„¶åä½¿ç”¨ s è·Ÿå¤–éƒ¨ç¯å¢ƒä¸­çš„ shoe_size è¿›è¡Œæ¯”è¾ƒï¼Œè‹¥ç›¸ç­‰ï¼Œåˆ™åœ¨è¿­ä»£å™¨ä¸­ä¿ç•™ s å€¼ï¼Œè‹¥ä¸ç›¸ç­‰ï¼Œåˆ™ä»è¿­ä»£å™¨ä¸­å‰”é™¤ s å€¼ï¼Œæœ€ç»ˆé€šè¿‡ collect æ”¶é›†ä¸º Vec<Shoe> ç±»å‹ã€‚

#### å®ç° Iterator ç‰¹å¾
ä¹‹å‰çš„å†…å®¹æˆ‘ä»¬ä¸€ç›´åŸºäºæ•°ç»„æ¥åˆ›å»ºè¿­ä»£å™¨ï¼Œå®é™…ä¸Šï¼Œä¸ä»…ä»…æ˜¯æ•°ç»„ï¼ŒåŸºäºå…¶å®ƒé›†åˆç±»å‹ä¸€æ ·å¯ä»¥åˆ›å»ºè¿­ä»£å™¨ï¼Œä¾‹å¦‚ HashMapã€‚ ä½ ä¹Ÿå¯ä»¥åˆ›å»ºè‡ªå·±çš„è¿­ä»£å™¨ â€”â€” åªè¦ä¸ºè‡ªå®šä¹‰ç±»å‹å®ç° Iterator ç‰¹å¾å³å¯ã€‚

é¦–å…ˆï¼Œåˆ›å»ºä¸€ä¸ªè®¡æ•°å™¨ï¼š
```rs
struct Counter {
    count: u32,
}

impl Counter {
    fn new() -> Counter {
        Counter { count: 0 }
    }
}
```
æˆ‘ä»¬ä¸ºè®¡æ•°å™¨ Counter å®ç°äº†ä¸€ä¸ªå…³è”å‡½æ•° newï¼Œç”¨äºåˆ›å»ºæ–°çš„è®¡æ•°å™¨å®ä¾‹ã€‚ä¸‹é¢æˆ‘ä»¬ç»§ç»­ä¸ºè®¡æ•°å™¨å®ç° Iterator ç‰¹å¾ï¼š
```rs
impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        if self.count < 5 {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}
```
é¦–å…ˆï¼Œå°†è¯¥ç‰¹å¾çš„å…³è”ç±»å‹è®¾ç½®ä¸º u32ï¼Œç”±äºæˆ‘ä»¬çš„è®¡æ•°å™¨ä¿å­˜çš„ count å­—æ®µå°±æ˜¯ u32 ç±»å‹ï¼Œ å› æ­¤åœ¨ next æ–¹æ³•ä¸­ï¼Œæœ€åè¿”å›çš„æ˜¯å®é™…ä¸Šæ˜¯ Option<u32> ç±»å‹ã€‚

æ¯æ¬¡è°ƒç”¨ next æ–¹æ³•ï¼Œéƒ½ä¼šè®©è®¡æ•°å™¨çš„å€¼åŠ ä¸€ï¼Œç„¶åè¿”å›æœ€æ–°çš„è®¡æ•°å€¼ï¼Œä¸€æ—¦è®¡æ•°å¤§äº 5ï¼Œå°±è¿”å› Noneã€‚

æœ€åï¼Œä½¿ç”¨æˆ‘ä»¬æ–°å»ºçš„ Counter è¿›è¡Œè¿­ä»£ï¼š
```rs
 let mut counter = Counter::new();

assert_eq!(counter.next(), Some(1));
assert_eq!(counter.next(), Some(2));
assert_eq!(counter.next(), Some(3));
assert_eq!(counter.next(), Some(4));
assert_eq!(counter.next(), Some(5));
assert_eq!(counter.next(), None);
```
###### å®ç° Iterator ç‰¹å¾çš„å…¶å®ƒæ–¹æ³•
å¯ä»¥çœ‹å‡ºï¼Œå®ç°è‡ªå·±çš„è¿­ä»£å™¨éå¸¸ç®€å•ï¼Œä½†æ˜¯ Iterator ç‰¹å¾ä¸­ï¼Œä¸ä»…ä»…æ˜¯åªæœ‰ next ä¸€ä¸ªæ–¹æ³•ï¼Œé‚£ä¸ºä»€ä¹ˆæˆ‘ä»¬åªéœ€è¦å®ç°å®ƒå‘¢ï¼Ÿå› ä¸ºå…¶å®ƒæ–¹æ³•éƒ½å…·æœ‰é»˜è®¤å®ç°ï¼Œæ‰€ä»¥æ— éœ€åƒ next è¿™æ ·æ‰‹åŠ¨å»å®ç°ï¼Œè€Œä¸”è¿™äº›é»˜è®¤å®ç°çš„æ–¹æ³•å…¶å®éƒ½æ˜¯åŸºäº next æ–¹æ³•å®ç°çš„ã€‚

ä¸‹é¢çš„ä»£ç æ¼”ç¤ºäº†éƒ¨åˆ†æ–¹æ³•çš„ä½¿ç”¨ï¼š
```rs
let sum: u32 = Counter::new()
    .zip(Counter::new().skip(1))
    .map(|(a, b)| a * b)
    .filter(|x| x % 3 == 0)
    .sum();
assert_eq!(18, sum);
```
å…¶ä¸­ zipï¼Œmapï¼Œfilter æ˜¯è¿­ä»£å™¨é€‚é…å™¨ï¼š

- zip æŠŠä¸¤ä¸ªè¿­ä»£å™¨åˆå¹¶æˆä¸€ä¸ªè¿­ä»£å™¨ï¼Œæ–°è¿­ä»£å™¨ä¸­ï¼Œæ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªå…ƒç»„ï¼Œç”±ä¹‹å‰ä¸¤ä¸ªè¿­ä»£å™¨çš„å…ƒç´ ç»„æˆã€‚ä¾‹å¦‚å°†å½¢å¦‚ [1, 2, 3, 4, 5] å’Œ [2, 3, 4, 5] çš„è¿­ä»£å™¨åˆå¹¶åï¼Œæ–°çš„è¿­ä»£å™¨å½¢å¦‚ [(1, 2),(2, 3),(3, 4),(4, 5)]
- map æ˜¯å°†è¿­ä»£å™¨ä¸­çš„å€¼ç»è¿‡æ˜ å°„åï¼Œè½¬æ¢æˆæ–°çš„å€¼[2, 6, 12, 20]
- filter å¯¹è¿­ä»£å™¨ä¸­çš„å…ƒç´ è¿›è¡Œè¿‡æ»¤ï¼Œè‹¥é—­åŒ…è¿”å› true åˆ™ä¿ç•™å…ƒç´ [6, 12]ï¼Œåä¹‹å‰”é™¤
è€Œ sum æ˜¯æ¶ˆè´¹è€…é€‚é…å™¨ï¼Œå¯¹è¿­ä»£å™¨ä¸­çš„æ‰€æœ‰å…ƒç´ æ±‚å’Œï¼Œæœ€ç»ˆè¿”å›ä¸€ä¸ª u32 å€¼ 18ã€‚

#### enumerate
é’ˆå¯¹ for å¾ªç¯ï¼Œæˆ‘ä»¬æä¾›äº†ä¸€ç§æ–¹æ³•å¯ä»¥è·å–è¿­ä»£æ—¶çš„ç´¢å¼•ï¼š
```rs
let v = vec![1u64, 2, 3, 4, 5, 6];
for (i,v) in v.iter().enumerate() {
    println!("ç¬¬{}ä¸ªå€¼æ˜¯{}",i,v)
}
```
)ã€‚

å› ä¸º enumerate æ˜¯è¿­ä»£å™¨é€‚é…å™¨ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å¯¹å®ƒè¿”å›çš„è¿­ä»£å™¨è°ƒç”¨å…¶å®ƒ Iterator ç‰¹å¾æ–¹æ³•ï¼š
```rs
let v = vec![1u64, 2, 3, 4, 5, 6];
let val = v.iter()
    .enumerate()
    // æ¯ä¸¤ä¸ªå…ƒç´ å‰”é™¤ä¸€ä¸ª
    // [1, 3, 5]
    .filter(|&(idx, _)| idx % 2 == 0)
    .map(|(idx, val)| val)
    // ç´¯åŠ  1+3+5 = 9
    .fold(0u64, |sum, acm| sum + acm);

println!("{}", val);
```


## æ·±å…¥ç±»å‹
### ç±»å‹è½¬æ¢
```rs
let mut values: [i32; 2] = [1, 2];
let p1: *mut i32 = values.as_mut_ptr();
let first_address = p1 as usize; // å°†p1å†…å­˜åœ°å€è½¬æ¢ä¸ºä¸€ä¸ªæ•´æ•°
let second_address = first_address + 4; // 4 == std::mem::size_of::<i32>()ï¼Œi32ç±»å‹å ç”¨4ä¸ªå­—èŠ‚ï¼Œå› æ­¤å°†å†…å­˜åœ°å€ + 4
let p2 = second_address as *mut i32; // è®¿é—®è¯¥åœ°å€æŒ‡å‘çš„ä¸‹ä¸€ä¸ªæ•´æ•°p2
unsafe {
    *p2 += 1;
}
assert_eq!(values[1], 3);

```
#### TryInto è½¬æ¢
```rs
fn main() {
    let b: i16 = 1500;

    let b_: u8 = match b.try_into() {
        Ok(b1) => b1,
        Err(e) => {
            println!("{:?}", e.to_string());
            0
        }
    };
}
```
####  é€šç”¨ç±»å‹è½¬æ¢
```rs
struct Foo {
    x: u32,
    y: u16,
}

struct Bar {
    a: u32,
    b: u16,
}

fn reinterpret(foo: Foo) -> Bar {
    let Foo { x, y } = foo;
    Bar { a: x, b: y }
}
```
### newtypeå’Œç±»å‹åç§°

#### ç±»å‹åˆ«å(Type Alias)
type Meters = u32;

!æ°¸ä¸è¿”å›ç±»å‹
### Sized å’Œä¸å®šé•¿ç±»å‹ DST
### æ•´æ•°è½¬æ¢ä¸ºæšä¸¾

## æ™ºèƒ½æŒ‡é’ˆ
### Box<T> å †å¯¹è±¡åˆ†é…
å› ä¸º Box<T> å…è®¸ä½ å°†ä¸€ä¸ªå€¼åˆ†é…åˆ°å †ä¸Šï¼Œç„¶ååœ¨æ ˆä¸Šä¿ç•™ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆæŒ‡å‘å †ä¸Šçš„æ•°æ®ã€‚

å½“æ ˆä¸Šæ•°æ®è½¬ç§»æ‰€æœ‰æƒæ—¶ï¼Œå®é™…ä¸Šæ˜¯æŠŠæ•°æ®æ‹·è´äº†ä¸€ä»½ï¼Œæœ€ç»ˆæ–°æ—§å˜é‡å„è‡ªæ‹¥æœ‰ä¸åŒçš„æ•°æ®ï¼Œå› æ­¤æ‰€æœ‰æƒå¹¶æœªè½¬ç§»ã€‚
```rs
enum List {
    Cons(i32, Box<List>),
    Nil,
}
```

Box ä¸­è¿˜æä¾›äº†ä¸€ä¸ªéå¸¸æœ‰ç”¨çš„å…³è”å‡½æ•°ï¼šBox::leakï¼Œå®ƒå¯ä»¥æ¶ˆè´¹æ‰ Box å¹¶ä¸”å¼ºåˆ¶ç›®æ ‡å€¼ä»å†…å­˜ä¸­æ³„æ¼ï¼Œè¯»è€…å¯èƒ½ä¼šè§‰å¾—ï¼Œè¿™æœ‰å•¥ç”¨å•Šï¼Ÿ
```rs
fn main() {
   let s = gen_static_str();
   println!("{}", s);
}

fn gen_static_str() -> &'static str{
    let mut s = String::new();
    s.push_str("hello, world");

    Box::leak(s.into_boxed_str())
}
```
### Deref è§£å¼•ç”¨
#### ä¸ºæ™ºèƒ½æŒ‡é’ˆå®ç° Deref ç‰¹å¾
```rs
use std::ops::Deref;

impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
```

### Drop é‡Šæ”¾èµ„æº

### Rc ä¸ Arc
å¼•ç”¨è®¡æ•°(reference counting)ï¼Œé¡¾åæ€ä¹‰ï¼Œé€šè¿‡è®°å½•ä¸€ä¸ªæ•°æ®è¢«å¼•ç”¨çš„æ¬¡æ•°æ¥ç¡®å®šè¯¥æ•°æ®æ˜¯å¦æ­£åœ¨è¢«ä½¿ç”¨ã€‚å½“å¼•ç”¨æ¬¡æ•°å½’é›¶æ—¶ï¼Œå°±ä»£è¡¨è¯¥æ•°æ®ä¸å†è¢«ä½¿ç”¨ï¼Œå› æ­¤å¯ä»¥è¢«æ¸…ç†é‡Šæ”¾ã€‚

Arc æ˜¯ Atomic Rc çš„ç¼©å†™ï¼Œé¡¾åæ€ä¹‰ï¼šåŸå­åŒ–çš„ Rc<T> æ™ºèƒ½æŒ‡é’ˆã€‚åŸå­åŒ–æ˜¯ä¸€ç§å¹¶å‘åŸè¯­ï¼Œæˆ‘ä»¬åœ¨åç»­ç« èŠ‚ä¼šè¿›è¡Œæ·±å…¥è®²è§£ï¼Œè¿™é‡Œä½ åªè¦çŸ¥é“å®ƒèƒ½ä¿è¯æˆ‘ä»¬çš„æ•°æ®èƒ½å¤Ÿå®‰å…¨çš„åœ¨çº¿ç¨‹é—´å…±äº«å³å¯ã€‚

### Cell å’Œ RefCell
Cell å’Œ RefCell åœ¨åŠŸèƒ½ä¸Šæ²¡æœ‰åŒºåˆ«ï¼ŒåŒºåˆ«åœ¨äº Cell<T> é€‚ç”¨äº T å®ç° Copy çš„æƒ…å†µ

#### RefCell

|Rust è§„åˆ™|	æ™ºèƒ½æŒ‡é’ˆå¸¦æ¥çš„é¢å¤–è§„åˆ™|
|-------------|------------------|

|ä¸€ä¸ªæ•°æ®åªæœ‰ä¸€ä¸ªæ‰€æœ‰è€…|	Rc/Arcè®©ä¸€ä¸ªæ•°æ®å¯ä»¥æ‹¥æœ‰å¤šä¸ªæ‰€æœ‰è€…|
è¦ä¹ˆå¤šä¸ªä¸å¯å˜å€Ÿç”¨ï¼Œè¦ä¹ˆä¸€ä¸ªå¯å˜å€Ÿç”¨|	RefCellå®ç°ç¼–è¯‘æœŸå¯å˜ã€ä¸å¯å˜å¼•ç”¨å…±å­˜|
|è¿èƒŒè§„åˆ™å¯¼è‡´ç¼–è¯‘é”™è¯¯	|è¿èƒŒè§„åˆ™å¯¼è‡´è¿è¡Œæ—¶panic|

## å¾ªç¯å¼•ç”¨ä¸è‡ªå¼•ç”¨

### Weak
|Weak|	Rc|
|---------------|-----------------------|
|ä¸è®¡æ•°	|å¼•ç”¨è®¡æ•°|
|ä¸æ‹¥æœ‰æ‰€æœ‰æƒ	|æ‹¥æœ‰å€¼çš„æ‰€æœ‰æƒ|
|ä¸é˜»æ­¢å€¼è¢«é‡Šæ”¾(drop)|	æ‰€æœ‰æƒè®¡æ•°å½’é›¶ï¼Œæ‰èƒ½ drop|
|å¼•ç”¨çš„å€¼å­˜åœ¨è¿”å› Someï¼Œä¸å­˜åœ¨è¿”å› None|	å¼•ç”¨çš„å€¼å¿…å®šå­˜åœ¨|
|é€šè¿‡ upgrade å–åˆ° Option<Rc<T>>ï¼Œç„¶åå†å–å€¼|	é€šè¿‡ Deref è‡ªåŠ¨è§£å¼•ç”¨ï¼Œå–å€¼æ— éœ€ä»»ä½•æ“ä½œ|

## å¤šçº¿ç¨‹å¹¶å‘ç¼–ç¨‹
### ä½¿ç”¨å¤šçº¿ç¨‹
```rs
use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
}
```
æœ‰å‡ ç‚¹å€¼å¾—æ³¨æ„ï¼š

- çº¿ç¨‹å†…éƒ¨çš„ä»£ç ä½¿ç”¨é—­åŒ…æ¥æ‰§è¡Œ
- main çº¿ç¨‹ä¸€æ—¦ç»“æŸï¼Œç¨‹åºå°±ç«‹åˆ»ç»“æŸï¼Œå› æ­¤éœ€è¦ä¿æŒå®ƒçš„å­˜æ´»ï¼Œç›´åˆ°å…¶å®ƒå­çº¿ç¨‹å®Œæˆè‡ªå·±çš„ä»»åŠ¡
- thread::sleep ä¼šè®©å½“å‰çº¿ç¨‹ä¼‘çœ æŒ‡å®šçš„æ—¶é—´ï¼Œéšåå…¶å®ƒçº¿ç¨‹ä¼šè¢«è°ƒåº¦è¿è¡Œï¼Œå› æ­¤å°±ç®—ä½ çš„ç”µè„‘åªæœ‰ä¸€ä¸ª CPU æ ¸å¿ƒï¼Œè¯¥ç¨‹åºä¹Ÿä¼šè¡¨ç°çš„å¦‚åŒå¤š CPU æ ¸å¿ƒä¸€èˆ¬ï¼Œè¿™å°±æ˜¯å¹¶å‘ï¼
#### åœ¨çº¿ç¨‹é—­åŒ…ä¸­ä½¿ç”¨ move
 move å…³é”®å­—åœ¨é—­åŒ…ä¸­çš„ä½¿ç”¨å¯ä»¥è®©è¯¥é—­åŒ…æ‹¿èµ°ç¯å¢ƒä¸­æŸä¸ªå€¼çš„æ‰€æœ‰æƒï¼ŒåŒæ ·åœ°ï¼Œä½ å¯ä»¥ä½¿ç”¨ move æ¥å°†æ‰€æœ‰æƒä»ä¸€ä¸ªçº¿ç¨‹è½¬ç§»åˆ°å¦å¤–ä¸€ä¸ªçº¿ç¨‹ã€‚
```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();

    // ä¸‹é¢ä»£ç ä¼šæŠ¥é”™borrow of moved value: `v`
    // println!("{:?}",v);
}
```
#### çº¿ç¨‹å±€éƒ¨å˜é‡(Thread Local Variable)
##### æ ‡å‡†åº“
```rust
use std::cell::RefCell;
use std::thread;

thread_local!(static FOO: RefCell<u32> = RefCell::new(1));

FOO.with(|f| {
    assert_eq!(*f.borrow(), 1);
    *f.borrow_mut() = 2;
});

// æ¯ä¸ªçº¿ç¨‹å¼€å§‹æ—¶éƒ½ä¼šæ‹¿åˆ°çº¿ç¨‹å±€éƒ¨å˜é‡çš„FOOçš„åˆå§‹å€¼
let t = thread::spawn(move|| {
    FOO.with(|f| {
        assert_eq!(*f.borrow(), 1);
        *f.borrow_mut() = 3;
    });
});

// ç­‰å¾…çº¿ç¨‹å®Œæˆ
t.join().unwrap();

// å°½ç®¡å­çº¿ç¨‹ä¸­ä¿®æ”¹ä¸ºäº†3ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œä¾ç„¶æ‹¥æœ‰mainçº¿ç¨‹ä¸­çš„å±€éƒ¨å€¼ï¼š2
FOO.with(|f| {
    assert_eq!(*f.borrow(), 2);
});

```
##### ç¬¬ä¸‰æ–¹åº“
```rust
use thread_local::ThreadLocal;
use std::sync::Arc;
use std::cell::Cell;
use std::thread;

let tls = Arc::new(ThreadLocal::new());

// åˆ›å»ºå¤šä¸ªçº¿ç¨‹
for _ in 0..5 {
    let tls2 = tls.clone();
    thread::spawn(move || {
        // å°†è®¡æ•°å™¨åŠ 1
        let cell = tls2.get_or(|| Cell::new(0));
        cell.set(cell.get() + 1);
    }).join().unwrap();
}

// ä¸€æ—¦æ‰€æœ‰å­çº¿ç¨‹ç»“æŸï¼Œæ”¶é›†å®ƒä»¬çš„çº¿ç¨‹å±€éƒ¨å˜é‡ä¸­çš„è®¡æ•°å™¨å€¼ï¼Œç„¶åè¿›è¡Œæ±‚å’Œ
let tls = Arc::try_unwrap(tls).unwrap();
let total = tls.into_iter().fold(0, |x, y| x + y.get());

// å’Œä¸º5
assert_eq!(total, 5);

```
### çº¿ç¨‹é—´çš„æ¶ˆæ¯ä¼ é€’
```rs
use std::sync::mpsc;
use std::thread;

fn main() {
    // åˆ›å»ºä¸€ä¸ªæ¶ˆæ¯é€šé“, è¿”å›ä¸€ä¸ªå…ƒç»„ï¼š(å‘é€è€…ï¼Œæ¥æ”¶è€…)
    let (tx, rx) = mpsc::channel();

    // åˆ›å»ºçº¿ç¨‹ï¼Œå¹¶å‘é€æ¶ˆæ¯
    thread::spawn(move || {
        // å‘é€ä¸€ä¸ªæ•°å­—1, sendæ–¹æ³•è¿”å›Result<T,E>ï¼Œé€šè¿‡unwrapè¿›è¡Œå¿«é€Ÿé”™è¯¯å¤„ç†
        tx.send(1).unwrap();

        // ä¸‹é¢ä»£ç å°†æŠ¥é”™ï¼Œå› ä¸ºç¼–è¯‘å™¨è‡ªåŠ¨æ¨å¯¼å‡ºé€šé“ä¼ é€’çš„å€¼æ˜¯i32ç±»å‹ï¼Œé‚£ä¹ˆOption<i32>ç±»å‹å°†äº§ç”Ÿä¸åŒ¹é…é”™è¯¯
        // tx.send(Some(1)).unwrap()
    });

    // åœ¨ä¸»çº¿ç¨‹ä¸­æ¥æ”¶å­çº¿ç¨‹å‘é€çš„æ¶ˆæ¯å¹¶è¾“å‡º
    println!("receive {}", rx.recv().unwrap());
}
```

- è‹¥å€¼çš„ç±»å‹å®ç°äº†Copyç‰¹å¾ï¼Œåˆ™ç›´æ¥å¤åˆ¶ä¸€ä»½è¯¥å€¼ï¼Œç„¶åä¼ è¾“è¿‡å»ï¼Œä¾‹å¦‚ä¹‹å‰çš„i32ç±»å‹
- è‹¥å€¼æ²¡æœ‰å®ç°Copyï¼Œåˆ™å®ƒçš„æ‰€æœ‰æƒä¼šè¢«è½¬ç§»ç»™æ¥æ”¶ç«¯ï¼Œåœ¨å‘é€ç«¯ç»§ç»­ä½¿ç”¨è¯¥å€¼å°†æŠ¥é”™
#### ä½¿ç”¨å¤šå‘é€è€…
```rs
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();
    let tx1 = tx.clone();
    thread::spawn(move || {
        tx.send(String::from("hi from raw tx")).unwrap();
    });

    thread::spawn(move || {
        tx1.send(String::from("hi from cloned tx")).unwrap();
    });

    for received in rx {
        println!("Got: {}", received);
    }
}
```
ä»¥ä¸Šä»£ç å¹¶ä¸å¤æ‚ï¼Œä½†ä»æœ‰å‡ ç‚¹éœ€è¦æ³¨æ„ï¼š

- tx,rxå¯¹åº”å‘é€è€…å’Œæ¥æ”¶è€…ï¼Œå®ƒä»¬çš„ç±»å‹ç”±ç¼–è¯‘å™¨è‡ªåŠ¨æ¨å¯¼: tx.send(1)å‘é€äº†æ•´æ•°ï¼Œå› æ­¤å®ƒä»¬åˆ†åˆ«æ˜¯mpsc::Sender<i32>å’Œmpsc::Receiver<i32>ç±»å‹ï¼Œéœ€è¦æ³¨æ„ï¼Œç”±äºå†…éƒ¨æ˜¯æ³›å‹å®ç°ï¼Œä¸€æ—¦ç±»å‹è¢«æ¨å¯¼ç¡®å®šï¼Œè¯¥é€šé“å°±åªèƒ½ä¼ é€’å¯¹åº”ç±»å‹çš„å€¼, ä¾‹å¦‚æ­¤ä¾‹ä¸­éi32ç±»å‹çš„å€¼å°†å¯¼è‡´ç¼–è¯‘é”™è¯¯
- æ¥æ”¶æ¶ˆæ¯çš„æ“ä½œrx.recv()ä¼šé˜»å¡å½“å‰çº¿ç¨‹ï¼Œç›´åˆ°è¯»å–åˆ°å€¼ï¼Œæˆ–è€…é€šé“è¢«å…³é—­
- éœ€è¦ä½¿ç”¨moveå°†txçš„æ‰€æœ‰æƒè½¬ç§»åˆ°å­çº¿ç¨‹çš„é—­åŒ…ä¸­
#### åŒæ­¥å’Œå¼‚æ­¥é€šé“
##### å¼‚æ­¥é€šé“
```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;
fn main() {
    let (tx, rx)= mpsc::channel();

    let handle = thread::spawn(move || {
        println!("å‘é€ä¹‹å‰");
        tx.send(1).unwrap();
        println!("å‘é€ä¹‹å");
    });

    println!("ç¡çœ ä¹‹å‰");
    thread::sleep(Duration::from_secs(3));
    println!("ç¡çœ ä¹‹å");

    println!("receive {}", rx.recv().unwrap());
    handle.join().unwrap();
}
```
##### åŒæ­¥é€šé“
```rs
use std::sync::mpsc;
use std::thread;
use std::time::Duration;
fn main() {
    // è®¾ç½®æ¶ˆæ¯é˜Ÿåˆ—å¤§å°
    let (tx, rx)= mpsc::sync_channel(0);

    let handle = thread::spawn(move || {
        println!("å‘é€ä¹‹å‰");
        tx.send(1).unwrap();
        println!("å‘é€ä¹‹å");
    });

    println!("ç¡çœ ä¹‹å‰");
    thread::sleep(Duration::from_secs(3));
    println!("ç¡çœ ä¹‹å");

    println!("receive {}", rx.recv().unwrap());
    handle.join().unwrap();
}
```

#### ä¼ è¾“å¤šç§ç±»å‹çš„æ•°æ®
```rs
use std::sync::mpsc::{self, Receiver, Sender};

enum Fruit {
    Apple(u8),
    Orange(String)
}

fn main() {
    let (tx, rx): (Sender<Fruit>, Receiver<Fruit>) = mpsc::channel();

    tx.send(Fruit::Orange("sweet".to_string())).unwrap();
    tx.send(Fruit::Apple(2)).unwrap();

    for _ in 0..2 {
        match rx.recv().unwrap() {
            Fruit::Apple(count) => println!("received {} apples", count),
            Fruit::Orange(flavor) => println!("received {} oranges", flavor),
        }
    }
}
```
### çº¿ç¨‹åŒæ­¥ï¼šé”ã€Condvar å’Œä¿¡å·é‡
å…±äº«å†…å­˜å¯ä»¥è¯´æ˜¯åŒæ­¥çš„çµé­‚ï¼Œå› ä¸ºæ¶ˆæ¯ä¼ é€’çš„åº•å±‚å®é™…ä¸Šä¹Ÿæ˜¯é€šè¿‡å…±äº«å†…å­˜æ¥å®ç°ï¼Œä¸¤è€…çš„åŒºåˆ«å¦‚ä¸‹ï¼š

- å…±äº«å†…å­˜ç›¸å¯¹æ¶ˆæ¯ä¼ é€’èƒ½èŠ‚çœå¤šæ¬¡å†…å­˜æ‹·è´çš„æˆæœ¬
- å…±äº«å†…å­˜çš„å®ç°ç®€æ´çš„å¤š
- å…±äº«å†…å­˜çš„é”ç«äº‰æ›´å¤š
æ¶ˆæ¯ä¼ é€’é€‚ç”¨çš„åœºæ™¯å¾ˆå¤šï¼Œæˆ‘ä»¬ä¸‹é¢åˆ—å‡ºäº†å‡ ä¸ªä¸»è¦çš„ä½¿ç”¨åœºæ™¯:

- éœ€è¦å¯é å’Œç®€å•çš„(ç®€å•ä¸ç­‰äºç®€æ´)å®ç°æ—¶
- éœ€è¦æ¨¡æ‹Ÿç°å®ä¸–ç•Œï¼Œä¾‹å¦‚ç”¨æ¶ˆæ¯å»é€šçŸ¥æŸä¸ªç›®æ ‡æ‰§è¡Œç›¸åº”çš„æ“ä½œæ—¶
- éœ€è¦ä¸€ä¸ªä»»åŠ¡å¤„ç†æµæ°´çº¿(ç®¡é“)æ—¶ï¼Œç­‰ç­‰
#### äº’æ–¥é” Mutex
```rs
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
```
#### è¯»å†™é” RwLock
```rs
use std::sync::RwLock;

fn main() {
    let lock = RwLock::new(5);

    // åŒä¸€æ—¶é—´å…è®¸å¤šä¸ªè¯»
    {
        let r1 = lock.read().unwrap();
        let r2 = lock.read().unwrap();
        assert_eq!(*r1, 5);
        assert_eq!(*r2, 5);
    } // è¯»é”åœ¨æ­¤å¤„è¢«drop

    // åŒä¸€æ—¶é—´åªå…è®¸ä¸€ä¸ªå†™
    {
        let mut w = lock.write().unwrap();
        *w += 1;
        assert_eq!(*w, 6);

        // ä»¥ä¸‹ä»£ç ä¼španicï¼Œå› ä¸ºè¯»å’Œå†™ä¸å…è®¸åŒæ—¶å­˜åœ¨
        // å†™é”wç›´åˆ°è¯¥è¯­å¥å—ç»“æŸæ‰è¢«é‡Šæ”¾ï¼Œå› æ­¤ä¸‹é¢çš„è¯»é”ä¾ç„¶å¤„äº`w`çš„ä½œç”¨åŸŸä¸­
        // let r1 = lock.read();
        // println!("{:?}",r1);
    }// å†™é”åœ¨æ­¤å¤„è¢«drop
}
```
åŒæ—¶å…è®¸å¤šä¸ªè¯»ï¼Œä½†æœ€å¤šåªèƒ½æœ‰ä¸€ä¸ªå†™
è¯»å’Œå†™ä¸èƒ½åŒæ—¶å­˜åœ¨
è¯»å¯ä»¥ä½¿ç”¨readã€try_readï¼Œå†™writeã€try_write, åœ¨å®é™…é¡¹ç›®ä¸­ï¼Œtry_xxxä¼šå®‰å…¨çš„å¤š
### çº¿ç¨‹åŒæ­¥ï¼šAtomic åŸå­ç±»å‹ä¸å†…å­˜é¡ºåº
åŸå­æŒ‡çš„æ˜¯ä¸€ç³»åˆ—ä¸å¯è¢« CPU ä¸Šä¸‹æ–‡äº¤æ¢çš„æœºå™¨æŒ‡ä»¤ï¼Œè¿™äº›æŒ‡ä»¤ç»„åˆåœ¨ä¸€èµ·å°±å½¢æˆäº†åŸå­æ“ä½œã€‚åœ¨å¤šæ ¸ CPU ä¸‹ï¼Œå½“æŸä¸ª CPU æ ¸å¿ƒå¼€å§‹è¿è¡ŒåŸå­æ“ä½œæ—¶ï¼Œä¼šå…ˆæš‚åœå…¶å®ƒ CPU å†…æ ¸å¯¹å†…å­˜çš„æ“ä½œï¼Œä»¥ä¿è¯åŸå­æ“ä½œä¸ä¼šè¢«å…¶å®ƒ CPU å†…æ ¸æ‰€å¹²æ‰°ã€‚
```rs
use std::ops::Sub;
use std::sync::atomic::{AtomicU64, Ordering};
use std::thread::{self, JoinHandle};
use std::time::Instant;

const N_TIMES: u64 = 10000000;
const N_THREADS: usize = 10;

static R: AtomicU64 = AtomicU64::new(0);

fn add_n_times(n: u64) -> JoinHandle<()> {
    thread::spawn(move || {
        for _ in 0..n {
            R.fetch_add(1, Ordering::Relaxed);
        }
    })
}

fn main() {
    let s = Instant::now();
    let mut threads = Vec::with_capacity(N_THREADS);

    for _ in 0..N_THREADS {
        threads.push(add_n_times(N_TIMES));
    }

    for thread in threads {
        thread.join().unwrap();
    }

    assert_eq!(N_TIMES * N_THREADS as u64, R.load(Ordering::Relaxed));

    println!("{:?}",Instant::now().sub(s));
}
```
#### Atomic èƒ½æ›¿ä»£é”å—
å¯¹äºå¤æ‚çš„åœºæ™¯ä¸‹ï¼Œé”çš„ä½¿ç”¨ç®€å•ç²—æš´ï¼Œä¸å®¹æ˜“æœ‰å‘
std::sync::atomicåŒ…ä¸­ä»…æä¾›äº†æ•°å€¼ç±»å‹çš„åŸå­æ“ä½œï¼šAtomicBool, AtomicIsize, AtomicUsize, AtomicI8, AtomicU16ç­‰ï¼Œè€Œé”å¯ä»¥åº”ç”¨äºå„ç§ç±»å‹
åœ¨æœ‰äº›æƒ…å†µä¸‹ï¼Œå¿…é¡»ä½¿ç”¨é”æ¥é…åˆï¼Œä¾‹å¦‚ä¸Šä¸€ç« èŠ‚ä¸­ä½¿ç”¨Mutexé…åˆCondvar

### åŸºäº Send å’Œ Sync çš„çº¿ç¨‹å®‰å…¨
## å…¨å±€å˜é‡
### ç¼–è¯‘æœŸåˆå§‹åŒ–
#### é™æ€å¸¸é‡
```rs
const MAX_ID: usize =  usize::MAX / 2;
fn main() {
   println!("ç”¨æˆ·IDå…è®¸çš„æœ€å¤§å€¼æ˜¯{}",MAX_ID);
}
```
- å…³é”®å­—æ˜¯constè€Œä¸æ˜¯let
- å®šä¹‰å¸¸é‡å¿…é¡»æŒ‡æ˜ç±»å‹ï¼ˆå¦‚ i32ï¼‰ä¸èƒ½çœç•¥
- å®šä¹‰å¸¸é‡æ—¶å˜é‡çš„å‘½åè§„åˆ™ä¸€èˆ¬æ˜¯å…¨éƒ¨å¤§å†™
- å¸¸é‡å¯ä»¥åœ¨ä»»æ„ä½œç”¨åŸŸè¿›è¡Œå®šä¹‰ï¼Œå…¶ç”Ÿå‘½å‘¨æœŸè´¯ç©¿æ•´ä¸ªç¨‹åºçš„ç”Ÿå‘½å‘¨æœŸã€‚ç¼–è¯‘æ—¶ç¼–è¯‘å™¨ä¼šå°½å¯èƒ½å°†å…¶å†…è”åˆ°ä»£ç ä¸­ï¼Œæ‰€ä»¥åœ¨ä¸åŒåœ°æ–¹å¯¹åŒä¸€å¸¸é‡çš„å¼•ç”¨å¹¶ä¸èƒ½ä¿è¯å¼•ç”¨åˆ°ç›¸åŒçš„å†…å­˜åœ°å€
- å¸¸é‡çš„èµ‹å€¼åªèƒ½æ˜¯å¸¸é‡è¡¨è¾¾å¼/æ•°å­¦è¡¨è¾¾å¼ï¼Œä¹Ÿå°±æ˜¯è¯´å¿…é¡»æ˜¯åœ¨ç¼–è¯‘æœŸå°±èƒ½è®¡ç®—å‡ºçš„å€¼ï¼Œå¦‚æœéœ€è¦åœ¨è¿è¡Œæ—¶æ‰èƒ½å¾—å‡ºç»“æœçš„å€¼æ¯”å¦‚å‡½æ•°ï¼Œåˆ™ä¸èƒ½èµ‹å€¼ç»™å¸¸é‡è¡¨è¾¾å¼
- å¯¹äºå˜é‡å‡ºç°é‡å¤çš„å®šä¹‰(ç»‘å®š)ä¼šå‘ç”Ÿå˜é‡é®ç›–ï¼Œåé¢å®šä¹‰çš„å˜é‡ä¼šé®ä½å‰é¢å®šä¹‰çš„å˜é‡ï¼Œå¸¸é‡åˆ™ä¸å…è®¸å‡ºç°é‡å¤çš„å®šä¹‰

#### é™æ€å˜é‡
```rs
static mut REQUEST_RECV: usize = 0;
fn main() {
   unsafe {
        REQUEST_RECV += 1;
        assert_eq!(REQUEST_RECV, 1);
   }
}
```
Rust è¦æ±‚å¿…é¡»ä½¿ç”¨unsafeè¯­å¥å—æ‰èƒ½è®¿é—®å’Œä¿®æ”¹staticå˜é‡ï¼Œå› ä¸ºè¿™ç§ä½¿ç”¨æ–¹å¼å¾€å¾€å¹¶ä¸å®‰å…¨ï¼Œå…¶å®ç¼–è¯‘å™¨æ˜¯å¯¹çš„ï¼Œå½“åœ¨å¤šçº¿ç¨‹ä¸­åŒæ—¶å»ä¿®æ”¹æ—¶ï¼Œä¼šä¸å¯é¿å…çš„é‡åˆ°è„æ•°æ®ã€‚

åªæœ‰åœ¨åŒä¸€çº¿ç¨‹å†…æˆ–è€…ä¸åœ¨ä¹æ•°æ®çš„å‡†ç¡®æ€§æ—¶ï¼Œæ‰åº”è¯¥ä½¿ç”¨å…¨å±€é™æ€å˜é‡ã€‚
#### åŸå­ç±»å‹
æƒ³è¦å…¨å±€è®¡æ•°å™¨ã€çŠ¶æ€æ§åˆ¶ç­‰åŠŸèƒ½ï¼Œåˆæƒ³è¦çº¿ç¨‹å®‰å…¨çš„å®ç°ï¼ŒåŸå­ç±»å‹æ˜¯éå¸¸å¥½çš„åŠæ³•ã€‚
```rs
use std::sync::atomic::{AtomicUsize, Ordering};
static REQUEST_RECV: AtomicUsize  = AtomicUsize::new(0);
fn main() {
    for _ in 0..100 {
        REQUEST_RECV.fetch_add(1, Ordering::Relaxed);
    }

    println!("å½“å‰ç”¨æˆ·è¯·æ±‚æ•°{:?}",REQUEST_RECV);
}
```
### è¿è¡ŒæœŸåˆå§‹åŒ–
é™æ€åˆå§‹åŒ–æœ‰ä¸€ä¸ªè‡´å‘½çš„é—®é¢˜ï¼šæ— æ³•ç”¨å‡½æ•°è¿›è¡Œé™æ€åˆå§‹åŒ–ï¼Œä¾‹å¦‚ä½ å¦‚æœæƒ³å£°æ˜ä¸€ä¸ªå…¨å±€çš„Mutexé”ï¼š
```rs
use std::sync::Mutex;
static NAMES: Mutex<String> = Mutex::new(String::from("Sunface, Jack, Allen"));

fn main() {
    let v = NAMES.lock().unwrap();
    println!("{}",v);
}
```

è¿è¡ŒåæŠ¥é”™å¦‚ä¸‹ï¼š
```shell
error[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants
 --> src/main.rs:3:42
  |
3 | static NAMES: Mutex<String> = Mutex::new(String::from("sunface"));
```


#### lazy_static
lazy_staticæ˜¯ç¤¾åŒºæä¾›çš„éå¸¸å¼ºå¤§çš„å®ï¼Œç”¨äºæ‡’åˆå§‹åŒ–é™æ€å˜é‡ï¼Œä¹‹å‰çš„é™æ€å˜é‡éƒ½æ˜¯åœ¨ç¼–è¯‘æœŸåˆå§‹åŒ–çš„ï¼Œå› æ­¤æ— æ³•ä½¿ç”¨å‡½æ•°è°ƒç”¨è¿›è¡Œèµ‹å€¼ï¼Œè€Œlazy_staticå…è®¸æˆ‘ä»¬åœ¨è¿è¡ŒæœŸåˆå§‹åŒ–é™æ€å˜é‡ï¼
```rs
use std::sync::Mutex;
use lazy_static::lazy_static;
lazy_static! {
    static ref NAMES: Mutex<String> = Mutex::new(String::from("Sunface, Jack, Allen"));
}

fn main() {
    let mut v = NAMES.lock().unwrap();
    v.push_str(", Myth");
    println!("{}",v);
}
```

#### Box::leak
Rustä¸ºæˆ‘ä»¬æä¾›äº†Box::leakæ–¹æ³•ï¼Œå®ƒå¯ä»¥å°†ä¸€ä¸ªå˜é‡ä»å†…å­˜ä¸­æ³„æ¼ï¼Œç„¶åå°†å…¶å˜ä¸º'staticç”Ÿå‘½å‘¨æœŸï¼Œæœ€ç»ˆè¯¥å˜é‡å°†å’Œç¨‹åºæ´»å¾—ä¸€æ ·ä¹…ï¼Œå› æ­¤å¯ä»¥èµ‹å€¼ç»™å…¨å±€é™æ€å˜é‡CONFIGã€‚
```rs
#[derive(Debug)]
struct Config {
    a: String,
    b: String
}
static mut CONFIG: Option<&mut Config> = None;

fn main() {
    let c = Box::new(Config {
        a: "A".to_string(),
        b: "B".to_string(),
    });

    unsafe {
        // å°†`c`ä»å†…å­˜ä¸­æ³„æ¼ï¼Œå˜æˆ`'static`ç”Ÿå‘½å‘¨æœŸ
        CONFIG = Some(Box::leak(c));
        println!("{:?}", CONFIG);
    }
}
```
#### ä»å‡½æ•°ä¸­è¿”å›å…¨å±€å˜é‡
```rs
#[derive(Debug)]
struct Config {
    a: String,
    b: String,
}
static mut CONFIG: Option<&mut Config> = None;

fn init() -> Option<&'static mut Config> {
    Some(&mut Config {
        a: "A".to_string(),
        b: "B".to_string(),
    })
}


fn main() {
    unsafe {
        CONFIG = init();

        println!("{:?}", CONFIG)
    }
}
```
### æ ‡å‡†åº“ä¸­çš„ OnceCell
åœ¨ Rust æ ‡å‡†åº“ä¸­æä¾›äº†å®éªŒæ€§çš„ lazy::OnceCell å’Œ lazy::SyncOnceCell (åœ¨ Rust 1.70.0ç‰ˆæœ¬åŠä»¥ä¸Šçš„æ ‡å‡†åº“ä¸­ï¼Œæ›¿æ¢ä¸ºç¨³å®šçš„ cell::OnceCell å’Œ sync::OnceLock )ä¸¤ç§ Cell ï¼Œå‰è€…ç”¨äºå•çº¿ç¨‹ï¼Œåè€…ç”¨äºå¤šçº¿ç¨‹ï¼Œå®ƒä»¬ç”¨æ¥å­˜å‚¨å †ä¸Šçš„ä¿¡æ¯ï¼Œå¹¶ä¸”å…·æœ‰æœ€ å¤šåªèƒ½èµ‹å€¼ä¸€æ¬¡çš„ç‰¹æ€§ã€‚ å¦‚å®ç°ä¸€ä¸ªå¤šçº¿ç¨‹çš„æ—¥å¿—ç»„ä»¶ Loggerï¼š
```rs
// ä½äºRust 1.70ç‰ˆæœ¬ä¸­ï¼Œ OnceCell å’Œ SyncOnceCell çš„APIä¸ºå®éªŒæ€§çš„ ï¼Œ
// éœ€å¯ç”¨ç‰¹æ€§ `#![feature(once_cell)]`ã€‚
// #![feature(once_cell)]
// use std::{lazy::SyncOnceCell, thread};

// Rust 1.70ç‰ˆæœ¬ä»¥ä¸Š,
use std::{sync::OnceLock, thread};

fn main() {
    // å­çº¿ç¨‹ä¸­è°ƒç”¨
    let handle = thread::spawn(|| {
        let logger = Logger::global();
        logger.log("thread message".to_string());
    });

    // ä¸»çº¿ç¨‹è°ƒç”¨
    let logger = Logger::global();
    logger.log("some message".to_string());

    let logger2 = Logger::global();
    logger2.log("other message".to_string());

    handle.join().unwrap();
}

#[derive(Debug)]
struct Logger;

// ä½äºRust 1.70ç‰ˆæœ¬
// static LOGGER: SyncOnceCell<Logger> = SyncOnceCell::new();

// Rust 1.70ç‰ˆæœ¬ä»¥ä¸Š
static LOGGER: OnceLock<Logger> = OnceLock::new();

impl Logger {
    fn global() -> &'static Logger {
        // è·å–æˆ–åˆå§‹åŒ– Logger
        LOGGER.get_or_init(|| {
            println!("Logger is being created..."); // åˆå§‹åŒ–æ‰“å°
            Logger
        })
    }

    fn log(&self, message: String) {
        println!("{}", message)
    }
}
```

ä»¥ä¸Šä»£ç æˆ‘ä»¬å£°æ˜äº†ä¸€ä¸ª global() å…³è”å‡½æ•°ï¼Œå¹¶åœ¨å…¶å†…éƒ¨è°ƒç”¨ get_or_init è¿›è¡Œåˆå§‹åŒ– Loggerï¼Œä¹‹ååœ¨ä¸åŒçº¿ç¨‹ä¸Šå¤šæ¬¡è°ƒç”¨ Logger::global() è·å–å…¶å®ä¾‹ï¼š

Logger is being created...
some message
other message
thread message
å¯ä»¥çœ‹åˆ°ï¼ŒLogger is being created... åœ¨å¤šä¸ªçº¿ç¨‹ä¸­ä½¿ç”¨ä¹Ÿåªè¢«æ‰“å°äº†ä¸€æ¬¡ã€‚

## é”™è¯¯å¤„ç†
### ç»„åˆå™¨
ä¸ç»„åˆå™¨æ¨¡å¼æœ‰æ‰€ä¸åŒï¼Œåœ¨ Rust ä¸­ï¼Œç»„åˆå™¨æ›´å¤šçš„æ˜¯ç”¨äºå¯¹è¿”å›ç»“æœçš„ç±»å‹è¿›è¡Œå˜æ¢ï¼šä¾‹å¦‚ä½¿ç”¨ ok_or å°†ä¸€ä¸ª Option ç±»å‹è½¬æ¢æˆ Result ç±»å‹ã€‚

#### or() å’Œ and()
è·Ÿå¸ƒå°”å…³ç³»çš„ä¸/æˆ–å¾ˆåƒï¼Œè¿™ä¸¤ä¸ªæ–¹æ³•ä¼šå¯¹ä¸¤ä¸ªè¡¨è¾¾å¼åšé€»è¾‘ç»„åˆï¼Œæœ€ç»ˆè¿”å› Option / Resultã€‚
- or()ï¼Œè¡¨è¾¾å¼æŒ‰ç…§é¡ºåºæ±‚å€¼ï¼Œè‹¥ä»»ä½•ä¸€ä¸ªè¡¨è¾¾å¼çš„ç»“æœæ˜¯ Some æˆ– Okï¼Œåˆ™è¯¥å€¼ä¼šç«‹åˆ»è¿”å›
- and()ï¼Œè‹¥ä¸¤ä¸ªè¡¨è¾¾å¼çš„ç»“æœéƒ½æ˜¯ Some æˆ– Okï¼Œåˆ™ç¬¬äºŒä¸ªè¡¨è¾¾å¼ä¸­çš„å€¼è¢«è¿”å›ã€‚è‹¥ä»»ä½•ä¸€ä¸ªçš„ç»“æœæ˜¯ None æˆ– Err ï¼Œåˆ™ç«‹åˆ»è¿”å›ã€‚
å®é™…ä¸Šï¼Œåªè¦å°†å¸ƒå°”è¡¨è¾¾å¼çš„ true / falseï¼Œæ›¿æ¢æˆ Some / None æˆ– Ok / Err å°±å¾ˆå¥½ç†è§£äº†ã€‚
```rs
fn main() {
  let s1 = Some("some1");
  let s2 = Some("some2");
  let n: Option<&str> = None;

  let o1: Result<&str, &str> = Ok("ok1");
  let o2: Result<&str, &str> = Ok("ok2");
  let e1: Result<&str, &str> = Err("error1");
  let e2: Result<&str, &str> = Err("error2");

  assert_eq!(s1.or(s2), s1); // Some1 or Some2 = Some1
  assert_eq!(s1.or(n), s1);  // Some or None = Some
  assert_eq!(n.or(s1), s1);  // None or Some = Some
  assert_eq!(n.or(n), n);    // None1 or None2 = None2

  assert_eq!(o1.or(o2), o1); // Ok1 or Ok2 = Ok1
  assert_eq!(o1.or(e1), o1); // Ok or Err = Ok
  assert_eq!(e1.or(o1), o1); // Err or Ok = Ok
  assert_eq!(e1.or(e2), e2); // Err1 or Err2 = Err2

  assert_eq!(s1.and(s2), s2); // Some1 and Some2 = Some2
  assert_eq!(s1.and(n), n);   // Some and None = None
  assert_eq!(n.and(s1), n);   // None and Some = None
  assert_eq!(n.and(n), n);    // None1 and None2 = None1

  assert_eq!(o1.and(o2), o2); // Ok1 and Ok2 = Ok2
  assert_eq!(o1.and(e1), e1); // Ok and Err = Err
  assert_eq!(e1.and(o1), e1); // Err and Ok = Err
  assert_eq!(e1.and(e2), e1); // Err1 and Err2 = Err1
}
```

é™¤äº† or å’Œ and ä¹‹å¤–ï¼ŒRust è¿˜ä¸ºæˆ‘ä»¬æä¾›äº† xor ï¼Œä½†æ˜¯å®ƒåªèƒ½åº”ç”¨åœ¨ Option ä¸Š.


#### or_else() å’Œ and_then()
å®ƒä»¬è·Ÿ or() å’Œ and() ç±»ä¼¼ï¼Œå”¯ä¸€çš„åŒºåˆ«åœ¨äºï¼Œå®ƒä»¬çš„ç¬¬äºŒä¸ªè¡¨è¾¾å¼æ˜¯ä¸€ä¸ªé—­åŒ…ã€‚
```rs
fn main() {
    // or_else with Option
    let s1 = Some("some1");
    let s2 = Some("some2");
    let fn_some = || Some("some2"); // ç±»ä¼¼äº: let fn_some = || -> Option<&str> { Some("some2") };

    let n: Option<&str> = None;
    let fn_none = || None;

    assert_eq!(s1.or_else(fn_some), s1);  // Some1 or_else Some2 = Some1
    assert_eq!(s1.or_else(fn_none), s1);  // Some or_else None = Some
    assert_eq!(n.or_else(fn_some), s2);   // None or_else Some = Some
    assert_eq!(n.or_else(fn_none), None); // None1 or_else None2 = None2

    // or_else with Result
    let o1: Result<&str, &str> = Ok("ok1");
    let o2: Result<&str, &str> = Ok("ok2");
    let fn_ok = |_| Ok("ok2"); // ç±»ä¼¼äº: let fn_ok = |_| -> Result<&str, &str> { Ok("ok2") };

    let e1: Result<&str, &str> = Err("error1");
    let e2: Result<&str, &str> = Err("error2");
    let fn_err = |_| Err("error2");

    assert_eq!(o1.or_else(fn_ok), o1);  // Ok1 or_else Ok2 = Ok1
    assert_eq!(o1.or_else(fn_err), o1); // Ok or_else Err = Ok
    assert_eq!(e1.or_else(fn_ok), o2);  // Err or_else Ok = Ok
    assert_eq!(e1.or_else(fn_err), e2); // Err1 or_else Err2 = Err2
}
fn main() {
    // and_then with Option
    let s1 = Some("some1");
    let s2 = Some("some2");
    let fn_some = |_| Some("some2"); // ç±»ä¼¼äº: let fn_some = |_| -> Option<&str> { Some("some2") };

    let n: Option<&str> = None;
    let fn_none = |_| None;

    assert_eq!(s1.and_then(fn_some), s2); // Some1 and_then Some2 = Some2
    assert_eq!(s1.and_then(fn_none), n);  // Some and_then None = None
    assert_eq!(n.and_then(fn_some), n);   // None and_then Some = None
    assert_eq!(n.and_then(fn_none), n);   // None1 and_then None2 = None1

    // and_then with Result
    let o1: Result<&str, &str> = Ok("ok1");
    let o2: Result<&str, &str> = Ok("ok2");
    let fn_ok = |_| Ok("ok2"); // ç±»ä¼¼äº: let fn_ok = |_| -> Result<&str, &str> { Ok("ok2") };

    let e1: Result<&str, &str> = Err("error1");
    let e2: Result<&str, &str> = Err("error2");
    let fn_err = |_| Err("error2");

    assert_eq!(o1.and_then(fn_ok), o2);  // Ok1 and_then Ok2 = Ok2
    assert_eq!(o1.and_then(fn_err), e2); // Ok and_then Err = Err
    assert_eq!(e1.and_then(fn_ok), e1);  // Err and_then Ok = Err
    assert_eq!(e1.and_then(fn_err), e1); // Err1 and_then Err2 = Err1
}

```

#### filter
filter ç”¨äºå¯¹ Option è¿›è¡Œè¿‡æ»¤ï¼š

```rs
fn main() {
    let s1 = Some(3);
    let s2 = Some(6);
    let n = None;

    let fn_is_even = |x: &i8| x % 2 == 0;

    assert_eq!(s1.filter(fn_is_even), n);  // Some(3) -> 3 is not even -> None
    assert_eq!(s2.filter(fn_is_even), s2); // Some(6) -> 6 is even -> Some(6)
    assert_eq!(n.filter(fn_is_even), n);   // None -> no value -> None
}
```

#### map() å’Œ map_err()
map å¯ä»¥å°† Some æˆ– Ok ä¸­çš„å€¼æ˜ å°„ä¸ºå¦ä¸€ä¸ªåŒç±»å‹çš„å€¼ï¼š
```rs
fn main() {
    let s1 = Some("abcde");
    let s2 = Some(5);

    let n1: Option<&str> = None;
    let n2: Option<usize> = None;

    let o1: Result<&str, &str> = Ok("abcde");
    let o2: Result<usize, &str> = Ok(5);

    let e1: Result<&str, &str> = Err("abcde");
    let e2: Result<usize, &str> = Err("abcde");
// ç»Ÿè®¡å­—ç¬¦ä¸²ä¸­
    let fn_character_count = |s: &str| s.chars().count();

    assert_eq!(s1.map(fn_character_count), s2); // Some1 map = Some2
    assert_eq!(n1.map(fn_character_count), n2); // None1 map = None2

    assert_eq!(o1.map(fn_character_count), o2); // Ok1 map = Ok2
    assert_eq!(e1.map(fn_character_count), e2); // Err1 map = Err2
}
```

ä½†æ˜¯å¦‚æœä½ æƒ³è¦å°† Err ä¸­çš„å€¼è¿›è¡Œæ”¹å˜ï¼Œæ­¤æ—¶æˆ‘ä»¬éœ€è¦ç”¨ map_errï¼š
```rs
fn main() {
    let o1: Result<&str, &str> = Ok("abcde");
    let o2: Result<&str, isize> = Ok("abcde");

    let e1: Result<&str, &str> = Err("404");
    let e2: Result<&str, isize> = Err(404);

    let fn_character_count = |s: &str| -> isize { s.parse().unwrap() }; // è¯¥å‡½æ•°è¿”å›ä¸€ä¸ª isize

    assert_eq!(o1.map_err(fn_character_count), o2); // Ok1 map = Ok2
    assert_eq!(e1.map_err(fn_character_count), e2); // Err1 map = Err2
}
```


#### map_or() å’Œ map_or_else()
map_or åœ¨ map çš„åŸºç¡€ä¸Šæä¾›äº†ä¸€ä¸ªé»˜è®¤å€¼:
```rs
fn main() {
    const V_DEFAULT: u32 = 1;

    let s: Result<u32, ()> = Ok(10);
    let n: Option<u32> = None;
    let fn_closure = |v: u32| v + 2;

    assert_eq!(s.map_or(V_DEFAULT, fn_closure), 12);
    assert_eq!(n.map_or(V_DEFAULT, fn_closure), V_DEFAULT);
}
```

å¦‚ä¸Šæ‰€ç¤ºï¼Œå½“å¤„ç† None çš„æ—¶å€™ï¼ŒV_DEFAULT ä½œä¸ºé»˜è®¤å€¼è¢«ç›´æ¥è¿”å›ã€‚

map_or_else ä¸ map_or ç±»ä¼¼ï¼Œä½†æ˜¯å®ƒæ˜¯é€šè¿‡ä¸€ä¸ªé—­åŒ…æ¥æä¾›é»˜è®¤å€¼:
```rs
fn main() {
    let s = Some(10);
    let n: Option<i8> = None;

    let fn_closure = |v: i8| v + 2;
    let fn_default = || 1;

    assert_eq!(s.map_or_else(fn_default, fn_closure), 12);
    assert_eq!(n.map_or_else(fn_default, fn_closure), 1);

    let o = Ok(10);
    let e = Err(5);
    let fn_default_for_result = |v: i8| v + 1; // é—­åŒ…å¯ä»¥å¯¹ Err ä¸­çš„å€¼è¿›è¡Œå¤„ç†ï¼Œå¹¶è¿”å›ä¸€ä¸ªæ–°å€¼

    assert_eq!(o.map_or_else(fn_default_for_result, fn_closure), 12);
    assert_eq!(e.map_or_else(fn_default_for_result, fn_closure), 6);
}
```

#### ok_or() and ok_or_else()
è¿™ä¸¤å…„å¼Ÿå¯ä»¥å°† Option ç±»å‹è½¬æ¢ä¸º Result ç±»å‹ã€‚å…¶ä¸­ ok_or æ¥æ”¶ä¸€ä¸ªé»˜è®¤çš„ Err å‚æ•°:
```rs
fn main() {
    const ERR_DEFAULT: &str = "error message";

    let s = Some("abcde");
    let n: Option<&str> = None;

    let o: Result<&str, &str> = Ok("abcde");
    let e: Result<&str, &str> = Err(ERR_DEFAULT);

    assert_eq!(s.ok_or(ERR_DEFAULT), o); // Some(T) -> Ok(T)
    assert_eq!(n.ok_or(ERR_DEFAULT), e); // None -> Err(default)
}
```

è€Œ ok_or_else æ¥æ”¶ä¸€ä¸ªé—­åŒ…ä½œä¸º Err å‚æ•°:
```rs
fn main() {
    let s = Some("abcde");
    let n: Option<&str> = None;
    let fn_err_message = || "error message";

    let o: Result<&str, &str> = Ok("abcde");
    let e: Result<&str, &str> = Err("error message");

    assert_eq!(s.ok_or_else(fn_err_message), o); // Some(T) -> Ok(T)
    assert_eq!(n.ok_or_else(fn_err_message), e); // None -> Err(default)
}
```


### è‡ªå®šä¹‰é”™è¯¯ç±»å‹
è™½ç„¶æ ‡å‡†åº“å®šä¹‰äº†å¤§é‡çš„é”™è¯¯ç±»å‹ï¼Œä½†æ˜¯ä¸€ä¸ªä¸¥è°¨çš„é¡¹ç›®ï¼Œå…‰ä½¿ç”¨è¿™äº›é”™è¯¯ç±»å‹å¾€å¾€æ˜¯ä¸å¤Ÿçš„ï¼Œä¾‹å¦‚æˆ‘ä»¬å¯èƒ½ä¼šä¸ºæš´éœ²ç»™ç”¨æˆ·çš„é”™è¯¯å®šä¹‰ç›¸åº”çš„ç±»å‹ã€‚

ä¸ºäº†å¸®åŠ©æˆ‘ä»¬æ›´å¥½çš„å®šä¹‰é”™è¯¯ï¼ŒRust åœ¨æ ‡å‡†åº“ä¸­æä¾›äº†ä¸€äº›å¯å¤ç”¨çš„ç‰¹å¾ï¼Œä¾‹å¦‚ std::error::Error ç‰¹å¾ï¼š
```rs
use std::fmt::{Debug, Display};

pub trait Error: Debug + Display {
    fn source(&self) -> Option<&(Error + 'static)> { ... }
}
```

å½“è‡ªå®šä¹‰ç±»å‹å®ç°è¯¥ç‰¹å¾åï¼Œè¯¥ç±»å‹å°±å¯ä»¥ä½œä¸º Err æ¥ä½¿ç”¨ã€‚

å®é™…ä¸Šï¼Œè‡ªå®šä¹‰é”™è¯¯ç±»å‹åªéœ€è¦å®ç° Debug å’Œ Display ç‰¹å¾å³å¯ï¼Œsource æ–¹æ³•æ˜¯å¯é€‰çš„ï¼Œè€Œ Debug ç‰¹å¾å¾€å¾€ä¹Ÿæ— éœ€æ‰‹åŠ¨å®ç°ï¼Œå¯ä»¥ç›´æ¥é€šè¿‡ derive æ¥æ´¾ç”Ÿ

æœ€ç®€å•çš„é”™è¯¯
```rs
use std::fmt;

// AppError æ˜¯è‡ªå®šä¹‰é”™è¯¯ç±»å‹ï¼Œå®ƒå¯ä»¥æ˜¯å½“å‰åŒ…ä¸­å®šä¹‰çš„ä»»ä½•ç±»å‹ï¼Œåœ¨è¿™é‡Œä¸ºäº†ç®€åŒ–ï¼Œæˆ‘ä»¬ä½¿ç”¨äº†å•å…ƒç»“æ„ä½“ä½œä¸ºä¾‹å­ã€‚
// ä¸º AppError è‡ªåŠ¨æ´¾ç”Ÿ Debug ç‰¹å¾
#[derive(Debug)]
struct AppError;

// ä¸º AppError å®ç° std::fmt::Display ç‰¹å¾
impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "An Error Occurred, Please Try Again!") // user-facing output
    }
}

// ä¸€ä¸ªç¤ºä¾‹å‡½æ•°ç”¨äºäº§ç”Ÿ AppError é”™è¯¯
fn produce_error() -> Result<(), AppError> {
    Err(AppError)
}

fn main(){
    match produce_error() {
        Err(e) => eprintln!("{}", e),
        _ => println!("No error"),
    }

    eprintln!("{:?}", produce_error()); // Err({ file: src/main.rs, line: 17 })
}
```

ä¸Šé¢çš„ä¾‹å­å¾ˆç®€å•ï¼Œæˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªé”™è¯¯ç±»å‹ï¼Œå½“ä¸ºå®ƒæ´¾ç”Ÿäº† Debug ç‰¹å¾ï¼ŒåŒæ—¶æ‰‹åŠ¨å®ç°äº† Display ç‰¹å¾åï¼Œè¯¥é”™è¯¯ç±»å‹å°±å¯ä»¥ä½œä¸º Erræ¥ä½¿ç”¨äº†ã€‚

äº‹å®ä¸Šï¼Œå®ç° Debug å’Œ Display ç‰¹å¾å¹¶ä¸æ˜¯ä½œä¸º Err ä½¿ç”¨çš„å¿…è¦æ¡ä»¶ï¼Œå¤§å®¶å¯ä»¥æŠŠè¿™ä¸¤ä¸ªç‰¹å¾å®ç°å’Œç›¸åº”ä½¿ç”¨å»é™¤ï¼Œç„¶åçœ‹çœ‹ä»£ç ä¼šå¦æŠ¥é”™ã€‚æ—¢ç„¶å¦‚æ­¤ï¼Œæˆ‘ä»¬ä¸ºä½•è¦ä¸ºè‡ªå®šä¹‰ç±»å‹å®ç°è¿™ä¸¤ä¸ªç‰¹å¾å‘¢ï¼ŸåŸå› æœ‰äºŒ:

é”™è¯¯å¾—æ‰“å°è¾“å‡ºåï¼Œæ‰èƒ½æœ‰å®é™…ç”¨å¤„ï¼Œè€Œæ‰“å°è¾“å‡ºå°±éœ€è¦å®ç°è¿™ä¸¤ä¸ªç‰¹å¾
å¯ä»¥å°†è‡ªå®šä¹‰é”™è¯¯è½¬æ¢æˆ `Box<dyn std::error:Error> `ç‰¹å¾å¯¹è±¡ï¼Œåœ¨åé¢çš„å½’ä¸€åŒ–ä¸åŒé”™è¯¯ç±»å‹éƒ¨åˆ†.
ç°åœ¨å†æ¥å®šä¹‰ä¸€ä¸ªå…·æœ‰é”™è¯¯ç å’Œä¿¡æ¯çš„é”™è¯¯:
```rs
use std::fmt;

struct AppError {
    code: usize,
    message: String,
}

// æ ¹æ®é”™è¯¯ç æ˜¾ç¤ºä¸åŒçš„é”™è¯¯ä¿¡æ¯
impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let err_msg = match self.code {
            404 => "Sorry, Can not find the Page!",
            _ => "Sorry, something is wrong! Please Try Again!",
        };
// å‘ä¸€ä¸ªç¼“å†²åŒºé‡Œå†™æ ¼å¼åŒ–çš„æ•°æ®ã€‚
// write!å°†æ ¼å¼åŒ–çš„å†…å®¹å†™å…¥åˆ°æŒ‡å®šçš„è¾“å‡ºæµä¸­ï¼Œä¾‹å¦‚write!(std::io::stdout(), "hello {}!", "world")å°†åœ¨æ ‡å‡†è¾“å‡ºæµä¸­æ‰“å°å‡ºhello world!ã€‚
// print!ä¹Ÿæ˜¯å¯¹è¾“å‡ºå†…å®¹è¿›è¡Œæ ¼å¼åŒ–ï¼Œä½†æ˜¯è¾“å‡ºçš„ç›®æ ‡æ˜¯æ ‡å‡†è¾“å‡ºæµ
        write!(f, "{}", err_msg)
    }
}

impl fmt::Debug for AppError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "AppError {{ code: {}, message: {} }}",
            self.code, self.message
        )
    }
}
// æµ‹è¯•é”™è¯¯æ–¹æ³•
fn produce_error() -> Result<(), AppError> {
    Err(AppError {
        code: 404,
        message: String::from("Page not found"),
    })
}

fn main() {
    match produce_error() {
        Err(e) => eprintln!("{}", e), // æŠ±æ­‰ï¼Œæœªæ‰¾åˆ°æŒ‡å®šçš„é¡µé¢!
        _ => println!("No error"),
    }

    eprintln!("{:?}", produce_error()); // Err(AppError { code: 404, message: Page not found })

    eprintln!("{:#?}", produce_error());
    // Err(
    //     AppError { code: 404, message: Page not found }
    // )
}
```

åœ¨æœ¬ä¾‹ä¸­ï¼Œæˆ‘ä»¬é™¤äº†å¢åŠ äº†é”™è¯¯ç å’Œæ¶ˆæ¯å¤–ï¼Œè¿˜æ‰‹åŠ¨å®ç°äº† Debug ç‰¹å¾ï¼ŒåŸå› åœ¨äºï¼Œæˆ‘ä»¬å¸Œæœ›èƒ½è‡ªå®šä¹‰ Debug çš„è¾“å‡ºå†…å®¹ï¼Œè€Œä¸æ˜¯ä½¿ç”¨æ´¾ç”Ÿåç³»ç»Ÿæä¾›çš„é»˜è®¤è¾“å‡ºå½¢å¼ã€‚

#### é”™è¯¯è½¬æ¢ From ç‰¹å¾
æ ‡å‡†åº“ã€ä¸‰æ–¹åº“ã€æœ¬åœ°åº“ï¼Œå„æœ‰å„çš„ç²¾å½©ï¼Œå„ä¹Ÿæœ‰å„çš„é”™è¯¯ã€‚é‚£ä¹ˆé—®é¢˜å°±æ¥äº†ï¼Œæˆ‘ä»¬è¯¥å¦‚ä½•å°†å…¶å®ƒçš„é”™è¯¯ç±»å‹è½¬æ¢æˆè‡ªå®šä¹‰çš„é”™è¯¯ç±»å‹ï¼Ÿæ€»ä¸èƒ½ç¥é¬¼ç‰›é­”ï¼ŒåŒå°å…±èˆå§ã€‚

å¥½åœ¨ Rust ä¸ºæˆ‘ä»¬æä¾›äº† std::convert::From ç‰¹å¾:
```rs
pub trait From<T>: Sized {
  fn from(_: T) -> Self;
}
```

å¤§å®¶éƒ½ä½¿ç”¨è¿‡ String::from å‡½æ•°å§ï¼Ÿå®ƒå¯ä»¥é€šè¿‡ &str æ¥åˆ›å»ºä¸€ä¸ª Stringï¼Œå…¶å®è¯¥å‡½æ•°å°±æ˜¯ From ç‰¹å¾æä¾›çš„

ä¸‹é¢ä¸€èµ·æ¥çœ‹çœ‹å¦‚ä½•ä¸ºè‡ªå®šä¹‰ç±»å‹å®ç° From ç‰¹å¾:
```rs
use std::fs::File;
use std::io;

#[derive(Debug)]
struct AppError {
    kind: String,    // é”™è¯¯ç±»å‹
    message: String, // é”™è¯¯ä¿¡æ¯
}

// ä¸º AppError å®ç° std::convert::From ç‰¹å¾ï¼Œç”±äº From åŒ…å«åœ¨ std::prelude ä¸­ï¼Œå› æ­¤å¯ä»¥ç›´æ¥ç®€åŒ–å¼•å…¥ã€‚
// å®ç° From<io::Error> æ„å‘³ç€æˆ‘ä»¬å¯ä»¥å°† io::Error é”™è¯¯è½¬æ¢æˆè‡ªå®šä¹‰çš„ AppError é”™è¯¯
impl From<io::Error> for AppError {
    fn from(error: io::Error) -> Self {
        AppError {
            kind: String::from("io"),
            message: error.to_string(),
        }
    }
}

fn main() -> Result<(), AppError> {
    let _file = File::open("nonexistent_file.txt")?;

    Ok(())
}
```
```shell
Error: AppError { kind: "io", message: "No such file or directory (os error 2)" }
```

ä¸Šé¢çš„ä»£ç ä¸­é™¤äº†å®ç° From å¤–ï¼Œè¿˜æœ‰ä¸€ç‚¹ç‰¹åˆ«é‡è¦ï¼Œé‚£å°±æ˜¯ ? å¯ä»¥å°†é”™è¯¯è¿›è¡Œéšå¼çš„å¼ºåˆ¶è½¬æ¢ï¼šFile::open è¿”å›çš„æ˜¯ std::io::Errorï¼Œ æˆ‘ä»¬å¹¶æ²¡æœ‰è¿›è¡Œä»»ä½•æ˜¾å¼çš„è½¬æ¢ï¼Œå®ƒå°±èƒ½è‡ªåŠ¨å˜æˆ AppError ï¼Œè¿™å°±æ˜¯ ? çš„å¼ºå¤§ä¹‹å¤„ï¼å½“ç„¶å®ç°éšå¼è½¬æ¢çš„å‰ææ˜¯å®ç°äº†å¯¹åº”çš„Fromï¼›

å†æ¥çœ‹çœ‹å¤šä¸ªä¸åŒçš„é”™è¯¯è½¬æ¢æˆ AppError çš„å®ç°ï¼š
```rs
use std::fs::File;
use std::io::{self, Read};
use std::num;

#[derive(Debug)]
struct AppError {
    kind: String,
    message: String,
}

impl From<io::Error> for AppError {
    fn from(error: io::Error) -> Self {
        AppError {
            kind: String::from("io"),
            message: error.to_string(),
        }
    }
}

impl From<num::ParseIntError> for AppError {
    fn from(error: num::ParseIntError) -> Self {
        AppError {
            kind: String::from("parse"),
            message: error.to_string(),
        }
    }
}

fn main() -> Result<(), AppError> {
    let mut file = File::open("hello_world.txt")?;

    let mut content = String::new();
    file.read_to_string(&mut content)?;

    let _number: usize;
    _number = content.parse()?;

    Ok(())
}

```

```shell
// 01. è‹¥ hello_world.txt æ–‡ä»¶ä¸å­˜åœ¨
Error: AppError { kind: "io", message: "No such file or directory (os error 2)" }

// 02. è‹¥ç”¨æˆ·æ²¡æœ‰ç›¸å…³çš„æƒé™è®¿é—® hello_world.txt
Error: AppError { kind: "io", message: "Permission denied (os error 13)" }

// 03. è‹¥ hello_world.txt åŒ…å«æœ‰éæ•°å­—çš„å†…å®¹ï¼Œä¾‹å¦‚ Hello, world!
Error: AppError { kind: "parse", message: "invalid digit found in string" }
```

### å½’ä¸€åŒ–ä¸åŒçš„é”™è¯¯ç±»å‹

åœ¨å®é™…é¡¹ç›®ä¸­ï¼Œæˆ‘ä»¬å¾€å¾€ä¼šä¸ºä¸åŒçš„é”™è¯¯å®šä¹‰ä¸åŒçš„ç±»å‹ï¼Œè¿™æ ·åšéå¸¸å¥½ï¼Œä½†æ˜¯å¦‚æœä½ è¦åœ¨ä¸€ä¸ªå‡½æ•°ä¸­è¿”å›ä¸åŒçš„é”™è¯¯å‘¢ï¼Ÿä¾‹å¦‚ï¼š
```rs
use std::fs::read_to_string;

fn main() -> Result<(), std::io::Error> {
  let html = render()?;
  println!("{}", html);
  Ok(())
}

fn render() -> Result<String, std::io::Error> {
  let file = std::env::var("MARKDOWN")?;
  let source = read_to_string(file)?;
  Ok(source)
}
```

ä¸Šé¢çš„ä»£ç ä¼šæŠ¥é”™ï¼ŒåŸå› åœ¨äº render å‡½æ•°ä¸­çš„ä¸¤ä¸ª ? è¿”å›çš„å®é™…ä¸Šæ˜¯ä¸åŒçš„é”™è¯¯ï¼šenv::var() è¿”å›çš„æ˜¯ std::env::VarErrorï¼Œè€Œ read_to_string è¿”å›çš„æ˜¯ std::io::Errorã€‚

ä¸ºäº†æ»¡è¶³ render å‡½æ•°çš„ç­¾åï¼Œæˆ‘ä»¬å°±éœ€è¦å°† env::VarError å’Œ io::Error å½’ä¸€åŒ–ä¸ºåŒä¸€ç§é”™è¯¯ç±»å‹ã€‚è¦å®ç°è¿™ä¸ªç›®çš„æœ‰ä¸‰ç§æ–¹å¼:

- ä½¿ç”¨ç‰¹å¾å¯¹è±¡ Box &lt;dyn Error>
- è‡ªå®šä¹‰é”™è¯¯ç±»å‹
- ä½¿ç”¨ thiserror
ä¸‹é¢ä¾æ¬¡æ¥çœ‹çœ‹ç›¸å…³çš„è§£å†³æ–¹å¼ã€‚

#### Box&lt;dyn Error>
```rs
use std::fs::read_to_string;
use std::error::Error;
fn main() -> Result<(), Box<dyn Error>> {
  let html = render()?;
  println!("{}", html);
  Ok(())
}

fn render() -> Result<String, Box<dyn Error>> {
  let file = std::env::var("MARKDOWN")?;
  let source = read_to_string(file)?;
  Ok(source)
}
```

è¿™ä¸ªæ–¹æ³•å¾ˆç®€å•ï¼Œåœ¨ç»å¤§å¤šæ•°åœºæ™¯ä¸­ï¼Œæ€§èƒ½ä¹Ÿéå¸¸å¤Ÿç”¨ï¼Œä½†æ˜¯æœ‰ä¸€ä¸ªé—®é¢˜ï¼šResult å®é™…ä¸Šä¸ä¼šé™åˆ¶é”™è¯¯çš„ç±»å‹ï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªç±»å‹å°±ç®—ä¸å®ç° Error ç‰¹å¾ï¼Œå®ƒä¾ç„¶å¯ä»¥åœ¨ Result&lt;T, E> ä¸­ä½œä¸º E æ¥ä½¿ç”¨ï¼Œæ­¤æ—¶è¿™ç§ç‰¹å¾å¯¹è±¡çš„è§£å†³æ–¹æ¡ˆå°±æ— èƒ½ä¸ºåŠ›äº†ã€‚

#### è‡ªå®šä¹‰é”™è¯¯ç±»å‹
ä¸ç‰¹å¾å¯¹è±¡ç›¸æ¯”ï¼Œè‡ªå®šä¹‰é”™è¯¯ç±»å‹éº»çƒ¦å½’éº»çƒ¦ï¼Œä½†æ˜¯å®ƒéå¸¸çµæ´»ï¼Œå› æ­¤ä¹Ÿä¸å…·æœ‰ä¸Šé¢çš„ç±»ä¼¼é™åˆ¶:
```rs
use std::fs::read_to_string;

fn main() -> Result<(), MyError> {
  let html = render()?;
  println!("{}", html);
  Ok(())
}

fn render() -> Result<String, MyError> {
  let file = std::env::var("MARKDOWN")?;
  let source = read_to_string(file)?;
  Ok(source)
}

#[derive(Debug)]
enum MyError {
  EnvironmentVariableNotFound,
  IOError(std::io::Error),
}

impl From<std::env::VarError> for MyError {
  fn from(_: std::env::VarError) -> Self {
    Self::EnvironmentVariableNotFound
  }
}

impl From<std::io::Error> for MyError {
  fn from(value: std::io::Error) -> Self {
    Self::IOError(value)
  }
}

impl std::error::Error for MyError {}

impl std::fmt::Display for MyError {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    match self {
      MyError::EnvironmentVariableNotFound => write!(f, "Environment variable not found"),
      MyError::IOError(err) => write!(f, "IO Error: {}", err.to_string()),
    }
  }
}
```

ä¸Šé¢ä»£ç ä¸­æœ‰ä¸€è¡Œå€¼å¾—æ³¨æ„ï¼šimpl std::error::Error for MyError {} ï¼Œåªæœ‰ä¸ºè‡ªå®šä¹‰é”™è¯¯ç±»å‹å®ç° Error ç‰¹å¾åï¼Œæ‰èƒ½è½¬æ¢æˆç›¸åº”çš„ç‰¹å¾å¯¹è±¡ã€‚

### ç®€åŒ–é”™è¯¯å¤„ç†
å¯¹äºå¼€å‘è€…è€Œè¨€ï¼Œé”™è¯¯å¤„ç†æ˜¯ä»£ç ä¸­æ‰“äº¤é“æœ€å¤šçš„éƒ¨åˆ†ä¹‹ä¸€ï¼Œå› æ­¤é€‰æ‹©ä¸€æŠŠè¶æ‰‹çš„æ­¦å™¨ä¹Ÿå¾ˆé‡è¦ï¼Œå®ƒå¯ä»¥å¸®åŠ©æˆ‘ä»¬èŠ‚çœå¤§é‡çš„æ—¶é—´å’Œç²¾åŠ›ï¼Œå¥½é’¢åº”è¯¥ç”¨åœ¨ä»£ç é€»è¾‘è€Œä¸æ˜¯å†—é•¿çš„é”™è¯¯å¤„ç†ä¸Šã€‚

#### thiserror
`thiserror`å¯ä»¥å¸®åŠ©æˆ‘ä»¬ç®€åŒ–ä¸Šé¢çš„ç¬¬äºŒç§è§£å†³æ–¹æ¡ˆï¼š
```rs
use std::fs::read_to_string;

fn main() -> Result<(), MyError> {
  let html = render()?;
  println!("{}", html);
  Ok(())
}

fn render() -> Result<String, MyError> {
  let file = std::env::var("MARKDOWN")?;
  let source = read_to_string(file)?;
  Ok(source)
}

#[derive(thiserror::Error, Debug)]
enum MyError {
  #[error("Environment variable not found")]
  EnvironmentVariableNotFound(#[from] std::env::VarError),
  #[error(transparent)]
  IOError(#[from] std::io::Error),
}
```

#### anyhow
anyhow å’Œ thiserror æ˜¯åŒä¸€ä¸ªä½œè€…å¼€å‘çš„ï¼Œè¿™é‡Œæ˜¯ä½œè€…å…³äº anyhow å’Œ thiserror çš„åŸè¯ï¼š

å¦‚æœä½ æƒ³è¦è®¾è®¡è‡ªå·±çš„é”™è¯¯ç±»å‹ï¼ŒåŒæ—¶ç»™è°ƒç”¨è€…æä¾›å…·ä½“çš„ä¿¡æ¯æ—¶ï¼Œå°±ä½¿ç”¨ thiserrorï¼Œä¾‹å¦‚å½“ä½ åœ¨å¼€å‘ä¸€ä¸ªä¸‰æ–¹åº“ä»£ç æ—¶ã€‚å¦‚æœä½ åªæƒ³è¦ç®€å•ï¼Œå°±ä½¿ç”¨ anyhowï¼Œä¾‹å¦‚åœ¨è‡ªå·±çš„åº”ç”¨æœåŠ¡ä¸­ã€‚
```rs
use std::fs::read_to_string;

use anyhow::Result;

fn main() -> Result<()> {
    let html = render()?;
    println!("{}", html);
    Ok(())
}

fn render() -> Result<String> {
    let file = std::env::var("MARKDOWN")?;
    let source = read_to_string(file)?;
    Ok(source)
}
```

å…³äºå¦‚ä½•é€‰ç”¨ thiserror å’Œ anyhow åªéœ€è¦éµå¾ªä¸€ä¸ªåŸåˆ™å³å¯ï¼šæ˜¯å¦å…³æ³¨è‡ªå®šä¹‰é”™è¯¯æ¶ˆæ¯ï¼Œå…³æ³¨åˆ™ä½¿ç”¨ thiserrorï¼ˆå¸¸è§ä¸šåŠ¡ä»£ç ï¼‰ï¼Œå¦åˆ™ä½¿ç”¨ anyhow(ç¼–å†™ç¬¬ä¸‰æ–¹åº“ä»£ç ).

## unsafe ç®€ä»‹

### è§£å¼•ç”¨è£¸æŒ‡é’ˆ
è£¸æŒ‡é’ˆé•¿è¿™æ ·: *const T å’Œ *mut Tï¼Œå®ƒä»¬åˆ†åˆ«ä»£è¡¨äº†ä¸å¯å˜å’Œå¯å˜ã€‚
**ä½œç”¨**ï¼š
- å¯ä»¥ç»•è¿‡ Rust çš„å€Ÿç”¨è§„åˆ™ï¼Œå¯ä»¥åŒæ—¶æ‹¥æœ‰ä¸€ä¸ªæ•°æ®çš„å¯å˜ã€ä¸å¯å˜æŒ‡é’ˆï¼Œç”šè‡³è¿˜èƒ½æ‹¥æœ‰å¤šä¸ªå¯å˜çš„æŒ‡é’ˆ
- å¹¶ä¸èƒ½ä¿è¯æŒ‡å‘åˆæ³•çš„å†…å­˜
- å¯ä»¥æ˜¯ null
- æ²¡æœ‰å®ç°ä»»ä½•è‡ªåŠ¨çš„å›æ”¶ (drop)
#### åŸºäºå¼•ç”¨åˆ›å»ºè£¸æŒ‡é’ˆ
åˆ›å»ºè£¸æŒ‡é’ˆæ˜¯å®‰å…¨çš„è¡Œä¸ºï¼Œè€Œè§£å¼•ç”¨è£¸æŒ‡é’ˆæ‰æ˜¯ä¸å®‰å…¨çš„è¡Œä¸º :
```rs
fn main() {
    let mut num = 5;

    let r1 = &num as *const i32;

    unsafe {
        println!("r1 is: {}", *r1);
    }
}
```

### FFI
FFIï¼ˆForeign Function Interfaceï¼‰å¯ä»¥ç”¨æ¥ä¸å…¶å®ƒè¯­è¨€è¿›è¡Œäº¤äº’ï¼Œä½†æ˜¯å¹¶ä¸æ˜¯æ‰€æœ‰è¯­è¨€éƒ½è¿™ä¹ˆç§°å‘¼ï¼Œä¾‹å¦‚ Java ç§°ä¹‹ä¸º JNIï¼ˆJava Native Interfaceï¼‰ã€‚

FFI ä¹‹æ‰€ä»¥å­˜åœ¨æ˜¯ç”±äºç°å®ä¸­å¾ˆå¤šä»£ç åº“éƒ½æ˜¯ç”±ä¸åŒè¯­è¨€ç¼–å†™çš„ï¼Œå¦‚æœæˆ‘ä»¬éœ€è¦ä½¿ç”¨æŸä¸ªåº“ï¼Œä½†æ˜¯å®ƒæ˜¯ç”±å…¶å®ƒè¯­è¨€ç¼–å†™çš„ï¼Œé‚£ä¹ˆå¾€å¾€åªæœ‰ä¸¤ä¸ªé€‰æ‹©ï¼š

- å¯¹è¯¥åº“è¿›è¡Œé‡å†™æˆ–è€…ç§»æ¤
- ä½¿ç”¨ FFI
unsafe çš„å¦ä¸€ä¸ªé‡è¦ç›®çš„å°±æ˜¯å¯¹ FFI æä¾›æ”¯æŒï¼Œå®ƒçš„å…¨ç§°æ˜¯ Foreign Function Interfaceï¼Œé¡¾åæ€ä¹‰ï¼Œé€šè¿‡ FFI , æˆ‘ä»¬çš„ Rust ä»£ç å¯ä»¥è·Ÿå…¶å®ƒè¯­è¨€çš„å¤–éƒ¨ä»£ç è¿›è¡Œäº¤äº’ã€‚
ä¸‹é¢çš„ä¾‹å­æ¼”ç¤ºäº†å¦‚ä½•è°ƒç”¨ C æ ‡å‡†åº“ä¸­çš„ abs å‡½æ•°ï¼š
```rs
extern "C" {
    fn abs(input: i32) -> i32;
}

fn main() {
    unsafe {
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }
}
```
#### ABI
åœ¨ extern "C" ä»£ç å—ä¸­ï¼Œæˆ‘ä»¬åˆ—å‡ºäº†æƒ³è¦è°ƒç”¨çš„å¤–éƒ¨å‡½æ•°çš„ç­¾åã€‚å…¶ä¸­ "C" å®šä¹‰äº†å¤–éƒ¨å‡½æ•°æ‰€ä½¿ç”¨çš„åº”ç”¨äºŒè¿›åˆ¶æ¥å£ABI (Application Binary Interface)ï¼šABI å®šä¹‰äº†å¦‚ä½•åœ¨æ±‡ç¼–å±‚é¢æ¥è°ƒç”¨è¯¥å‡½æ•°ã€‚åœ¨æ‰€æœ‰ ABI ä¸­ï¼ŒC è¯­è¨€çš„æ˜¯æœ€å¸¸è§çš„ã€‚

#### åœ¨å…¶å®ƒè¯­è¨€ä¸­è°ƒç”¨ Rust å‡½æ•°
æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ extern æ¥åˆ›å»ºä¸€ä¸ªæ¥å£ï¼Œå…¶å®ƒè¯­è¨€å¯ä»¥é€šè¿‡è¯¥æ¥å£æ¥è°ƒç”¨ç›¸å…³çš„ Rust å‡½æ•°ã€‚ä½†æ˜¯æ­¤å¤„çš„è¯­æ³•ä¸ä¹‹å‰æœ‰æ‰€ä¸åŒï¼Œä¹‹å‰ç”¨çš„æ˜¯è¯­å¥å—ï¼Œè€Œè¿™é‡Œæ˜¯åœ¨å‡½æ•°å®šä¹‰æ—¶åŠ ä¸Š extern å…³é”®å­—ï¼Œå½“ç„¶ï¼Œåˆ«å¿˜äº†æŒ‡å®šç›¸åº”çš„ ABIï¼š
```rs
#[no_mangle]
pub extern "C" fn call_from_c() {
    println!("Just called a Rust function from C!");
}
```
### å†…è”æ±‡ç¼–


ä¸Šé¢çš„ä»£ç å¯ä»¥è®© call_from_c å‡½æ•°è¢« C è¯­è¨€çš„ä»£ç è°ƒç”¨ï¼Œå½“ç„¶ï¼Œå‰ææ˜¯å°†å…¶ç¼–è¯‘æˆä¸€ä¸ªå…±äº«åº“ï¼Œç„¶åé“¾æ¥åˆ° C è¯­è¨€ä¸­ã€‚

è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªæ¯”è¾ƒå¥‡æ€ªçš„æ³¨è§£ #[no_mangle]ï¼Œå®ƒç”¨äºå‘Šè¯‰ Rust ç¼–è¯‘å™¨ï¼šä¸è¦ä¹±æ”¹å‡½æ•°çš„åç§°ã€‚ Mangling çš„å®šä¹‰æ˜¯ï¼šå½“ Rust å› ä¸ºç¼–è¯‘éœ€è¦å»ä¿®æ”¹å‡½æ•°çš„åç§°ï¼Œä¾‹å¦‚ä¸ºäº†è®©åç§°åŒ…å«æ›´å¤šçš„ä¿¡æ¯ï¼Œè¿™æ ·å…¶å®ƒçš„ç¼–è¯‘éƒ¨åˆ†å°±èƒ½ä»è¯¥åç§°è·å–ç›¸åº”çš„ä¿¡æ¯ï¼Œè¿™ç§ä¿®æ”¹ä¼šå¯¼è‡´å‡½æ•°åå˜å¾—ç›¸å½“ä¸å¯è¯»ã€‚å› æ­¤ï¼Œä¸ºäº†è®© Rust å‡½æ•°èƒ½é¡ºåˆ©è¢«å…¶å®ƒè¯­è¨€è°ƒç”¨ï¼Œæˆ‘ä»¬å¿…é¡»è¦ç¦æ­¢æ‰è¯¥åŠŸèƒ½ã€‚
## Macro å®ç¼–ç¨‹
åœ¨ Rust ä¸­å®åˆ†ä¸ºä¸¤å¤§ç±»ï¼šå£°æ˜å¼å®( declarative macros ) macro_rules! å’Œä¸‰ç§è¿‡ç¨‹å®( procedural macros ):

    - #[derive]ï¼Œåœ¨ä¹‹å‰å¤šæ¬¡è§åˆ°çš„æ´¾ç”Ÿå®ï¼Œå¯ä»¥ä¸ºç›®æ ‡ç»“æ„ä½“æˆ–æšä¸¾æ´¾ç”ŸæŒ‡å®šçš„ä»£ç ï¼Œä¾‹å¦‚ Debug ç‰¹å¾
    - ç±»å±æ€§å®(Attribute-like macro)ï¼Œç”¨äºä¸ºç›®æ ‡æ·»åŠ è‡ªå®šä¹‰çš„å±æ€§
    - ç±»å‡½æ•°å®(Function-like macro)ï¼Œçœ‹ä¸Šå»å°±åƒæ˜¯å‡½æ•°è°ƒç”¨
### å®å’Œå‡½æ•°çš„åŒºåˆ«
å…ƒç¼–ç¨‹
ä»æ ¹æœ¬ä¸Šæ¥è¯´ï¼Œå®æ˜¯é€šè¿‡ä¸€ç§ä»£ç æ¥ç”Ÿæˆå¦ä¸€ç§ä»£ç ï¼Œå¦‚æœå¤§å®¶ç†Ÿæ‚‰å…ƒç¼–ç¨‹ï¼Œå°±ä¼šå‘ç°ä¸¤è€…çš„å…±åŒç‚¹ã€‚
å¯å˜å‚æ•°
Rust çš„å‡½æ•°ç­¾åæ˜¯å›ºå®šçš„ï¼šå®šä¹‰äº†ä¸¤ä¸ªå‚æ•°ï¼Œå°±å¿…é¡»ä¼ å…¥ä¸¤ä¸ªå‚æ•°ï¼Œå¤šä¸€ä¸ªå°‘ä¸€ä¸ªéƒ½ä¸è¡Œï¼Œå¯¹äºä» JS/TS è¿‡æ¥çš„åŒå­¦ï¼Œè¿™ä¸€ç‚¹å…¶å®æ˜¯æœ‰äº›æ¼äººçš„ã€‚
å®å±•å¼€
ç”±äºå®ä¼šè¢«å±•å¼€æˆå…¶å®ƒä»£ç ï¼Œä¸”è¿™ä¸ªå±•å¼€è¿‡ç¨‹æ˜¯å‘ç”Ÿåœ¨ç¼–è¯‘å™¨å¯¹ä»£ç è¿›è¡Œè§£é‡Šä¹‹å‰ã€‚å› æ­¤ï¼Œå®å¯ä»¥ä¸ºæŒ‡å®šçš„ç±»å‹å®ç°æŸä¸ªç‰¹å¾ï¼šå…ˆå°†å®å±•å¼€æˆå®ç°ç‰¹å¾çš„ä»£ç åï¼Œå†è¢«ç¼–è¯‘ã€‚
ç›¸å¯¹å‡½æ•°æ¥è¯´ï¼Œç”±äºå®æ˜¯åŸºäºä»£ç å†å±•å¼€æˆä»£ç ï¼Œå› æ­¤å®ç°ç›¸æ¯”å‡½æ•°æ¥è¯´ä¼šæ›´åŠ å¤æ‚ï¼Œå†åŠ ä¸Šå®çš„è¯­æ³•æ›´ä¸ºå¤æ‚ï¼Œæœ€ç»ˆå¯¼è‡´å®šä¹‰å®çš„ä»£ç ç›¸å½“åœ°éš¾è¯»ï¼Œä¹Ÿéš¾ä»¥ç†è§£å’Œç»´æŠ¤ã€‚
```rs
#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
```

## å¼‚æ­¥ç¼–ç¨‹
### Async ç¼–ç¨‹ç®€ä»‹
- OS **çº¿ç¨‹**, å®ƒæœ€ç®€å•ï¼Œä¹Ÿæ— éœ€æ”¹å˜ä»»ä½•ç¼–ç¨‹æ¨¡å‹(ä¸šåŠ¡/ä»£ç é€»è¾‘)ï¼Œå› æ­¤éå¸¸é€‚åˆä½œä¸ºè¯­è¨€çš„åŸç”Ÿå¹¶å‘æ¨¡å‹ï¼Œæˆ‘ä»¬åœ¨å¤šçº¿ç¨‹ç« èŠ‚ä¹Ÿæåˆ°è¿‡ï¼ŒRust å°±é€‰æ‹©äº†åŸç”Ÿæ”¯æŒçº¿ç¨‹çº§çš„å¹¶å‘ç¼–ç¨‹ã€‚ä½†æ˜¯ï¼Œè¿™ç§æ¨¡å‹ä¹Ÿæœ‰ç¼ºç‚¹ï¼Œä¾‹å¦‚çº¿ç¨‹é—´çš„åŒæ­¥å°†å˜å¾—æ›´åŠ å›°éš¾ï¼Œçº¿ç¨‹é—´çš„ä¸Šä¸‹æ–‡åˆ‡æ¢æŸè€—è¾ƒå¤§ã€‚ä½¿ç”¨çº¿ç¨‹æ± åœ¨ä¸€å®šç¨‹åº¦ä¸Šå¯ä»¥æå‡æ€§èƒ½ï¼Œä½†æ˜¯å¯¹äº IO å¯†é›†çš„åœºæ™¯æ¥è¯´ï¼Œçº¿ç¨‹æ± è¿˜æ˜¯ä¸å¤Ÿã€‚
- **äº‹ä»¶é©±åŠ¨(Event driven)**,å¦‚æœè¯´äº‹ä»¶é©±åŠ¨å¸¸å¸¸è·Ÿå›è°ƒ( Callback )ä¸€èµ·ä½¿ç”¨ï¼Œç›¸ä¿¡å¤§å®¶å°±æç„¶å¤§æ‚Ÿäº†ã€‚è¿™ç§æ¨¡å‹æ€§èƒ½ç›¸å½“çš„å¥½ï¼Œä½†æœ€å¤§çš„é—®é¢˜å°±æ˜¯å­˜åœ¨å›è°ƒåœ°ç‹±çš„é£é™©ï¼šéçº¿æ€§çš„æ§åˆ¶æµå’Œç»“æœå¤„ç†å¯¼è‡´äº†æ•°æ®æµå‘å’Œé”™è¯¯ä¼ æ’­å˜å¾—éš¾ä»¥æŒæ§ï¼Œè¿˜ä¼šå¯¼è‡´ä»£ç å¯ç»´æŠ¤æ€§å’Œå¯è¯»æ€§çš„å¤§å¹…é™ä½ã€‚
- **åç¨‹(Coroutines)** Go è¯­è¨€çš„åç¨‹è®¾è®¡å°±éå¸¸ä¼˜ç§€ï¼Œè¿™ä¹Ÿæ˜¯ Go è¯­è¨€èƒ½å¤Ÿè¿…é€Ÿç«éå…¨çƒçš„æ€æ‰‹é”ä¹‹ä¸€ã€‚åç¨‹è·Ÿçº¿ç¨‹ç±»ä¼¼ï¼Œæ— éœ€æ”¹å˜ç¼–ç¨‹æ¨¡å‹ï¼ŒåŒæ—¶ï¼Œå®ƒä¹Ÿè·Ÿ async ç±»ä¼¼ï¼Œå¯ä»¥æ”¯æŒå¤§é‡çš„ä»»åŠ¡å¹¶å‘è¿è¡Œã€‚ä½†åç¨‹æŠ½è±¡å±‚æ¬¡è¿‡é«˜ï¼Œå¯¼è‡´ç”¨æˆ·æ— æ³•æ¥è§¦åˆ°åº•å±‚çš„ç»†èŠ‚ï¼Œè¿™å¯¹äºç³»ç»Ÿç¼–ç¨‹è¯­è¨€å’Œè‡ªå®šä¹‰å¼‚æ­¥è¿è¡Œæ—¶æ˜¯éš¾ä»¥æ¥å—çš„
- **actor** æ¨¡å‹æ˜¯ erlang çš„æ€æ‰‹é”ä¹‹ä¸€ï¼Œå®ƒå°†æ‰€æœ‰å¹¶å‘è®¡ç®—åˆ†å‰²æˆä¸€ä¸ªä¸€ä¸ªå•å…ƒï¼Œè¿™äº›å•å…ƒè¢«ç§°ä¸º actor , å•å…ƒä¹‹é—´é€šè¿‡æ¶ˆæ¯ä¼ é€’çš„æ–¹å¼è¿›è¡Œé€šä¿¡å’Œæ•°æ®ä¼ é€’ï¼Œè·Ÿåˆ†å¸ƒå¼ç³»ç»Ÿçš„è®¾è®¡ç†å¿µéå¸¸ç›¸åƒã€‚ç”±äº actor æ¨¡å‹è·Ÿç°å®å¾ˆè´´è¿‘ï¼Œå› æ­¤å®ƒç›¸å¯¹æ¥è¯´æ›´å®¹æ˜“å®ç°ï¼Œä½†æ˜¯ä¸€æ—¦é‡åˆ°æµæ§åˆ¶ã€å¤±è´¥é‡è¯•ç­‰åœºæ™¯æ—¶ï¼Œå°±ä¼šå˜å¾—ä¸å¤ªå¥½ç”¨
- **async/await**ï¼Œ è¯¥æ¨¡å‹æ€§èƒ½é«˜ï¼Œè¿˜èƒ½æ”¯æŒåº•å±‚ç¼–ç¨‹ï¼ŒåŒæ—¶åˆåƒçº¿ç¨‹å’Œåç¨‹é‚£æ ·æ— éœ€è¿‡å¤šçš„æ”¹å˜ç¼–ç¨‹æ¨¡å‹ï¼Œä½†æœ‰å¾—å¿…æœ‰å¤±ï¼Œasync æ¨¡å‹çš„é—®é¢˜å°±æ˜¯å†…éƒ¨å®ç°æœºåˆ¶è¿‡äºå¤æ‚ï¼Œå¯¹äºç”¨æˆ·æ¥è¯´ï¼Œç†è§£å’Œä½¿ç”¨èµ·æ¥ä¹Ÿæ²¡æœ‰çº¿ç¨‹å’Œåç¨‹ç®€å•ï¼Œå¥½åœ¨å‰è€…çš„å¤æ‚æ€§å¼€å‘è€…ä»¬å·²ç»å¸®æˆ‘ä»¬å°è£…å¥½ï¼Œè€Œç†è§£å’Œä½¿ç”¨èµ·æ¥ä¸å¤Ÿç®€å•ã€‚

å¯¹äºé•¿æ—¶é—´è¿è¡Œçš„ CPU å¯†é›†å‹ä»»åŠ¡ï¼Œä¾‹å¦‚å¹¶è¡Œè®¡ç®—ï¼Œä½¿ç”¨çº¿ç¨‹å°†æ›´æœ‰ä¼˜åŠ¿ã€‚ è¿™ç§å¯†é›†ä»»åŠ¡å¾€å¾€ä¼šè®©æ‰€åœ¨çš„çº¿ç¨‹æŒç»­è¿è¡Œï¼Œä»»ä½•ä¸å¿…è¦çš„çº¿ç¨‹åˆ‡æ¢éƒ½ä¼šå¸¦æ¥æ€§èƒ½æŸè€—ï¼Œå› æ­¤é«˜å¹¶å‘åè€Œåœ¨æ­¤æ—¶æˆä¸ºäº†ä¸€ç§å¤šä½™ã€‚åŒæ—¶ä½ æ‰€åˆ›å»ºçš„çº¿ç¨‹æ•°åº”è¯¥ç­‰äº CPU æ ¸å¿ƒæ•°ï¼Œå……åˆ†åˆ©ç”¨ CPU çš„å¹¶è¡Œèƒ½åŠ›ï¼Œç”šè‡³è¿˜å¯ä»¥å°†çº¿ç¨‹ç»‘å®šåˆ° CPU æ ¸å¿ƒä¸Šï¼Œè¿›ä¸€æ­¥å‡å°‘çº¿ç¨‹ä¸Šä¸‹æ–‡åˆ‡æ¢ã€‚

è€Œé«˜å¹¶å‘æ›´é€‚åˆ IO å¯†é›†å‹ä»»åŠ¡ï¼Œä¾‹å¦‚ web æœåŠ¡å™¨ã€æ•°æ®åº“è¿æ¥ç­‰ç­‰ç½‘ç»œæœåŠ¡ï¼Œå› ä¸ºè¿™äº›ä»»åŠ¡ç»å¤§éƒ¨åˆ†æ—¶é—´éƒ½å¤„äºç­‰å¾…çŠ¶æ€ï¼Œå¦‚æœä½¿ç”¨å¤šçº¿ç¨‹ï¼Œé‚£çº¿ç¨‹å¤§é‡æ—¶é—´ä¼šå¤„äºæ— æ‰€äº‹äº‹çš„çŠ¶æ€ï¼Œå†åŠ ä¸Šçº¿ç¨‹ä¸Šä¸‹æ–‡åˆ‡æ¢çš„é«˜æ˜‚ä»£ä»·ï¼Œè®©å¤šçº¿ç¨‹åš IO å¯†é›†ä»»åŠ¡å˜æˆäº†ä¸€ä»¶éå¸¸å¥¢ä¾ˆçš„äº‹ã€‚è€Œä½¿ç”¨asyncï¼Œæ—¢å¯ä»¥æœ‰æ•ˆçš„é™ä½ CPU å’Œå†…å­˜çš„è´Ÿæ‹…ï¼Œåˆå¯ä»¥è®©å¤§é‡çš„ä»»åŠ¡å¹¶å‘çš„è¿è¡Œï¼Œä¸€ä¸ªä»»åŠ¡ä¸€æ—¦å¤„äºIOæˆ–è€…å…¶ä»–ç­‰å¾…(é˜»å¡)çŠ¶æ€ï¼Œå°±ä¼šè¢«ç«‹åˆ»åˆ‡èµ°å¹¶æ‰§è¡Œå¦ä¸€ä¸ªä»»åŠ¡ï¼Œè€Œè¿™é‡Œçš„ä»»åŠ¡åˆ‡æ¢çš„æ€§èƒ½å¼€é”€è¦è¿œè¿œä½äºä½¿ç”¨å¤šçº¿ç¨‹æ—¶çš„çº¿ç¨‹ä¸Šä¸‹æ–‡åˆ‡æ¢ã€‚
#### async/.await ç®€å•å…¥é—¨
async/.await æ˜¯ Rust å†…ç½®çš„è¯­è¨€ç‰¹æ€§ï¼Œå¯ä»¥è®©æˆ‘ä»¬ç”¨åŒæ­¥çš„æ–¹å¼å»ç¼–å†™å¼‚æ­¥çš„ä»£ç ã€‚
é€šè¿‡ async æ ‡è®°çš„è¯­æ³•å—ä¼šè¢«è½¬æ¢æˆå®ç°äº†Futureç‰¹å¾çš„çŠ¶æ€æœºã€‚ ä¸åŒæ­¥è°ƒç”¨é˜»å¡å½“å‰çº¿ç¨‹ä¸åŒï¼Œå½“Futureæ‰§è¡Œå¹¶é‡åˆ°é˜»å¡æ—¶ï¼Œå®ƒä¼šè®©å‡ºå½“å‰çº¿ç¨‹çš„æ§åˆ¶æƒï¼Œè¿™æ ·å…¶å®ƒçš„Futureå°±å¯ä»¥åœ¨è¯¥çº¿ç¨‹ä¸­è¿è¡Œï¼Œè¿™ç§æ–¹å¼å®Œå…¨ä¸ä¼šå¯¼è‡´å½“å‰çº¿ç¨‹çš„é˜»å¡ã€‚
ä¸‹é¢æˆ‘ä»¬æ¥é€šè¿‡ä¾‹å­å­¦ä¹  async/.await å…³é”®å­—è¯¥å¦‚ä½•ä½¿ç”¨ï¼Œåœ¨å¼€å§‹ä¹‹å‰ï¼Œéœ€è¦å…ˆå¼•å…¥ futures åŒ…ã€‚ç¼–è¾‘ Cargo.toml æ–‡ä»¶å¹¶æ·»åŠ ä»¥ä¸‹å†…å®¹:
```toml
[dependencies]
futures = "0.3"
```
```rs
// `block_on`ä¼šé˜»å¡å½“å‰çº¿ç¨‹ç›´åˆ°æŒ‡å®šçš„`Future`æ‰§è¡Œå®Œæˆï¼Œè¿™ç§é˜»å¡å½“å‰çº¿ç¨‹ä»¥ç­‰å¾…ä»»åŠ¡å®Œæˆçš„æ–¹å¼è¾ƒä¸ºç®€å•ã€ç²—æš´ï¼Œ
// å¥½åœ¨å…¶å®ƒè¿è¡Œæ—¶çš„æ‰§è¡Œå™¨(executor)ä¼šæä¾›æ›´åŠ å¤æ‚çš„è¡Œä¸ºï¼Œä¾‹å¦‚å°†å¤šä¸ª`future`è°ƒåº¦åˆ°åŒä¸€ä¸ªçº¿ç¨‹ä¸Šæ‰§è¡Œã€‚
use futures::executor::block_on;

async fn hello_world() {
    hello_cat().await;//ç­‰å¾…å¼‚æ­¥æ–¹æ³•å®Œæˆ
    println!("hello, world!");
}

async fn hello_cat() {
    println!("hello, kitty!");
}
fn main() {
    let future = hello_world(); // è¿”å›ä¸€ä¸ªFuture, å› æ­¤ä¸ä¼šæ‰“å°ä»»ä½•è¾“å‡º
    block_on(future); // æ‰§è¡Œ`Future`å¹¶ç­‰å¾…å…¶è¿è¡Œå®Œæˆï¼Œæ­¤æ—¶"hello, world!"ä¼šè¢«æ‰“å°è¾“å‡º
}
```
æ€»ä¹‹ï¼Œåœ¨async fnå‡½æ•°ä¸­ä½¿ç”¨.awaitå¯ä»¥ç­‰å¾…å¦ä¸€ä¸ªå¼‚æ­¥è°ƒç”¨çš„å®Œæˆã€‚ä½†æ˜¯ä¸block_onä¸åŒï¼Œ.awaitå¹¶ä¸ä¼šé˜»å¡å½“å‰çš„çº¿ç¨‹ï¼Œè€Œæ˜¯å¼‚æ­¥çš„ç­‰å¾…Future Açš„å®Œæˆï¼Œåœ¨ç­‰å¾…çš„è¿‡ç¨‹ä¸­ï¼Œè¯¥çº¿ç¨‹è¿˜å¯ä»¥ç»§ç»­æ‰§è¡Œå…¶å®ƒçš„Future Bï¼Œæœ€ç»ˆå®ç°äº†å¹¶å‘å¤„ç†çš„æ•ˆæœã€‚

###  Future æ‰§è¡Œå™¨ä¸ä»»åŠ¡è°ƒåº¦
#### Future ç‰¹å¾
é¦–å…ˆï¼Œæ¥ç»™å‡º Future çš„å®šä¹‰ï¼šå®ƒæ˜¯ä¸€ä¸ªèƒ½äº§å‡ºå€¼çš„å¼‚æ­¥è®¡ç®—(è™½ç„¶è¯¥å€¼å¯èƒ½ä¸ºç©ºï¼Œä¾‹å¦‚ () )ã€‚å…‰çœ‹è¿™ä¸ªå®šä¹‰ï¼Œä¸€ä¸ªç®€åŒ–ç‰ˆçš„ Future ç‰¹å¾:
```rs
trait SimpleFuture {
    // è®¾ç½®å…³è”ç±»å‹
    type Output;
    // è¾“å‡ºè®¡ç®—å®Œæˆçš„ç»“æœæˆ–è€…è¾“å‡ºPendingè¡¨ç¤ºæœ¬æ¬¡ä¸èƒ½å¤Ÿå®Œæˆè®¡ç®—
    fn poll(&mut self, wake: fn()) -> Poll<Self::Output>;
}

// Future éœ€è¦è¢«æ‰§è¡Œå™¨poll(è½®è¯¢)åæ‰èƒ½è¿è¡Œï¼Œå¹¶ä¸èƒ½ä¿è¯åœ¨ä¸€æ¬¡ poll ä¸­å°±è¢«æ‰§è¡Œå®Œï¼Œ
enum Poll<T> {
    Ready(T),
    Pending,
}
```
è‹¥åœ¨å½“å‰ poll ä¸­ï¼Œ Future å¯ä»¥è¢«å®Œæˆï¼Œåˆ™ä¼šè¿”å› Poll::Ready(result) ï¼Œåä¹‹åˆ™è¿”å› Poll::Pendingï¼Œ å¹¶ä¸”å®‰æ’ä¸€ä¸ª wake å‡½æ•°ï¼šå½“æœªæ¥ Future å‡†å¤‡å¥½è¿›ä¸€æ­¥æ‰§è¡Œæ—¶ï¼Œ è¯¥å‡½æ•°ä¼šè¢«è°ƒç”¨ï¼Œç„¶åç®¡ç†è¯¥ Future çš„æ‰§è¡Œå™¨ä¼šå†æ¬¡è°ƒç”¨ poll æ–¹æ³•ï¼Œæ­¤æ—¶ Future å°±å¯ä»¥ç»§ç»­æ‰§è¡Œäº†ã€‚

ç”¨ä¸€ä¸ªä¾‹å­æ¥è¯´æ˜ä¸‹ã€‚è€ƒè™‘ä¸€ä¸ªéœ€è¦ä» socket è¯»å–æ•°æ®çš„åœºæ™¯ï¼šå¦‚æœæœ‰æ•°æ®ï¼Œå¯ä»¥ç›´æ¥è¯»å–æ•°æ®å¹¶è¿”å› Poll::Ready(data)ï¼Œ ä½†å¦‚æœæ²¡æœ‰æ•°æ®ï¼ŒFuture ä¼šè¢«é˜»å¡ä¸”ä¸ä¼šå†ç»§ç»­æ‰§è¡Œï¼Œæ­¤æ—¶å®ƒä¼šæ³¨å†Œä¸€ä¸ª wake å‡½æ•°ï¼Œå½“ socket æ•°æ®å‡†å¤‡å¥½æ—¶ï¼Œè¯¥å‡½æ•°å°†è¢«è°ƒç”¨ä»¥é€šçŸ¥æ‰§è¡Œå™¨ï¼šæˆ‘ä»¬çš„ Future å·²ç»å‡†å¤‡å¥½äº†ï¼Œå¯ä»¥ç»§ç»­æ‰§è¡Œã€‚
```rs
pub struct SocketRead<'a> {
    socket: &'a Socket,
}

impl SimpleFuture for SocketRead<'_> {
    type Output = Vec<u8>;

    fn poll(&mut self, wake: fn()) -> Poll<Self::Output> {
        if self.socket.has_data_to_read() {
            // socketæœ‰æ•°æ®ï¼Œå†™å…¥bufferä¸­å¹¶è¿”å›
            Poll::Ready(self.socket.read_buf())
        } else {
            // socketä¸­è¿˜æ²¡æ•°æ®
            // æ³¨å†Œä¸€ä¸ª`wake`å‡½æ•°ï¼Œå½“æ•°æ®å¯ç”¨æ—¶ï¼Œè¯¥å‡½æ•°ä¼šè¢«è°ƒç”¨ï¼Œ
            // ç„¶åå½“å‰Futureçš„æ‰§è¡Œå™¨ä¼šå†æ¬¡è°ƒç”¨`poll`æ–¹æ³•ï¼Œæ­¤æ—¶å°±å¯ä»¥è¯»å–åˆ°æ•°æ®
            self.socket.set_readable_callback(wake);
            Poll::Pending
        }
    }
}
```

Future æ¨¡å‹å…è®¸å°†**å¤šä¸ªå¼‚æ­¥**æ“ä½œç»„åˆåœ¨ä¸€èµ·ï¼ŒåŒæ—¶è¿˜æ— éœ€ä»»ä½•å†…å­˜åˆ†é…ã€‚ä¸ä»…ä»…å¦‚æ­¤ï¼Œå¦‚æœä½ éœ€è¦åŒæ—¶è¿è¡Œå¤šä¸ª Futureæˆ–é“¾å¼è°ƒç”¨å¤šä¸ª Future ï¼Œä¹Ÿå¯ä»¥é€šè¿‡æ— å†…å­˜åˆ†é…çš„çŠ¶æ€æœºå®ç°ï¼Œä¾‹å¦‚ï¼š
```rs

trait SimpleFuture {
    // å…³è”ç±»å‹æ˜¯ trait å®šä¹‰ä¸­çš„ç±»å‹å ä½ç¬¦ã€‚å®šä¹‰çš„æ—¶å€™ï¼Œå¹¶ä¸å®šä¹‰å®ƒçš„å…·ä½“çš„ç±»å‹æ˜¯ä»€ä¹ˆã€‚åœ¨ impl è¿™ä¸ª trait çš„æ—¶å€™ï¼Œæ‰ä¸ºè¿™ä¸ªå…³è”ç±»å‹èµ‹äºˆç¡®å®šçš„ç±»å‹ã€‚
    type Output;//å…³è”ç±»å‹
    fn poll(&mut self, wake: fn()) -> Poll<Self::Output>;
}

enum Poll<T> {
    Ready(T),
    Pending,
}

/// ä¸€ä¸ªSimpleFutureï¼Œå®ƒä¼šå¹¶å‘åœ°è¿è¡Œä¸¤ä¸ªFutureç›´åˆ°å®ƒä»¬å®Œæˆ
///
/// ä¹‹æ‰€ä»¥å¯ä»¥å¹¶å‘ï¼Œæ˜¯å› ä¸ºä¸¤ä¸ªFutureçš„è½®è¯¢å¯ä»¥äº¤æ›¿è¿›è¡Œï¼Œä¸€ä¸ªé˜»å¡ï¼Œå¦ä¸€ä¸ªå°±å¯ä»¥ç«‹åˆ»æ‰§è¡Œï¼Œåä¹‹äº¦ç„¶
pub struct Join<FutureA, FutureB> {
    // ç»“æ„ä½“çš„æ¯ä¸ªå­—æ®µéƒ½åŒ…å«ä¸€ä¸ªFutureï¼Œå¯ä»¥è¿è¡Œç›´åˆ°å®Œæˆ.
    // ç­‰åˆ°Futureå®Œæˆåï¼Œå­—æ®µä¼šè¢«è®¾ç½®ä¸º `None`. è¿™æ ·Futureå®Œæˆåï¼Œå°±ä¸ä¼šå†è¢«è½®è¯¢
    a: Option<FutureA>,
    b: Option<FutureB>,
}

impl<FutureA, FutureB> SimpleFuture for Join<FutureA, FutureB>
where
    FutureA: SimpleFuture<Output = ()>,
    FutureB: SimpleFuture<Output = ()>,
{
    type Output = ();
    fn poll(&mut self, wake: fn()) -> Poll<Self::Output> {
        // å°è¯•å»å®Œæˆä¸€ä¸ª Future `a`
        if let Some(a) = &mut self.a {
            if let Poll::Ready(()) = a.poll(wake) {
                self.a.take();
            }
        }

        // å°è¯•å»å®Œæˆä¸€ä¸ª Future `b`
        if let Some(b) = &mut self.b {
            if let Poll::Ready(()) = b.poll(wake) {
                self.b.take();
            }
        }

        if self.a.is_none() && self.b.is_none() {
            // ä¸¤ä¸ª Futureéƒ½å·²å®Œæˆ - æˆ‘ä»¬å¯ä»¥æˆåŠŸåœ°è¿”å›äº†
            Poll::Ready(())
        } else {
            // è‡³å°‘è¿˜æœ‰ä¸€ä¸ª Future æ²¡æœ‰å®Œæˆä»»åŠ¡ï¼Œå› æ­¤è¿”å› `Poll::Pending`.
            // å½“è¯¥ Future å†æ¬¡å‡†å¤‡å¥½æ—¶ï¼Œé€šè¿‡è°ƒç”¨`wake()`å‡½æ•°æ¥ç»§ç»­æ‰§è¡Œ
            Poll::Pending
        }
    }
}
```

ä¸Šé¢ä»£ç å±•ç¤ºäº†å¦‚ä½•åŒæ—¶è¿è¡Œå¤šä¸ª Futureï¼Œ ä¸”åœ¨æ­¤è¿‡ç¨‹ä¸­æ²¡æœ‰ä»»ä½•å†…å­˜åˆ†é…ï¼Œè®©å¹¶å‘ç¼–ç¨‹æ›´åŠ é«˜æ•ˆã€‚ ç±»ä¼¼çš„ï¼Œå¤šä¸ªFutureä¹Ÿå¯ä»¥ä¸€ä¸ªæ¥ä¸€ä¸ªçš„è¿ç»­è¿è¡Œï¼š
```rs
/// ä¸€ä¸ªSimpleFuture, å®ƒä½¿ç”¨é¡ºåºçš„æ–¹å¼ï¼Œä¸€ä¸ªæ¥ä¸€ä¸ªåœ°è¿è¡Œä¸¤ä¸ªFuture
//
// è€ŒçœŸå®çš„`Andthen`å…è®¸æ ¹æ®ç¬¬ä¸€ä¸ª`Future`çš„è¾“å‡ºæ¥åˆ›å»ºç¬¬äºŒä¸ª`Future`ï¼Œå› æ­¤å¤æ‚çš„å¤šã€‚
pub struct AndThenFut<FutureA, FutureB> {
    first: Option<FutureA>,
    second: FutureB,
}

impl<FutureA, FutureB> SimpleFuture for AndThenFut<FutureA, FutureB>
where
    FutureA: SimpleFuture<Output = ()>,
    FutureB: SimpleFuture<Output = ()>,
{
    type Output = ();
    fn poll(&mut self, wake: fn()) -> Poll<Self::Output> {
        if let Some(first) = &mut self.first {
            match first.poll(wake) {
                // æˆ‘ä»¬å·²ç»å®Œæˆäº†ç¬¬ä¸€ä¸ª Futureï¼Œ å¯ä»¥å°†å®ƒç§»é™¤ï¼Œ ç„¶åå‡†å¤‡å¼€å§‹è¿è¡Œç¬¬äºŒä¸ª
                Poll::Ready(()) => self.first.take(),
                // ç¬¬ä¸€ä¸ª Future è¿˜ä¸èƒ½å®Œæˆ
                Poll::Pending => return Poll::Pending,
            };
        }

        // è¿è¡Œåˆ°è¿™é‡Œï¼Œè¯´æ˜ç¬¬ä¸€ä¸ªFutureå·²ç»å®Œæˆï¼Œå°è¯•å»å®Œæˆç¬¬äºŒä¸ª
        self.second.poll(wake)
    }
}

```

è¿™äº›ä¾‹å­å±•ç¤ºäº†åœ¨ä¸éœ€è¦å†…å­˜å¯¹è±¡åˆ†é…ä»¥åŠæ·±å±‚åµŒå¥—å›è°ƒçš„æƒ…å†µä¸‹ï¼Œè¯¥å¦‚ä½•ä½¿ç”¨ Future ç‰¹å¾å»è¡¨è¾¾å¼‚æ­¥æ§åˆ¶æµã€‚ åœ¨äº†è§£äº†åŸºç¡€çš„æ§åˆ¶æµåï¼Œæˆ‘ä»¬å†æ¥çœ‹çœ‹çœŸå®çš„ Future ç‰¹å¾æœ‰ä½•ä¸åŒä¹‹å¤„ã€‚
```rs
trait Future {
    type Output;
    fn poll(
        // é¦–å…ˆå€¼å¾—æ³¨æ„çš„åœ°æ–¹æ˜¯ï¼Œ`self`çš„ç±»å‹ä»`&mut self`å˜æˆäº†`Pin<&mut Self>`:
        self: Pin<&mut Self>,
        // å…¶æ¬¡å°†`wake: fn()` ä¿®æ”¹ä¸º `cx: &mut Context<'_>`:
        cx: &mut Context<'_>,
    ) -> Poll<Self::Output>;
}

```

é¦–å…ˆè¿™é‡Œå¤šäº†ä¸€ä¸ª Pin ï¼Œç°åœ¨ä½ åªéœ€è¦çŸ¥é“ä½¿ç”¨å®ƒå¯ä»¥åˆ›å»ºä¸€ä¸ªæ— æ³•è¢«ç§»åŠ¨çš„ Future ï¼Œå› ä¸ºæ— æ³•è¢«ç§»åŠ¨ï¼Œæ‰€ä»¥å®ƒå°†å…·æœ‰å›ºå®šçš„å†…å­˜åœ°å€ï¼Œæ„å‘³ç€æˆ‘ä»¬å¯ä»¥å­˜å‚¨å®ƒçš„æŒ‡é’ˆ(å¦‚æœå†…å­˜åœ°å€å¯èƒ½ä¼šå˜åŠ¨ï¼Œé‚£å­˜å‚¨æŒ‡é’ˆåœ°å€å°†æ¯«æ— æ„ä¹‰ï¼)ï¼Œä¹Ÿæ„å‘³ç€å¯ä»¥å®ç°ä¸€ä¸ªè‡ªå¼•ç”¨æ•°æ®ç»“æ„: struct MyFut { a: i32, ptr_to_a: *const i32 }ã€‚ 

å…¶æ¬¡ï¼Œä» wake: fn() å˜æˆäº† &mut Context<'_> ã€‚æ„å‘³ç€ wake å‡½æ•°å¯ä»¥æºå¸¦æ•°æ®äº†ã€‚

#### ä½¿ç”¨ Waker æ¥å”¤é†’ä»»åŠ¡
å¯¹äº Future æ¥è¯´ï¼Œç¬¬ä¸€æ¬¡è¢« poll æ—¶æ— æ³•å®Œæˆä»»åŠ¡æ˜¯å¾ˆæ­£å¸¸çš„ã€‚ä½†å®ƒéœ€è¦ç¡®ä¿åœ¨æœªæ¥ä¸€æ—¦å‡†å¤‡å¥½æ—¶ï¼Œå¯ä»¥é€šçŸ¥æ‰§è¡Œå™¨å†æ¬¡å¯¹å…¶è¿›è¡Œ poll è¿›è€Œç»§ç»­å¾€ä¸‹æ‰§è¡Œï¼Œè¯¥é€šçŸ¥å°±æ˜¯é€šè¿‡ Waker ç±»å‹å®Œæˆçš„ã€‚

Waker æä¾›äº†ä¸€ä¸ª wake() æ–¹æ³•å¯ä»¥ç”¨äºå‘Šè¯‰æ‰§è¡Œå™¨ï¼šç›¸å…³çš„ä»»åŠ¡å¯ä»¥è¢«å”¤é†’äº†ï¼Œæ­¤æ—¶æ‰§è¡Œå™¨å°±å¯ä»¥å¯¹ç›¸åº”çš„ Future å†æ¬¡è¿›è¡Œ poll æ“ä½œã€‚

#### æ„å»ºä¸€ä¸ªå®šæ—¶å™¨
ä¸‹é¢ä¸€èµ·æ¥å®ç°ä¸€ä¸ªç®€å•çš„å®šæ—¶å™¨ Future ã€‚ä¸ºäº†è®©ä¾‹å­å°½é‡ç®€å•ï¼Œå½“è®¡æ—¶å™¨åˆ›å»ºæ—¶ï¼Œæˆ‘ä»¬ä¼šå¯åŠ¨ä¸€ä¸ªçº¿ç¨‹æ¥ç€è®©è¯¥çº¿ç¨‹è¿›å…¥ç¡çœ ï¼Œç­‰ç¡çœ ç»“æŸåå†é€šçŸ¥ç»™ Future ã€‚

æ³¨æ„æœ¬ä¾‹å­è¿˜ä¼šåœ¨åé¢ç»§ç»­ä½¿ç”¨ï¼Œå› æ­¤æˆ‘ä»¬é‡æ–°åˆ›å»ºä¸€ä¸ªå·¥ç¨‹æ¥æ¼”ç¤ºï¼šä½¿ç”¨ cargo new --lib timer_future æ¥åˆ›å»ºä¸€ä¸ªæ–°å·¥ç¨‹ï¼Œåœ¨ lib åŒ…çš„æ ¹è·¯å¾„ src/lib.rs ä¸­æ·»åŠ ä»¥ä¸‹å†…å®¹ï¼š
```rs
use std::{
    future::Future,
    pin::Pin,
    sync::{Arc, Mutex},
    task::{Context, Poll, Waker},
    thread,
    time::Duration,
};
```

ç»§ç»­æ¥å®ç° Future å®šæ—¶å™¨ï¼Œä¹‹å‰æåˆ°: æ–°å»ºçº¿ç¨‹åœ¨ç¡çœ ç»“æŸåä¼šéœ€è¦å°†çŠ¶æ€åŒæ­¥ç»™å®šæ—¶å™¨ Future ï¼Œç”±äºæ˜¯å¤šçº¿ç¨‹ç¯å¢ƒï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨ Arc/<Mutex/><T/>/> æ¥ä½œä¸ºä¸€ä¸ªå…±äº«çŠ¶æ€ï¼Œç”¨äºåœ¨æ–°çº¿ç¨‹å’Œ Future å®šæ—¶å™¨é—´å…±äº«ã€‚
```rs
pub struct TimerFuture {
    // Arcæ˜¯ä¸€ç§èƒ½å¤Ÿä½¿å¾—æ•°æ®åœ¨çº¿ç¨‹é—´å®‰å…¨å…±äº«çš„æ™ºèƒ½æŒ‡é’ˆ.å®ƒçš„å·¥ä½œæ–¹å¼ä»æœ¬è´¨ä¸Šæ¥è®²ï¼Œæ˜¯å¯¹å°†è¦å…±äº«çš„æ•°æ®è¿›è¡ŒåŒ…è£…ï¼Œå¹¶è¡¨ç°ä¸ºæ­¤æ•°æ®çš„ä¸€ä¸ªæŒ‡é’ˆã€‚
    // Arcä¼šè¿½è¸ªè¿™ä¸ªæŒ‡é’ˆçš„æ‰€æœ‰æ‹·è´ï¼Œå½“æœ€åä¸€ä»½æ‹·è´ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå®ƒå°±ä¼šå®‰å…¨é‡Šæ”¾å†…å­˜ã€‚
    shared_state: Arc<Mutex<SharedState>>,
}

/// åœ¨Futureå’Œç­‰å¾…çš„çº¿ç¨‹é—´å…±äº«çŠ¶æ€
struct SharedState {
    /// å®šæ—¶(ç¡çœ )æ˜¯å¦ç»“æŸ
    completed: bool,

    /// å½“ç¡çœ ç»“æŸåï¼Œçº¿ç¨‹å¯ä»¥ç”¨`waker`é€šçŸ¥`TimerFuture`æ¥å”¤é†’ä»»åŠ¡
    waker: Option<Waker>,
}
```

ä¸‹é¢ç»™å‡º Future çš„å…·ä½“å®ç°:
```rs
impl Future for TimerFuture {
    type Output = ();
    // å‡½æ•°æ²¡æœ‰è¿”å›å€¼ï¼Œé‚£ä¹ˆè¿”å›ä¸€ä¸ª ()
   // é€šè¿‡ ; ç»“å°¾çš„è¡¨è¾¾å¼è¿”å›ä¸€ä¸ª ()
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        // é€šè¿‡æ£€æŸ¥å…±äº«çŠ¶æ€ï¼Œæ¥ç¡®å®šå®šæ—¶å™¨æ˜¯å¦å·²ç»å®Œæˆ
        let mut shared_state = self.shared_state.lock().unwrap();
        if shared_state.completed {
            // è®¡ç®—å®Œæˆï¼Œå¼¹å‡ºè®¡ç®—æ•°æ®
            Poll::Ready(())
        } else {
            // è®¾ç½®`waker`ï¼Œè¿™æ ·æ–°çº¿ç¨‹åœ¨ç¡çœ (è®¡æ—¶)ç»“æŸåå¯ä»¥å”¤é†’å½“å‰çš„ä»»åŠ¡ï¼Œæ¥ç€å†æ¬¡å¯¹`Future`è¿›è¡Œ`poll`æ“ä½œ,
            // ä¸‹é¢çš„`clone`æ¯æ¬¡è¢«`poll`æ—¶éƒ½ä¼šå‘ç”Ÿä¸€æ¬¡ï¼Œå®é™…ä¸Šï¼Œåº”è¯¥æ˜¯åª`clone`ä¸€æ¬¡æ›´åŠ åˆç†ã€‚
            // é€‰æ‹©æ¯æ¬¡éƒ½`clone`çš„åŸå› æ˜¯ï¼š `TimerFuture`å¯ä»¥åœ¨æ‰§è¡Œå™¨çš„ä¸åŒä»»åŠ¡é—´ç§»åŠ¨ï¼Œå¦‚æœåªå…‹éš†ä¸€æ¬¡ï¼Œ
            // é‚£ä¹ˆè·å–åˆ°çš„`waker`å¯èƒ½å·²ç»è¢«ç¯¡æ”¹å¹¶æŒ‡å‘äº†å…¶å®ƒä»»åŠ¡ï¼Œæœ€ç»ˆå¯¼è‡´æ‰§è¡Œå™¨è¿è¡Œäº†é”™è¯¯çš„ä»»åŠ¡
            shared_state.waker = Some(cx.waker().clone());
            // è®¾ç½®pendingçŠ¶æ€
            Poll::Pending
        }
    }
}
```

ä»£ç å¾ˆç®€å•ï¼Œåªè¦æ–°çº¿ç¨‹è®¾ç½®äº† shared_state.completed = true ï¼Œé‚£ä»»åŠ¡å°±èƒ½é¡ºåˆ©ç»“æŸã€‚å¦‚æœæ²¡æœ‰è®¾ç½®ï¼Œä¼šä¸ºå½“å‰çš„ä»»åŠ¡å…‹éš†ä¸€ä»½ Waker ï¼Œè¿™æ ·æ–°çº¿ç¨‹å°±å¯ä»¥ä½¿ç”¨å®ƒæ¥å”¤é†’å½“å‰çš„ä»»åŠ¡ã€‚

æœ€åï¼Œå†æ¥åˆ›å»ºä¸€ä¸ª API ç”¨äºæ„å»ºå®šæ—¶å™¨å’Œå¯åŠ¨è®¡æ—¶çº¿ç¨‹:
```rs
impl TimerFuture {
    /// åˆ›å»ºä¸€ä¸ªæ–°çš„`TimerFuture`ï¼Œåœ¨æŒ‡å®šçš„æ—¶é—´ç»“æŸåï¼Œè¯¥`Future`å¯ä»¥å®Œæˆ
    pub fn new(duration: Duration) -> Self {
        let shared_state = Arc::new(Mutex::new(SharedState {
            completed: false,
            waker: None,
        }));

        // åˆ›å»ºæ–°çº¿ç¨‹
        let thread_shared_state = shared_state.clone();
        thread::spawn(move || {
            // ç¡çœ æŒ‡å®šæ—¶é—´å®ç°è®¡æ—¶åŠŸèƒ½
            thread::sleep(duration);
            let mut shared_state = thread_shared_state.lock().unwrap();
            // é€šçŸ¥æ‰§è¡Œå™¨å®šæ—¶å™¨å·²ç»å®Œæˆï¼Œå¯ä»¥ç»§ç»­`poll`å¯¹åº”çš„`Future`äº†
            shared_state.completed = true;
            if let Some(waker) = shared_state.waker.take() {
                waker.wake()
            }
        });

        TimerFuture { shared_state }
    }
}

```



#### æ‰§è¡Œå™¨ Executor
Rust çš„ Future æ˜¯æƒ°æ€§çš„ã€‚å…¶ä¸­ä¸€ä¸ªæ¨åŠ¨å®ƒçš„æ–¹å¼å°±æ˜¯åœ¨ async å‡½æ•°ä¸­ä½¿ç”¨ .await æ¥è°ƒç”¨å¦ä¸€ä¸ª async å‡½æ•°ï¼Œä½†æ˜¯è¿™ä¸ªåªèƒ½è§£å†³ async å†…éƒ¨çš„é—®é¢˜ï¼Œé‚£ä¹ˆè¿™äº›æœ€å¤–å±‚çš„ async å‡½æ•°ç”±æ‰§è¡Œå™¨ executoræ§åˆ¶ ã€‚

æ‰§è¡Œå™¨ä¼šç®¡ç†ä¸€æ‰¹ Future (æœ€å¤–å±‚çš„ async å‡½æ•°)ï¼Œç„¶åé€šè¿‡ä¸åœåœ° poll æ¨åŠ¨å®ƒä»¬ç›´åˆ°å®Œæˆã€‚ æœ€å¼€å§‹ï¼Œæ‰§è¡Œå™¨ä¼šå…ˆ poll ä¸€æ¬¡ Future ï¼Œåé¢å°±ä¸ä¼šä¸»åŠ¨å» poll äº†ï¼Œè€Œæ˜¯ç­‰å¾… Future é€šè¿‡è°ƒç”¨ wake å‡½æ•°æ¥é€šçŸ¥å®ƒå¯ä»¥ç»§ç»­ï¼Œå®ƒæ‰ä¼šç»§ç»­å» poll ã€‚è¿™ç§ wake é€šçŸ¥ç„¶å poll çš„æ–¹å¼ä¼šä¸æ–­é‡å¤ï¼Œç›´åˆ° Future å®Œæˆã€‚

##### æ„å»ºæ‰§è¡Œå™¨
ä¸‹é¢æˆ‘ä»¬å°†å®ç°ä¸€ä¸ªç®€å•çš„æ‰§è¡Œå™¨ï¼Œå®ƒå¯ä»¥åŒæ—¶å¹¶å‘è¿è¡Œå¤šä¸ª Future ã€‚ä¾‹å­ä¸­ï¼Œéœ€è¦ç”¨åˆ° futures åŒ…çš„ ArcWake ç‰¹å¾ï¼Œå®ƒå¯ä»¥æä¾›ä¸€ä¸ªæ–¹ä¾¿çš„é€”å¾„å»æ„å»ºä¸€ä¸ª Waker ã€‚ç¼–è¾‘ Cargo.toml ï¼Œæ·»åŠ ä¸‹é¢ä¾èµ–:
```toml
[dependencies]
futures = "0.3"
```

åœ¨ä¹‹å‰çš„å†…å®¹ä¸­ï¼Œæˆ‘ä»¬åœ¨ src/lib.rs ä¸­åˆ›å»ºäº†å®šæ—¶å™¨ Future ï¼Œç°åœ¨åœ¨ src/main.rs ä¸­æ¥åˆ›å»ºç¨‹åºçš„ä¸»ä½“å†…å®¹ï¼Œå¼€å§‹ä¹‹å‰ï¼Œå…ˆå¼•å…¥æ‰€éœ€çš„åŒ…ï¼š
```rs

use {
    futures::{
        future::{BoxFuture, FutureExt},
        task::{waker_ref, ArcWake},
    },
    std::{
        future::Future,
        sync::mpsc::{sync_channel, Receiver, SyncSender},
        sync::{Arc, Mutex},
        task::{Context, Poll},
        time::Duration,
    },
    // å¼•å…¥ä¹‹å‰å®ç°çš„å®šæ—¶å™¨æ¨¡å—
    timer_future::TimerFuture,
};
```

æ‰§è¡Œå™¨éœ€è¦ä»ä¸€ä¸ªæ¶ˆæ¯é€šé“( channel )ä¸­æ‹‰å–äº‹ä»¶ï¼Œç„¶åè¿è¡Œå®ƒä»¬ã€‚å½“ä¸€ä¸ªä»»åŠ¡å‡†å¤‡å¥½åï¼ˆå¯ä»¥ç»§ç»­æ‰§è¡Œï¼‰ï¼Œå®ƒä¼šå°†è‡ªå·±æ”¾å…¥æ¶ˆæ¯é€šé“ä¸­ï¼Œç„¶åç­‰å¾…æ‰§è¡Œå™¨ poll ã€‚
```rs
/// ä»»åŠ¡æ‰§è¡Œå™¨ï¼Œè´Ÿè´£ä»é€šé“ä¸­æ¥æ”¶ä»»åŠ¡ç„¶åæ‰§è¡Œ
struct Executor {
    ready_queue: Receiver<Arc<Task>>,
}

/// `Spawner`è´Ÿè´£åˆ›å»ºæ–°çš„`Future`ç„¶åå°†å®ƒå‘é€åˆ°ä»»åŠ¡é€šé“ä¸­
#[derive(Clone)]
struct Spawner {
    task_sender: SyncSender<Arc<Task>>,
}

/// ä¸€ä¸ªFutureï¼Œå®ƒå¯ä»¥è°ƒåº¦è‡ªå·±(å°†è‡ªå·±æ”¾å…¥ä»»åŠ¡é€šé“ä¸­)ï¼Œç„¶åç­‰å¾…æ‰§è¡Œå™¨å»`poll`
struct Task {
    /// è¿›è¡Œä¸­çš„Futureï¼Œåœ¨æœªæ¥çš„æŸä¸ªæ—¶é—´ç‚¹ä¼šè¢«å®Œæˆ
    ///
    /// æŒ‰ç†æ¥è¯´`Mutex`åœ¨è¿™é‡Œæ˜¯å¤šä½™çš„ï¼Œå› ä¸ºæˆ‘ä»¬åªæœ‰ä¸€ä¸ªçº¿ç¨‹æ¥æ‰§è¡Œä»»åŠ¡ã€‚ä½†æ˜¯ç”±äº
    /// Rustå¹¶ä¸èªæ˜ï¼Œå®ƒæ— æ³•çŸ¥é“`Future`åªä¼šåœ¨ä¸€ä¸ªçº¿ç¨‹å†…è¢«ä¿®æ”¹ï¼Œå¹¶ä¸ä¼šè¢«è·¨çº¿ç¨‹ä¿®æ”¹ã€‚å› æ­¤
    /// æˆ‘ä»¬éœ€è¦ä½¿ç”¨`Mutex`æ¥æ»¡è¶³è¿™ä¸ªç¬¨ç¬¨çš„ç¼–è¯‘å™¨å¯¹çº¿ç¨‹å®‰å…¨çš„æ‰§ç€ã€‚
    ///
    /// å¦‚æœæ˜¯ç”Ÿäº§çº§çš„æ‰§è¡Œå™¨å®ç°ï¼Œä¸ä¼šä½¿ç”¨`Mutex`ï¼Œå› ä¸ºä¼šå¸¦æ¥æ€§èƒ½ä¸Šçš„å¼€é”€ï¼Œå–è€Œä»£ä¹‹çš„æ˜¯ä½¿ç”¨`UnsafeCell`
    future: Mutex<Option<BoxFuture<'static, ()>>>,

    /// å¯ä»¥å°†è¯¥ä»»åŠ¡è‡ªèº«æ”¾å›åˆ°ä»»åŠ¡é€šé“ä¸­ï¼Œç­‰å¾…æ‰§è¡Œå™¨çš„poll
    task_sender: SyncSender<Arc<Task>>,
}

fn new_executor_and_spawner() -> (Executor, Spawner) {
    // ä»»åŠ¡é€šé“å…è®¸çš„æœ€å¤§ç¼“å†²æ•°(ä»»åŠ¡é˜Ÿåˆ—çš„æœ€å¤§é•¿åº¦)
    // å½“å‰çš„å®ç°ä»…ä»…æ˜¯ä¸ºäº†ç®€å•ï¼Œåœ¨å®é™…çš„æ‰§è¡Œä¸­ï¼Œå¹¶ä¸ä¼šè¿™ä¹ˆä½¿ç”¨
    const MAX_QUEUED_TASKS: usize = 10_000;
    let (task_sender, ready_queue) = sync_channel(MAX_QUEUED_TASKS);
    (Executor { ready_queue }, Spawner { task_sender })
}
```


ä¸‹é¢å†æ¥æ·»åŠ ä¸€ä¸ªæ–¹æ³•ç”¨äºç”Ÿæˆ Future , ç„¶åå°†å®ƒæ”¾å…¥ä»»åŠ¡é€šé“ä¸­:
```rs
impl Spawner {
    fn spawn(&self, future: impl Future<Output = ()> + 'static + Send) {
        let future = future.boxed();
        let task = Arc::new(Task {
            future: Mutex::new(Some(future)),
            task_sender: self.task_sender.clone(),
        });
        self.task_sender.send(task).expect("ä»»åŠ¡é˜Ÿåˆ—å·²æ»¡");
    }
}
```

åœ¨æ‰§è¡Œå™¨ poll ä¸€ä¸ª Future ä¹‹å‰ï¼Œé¦–å…ˆéœ€è¦è°ƒç”¨ wake æ–¹æ³•è¿›è¡Œå”¤é†’ï¼Œç„¶åå†ç”± Waker è´Ÿè´£è°ƒåº¦è¯¥ä»»åŠ¡å¹¶å°†å…¶æ”¾å…¥ä»»åŠ¡é€šé“ä¸­ã€‚åˆ›å»º Waker çš„æœ€ç®€å•çš„æ–¹å¼å°±æ˜¯å®ç° ArcWake ç‰¹å¾ï¼Œå…ˆæ¥ä¸ºæˆ‘ä»¬çš„ä»»åŠ¡å®ç° ArcWake ç‰¹å¾ï¼Œè¿™æ ·å®ƒä»¬å°±èƒ½è¢«è½¬å˜æˆ Waker ç„¶åè¢«å”¤é†’:
```rs
impl ArcWake for Task {
    fn wake_by_ref(arc_self: &Arc<Self>) {
        // é€šè¿‡å‘é€ä»»åŠ¡åˆ°ä»»åŠ¡ç®¡é“çš„æ–¹å¼æ¥å®ç°`wake`ï¼Œè¿™æ ·`wake`åï¼Œä»»åŠ¡å°±èƒ½è¢«æ‰§è¡Œå™¨`poll`
        let cloned = arc_self.clone();
        arc_self
            .task_sender
            .send(cloned)
            .expect("ä»»åŠ¡é˜Ÿåˆ—å·²æ»¡");
    }
}
```

å½“ä»»åŠ¡å®ç°äº† ArcWake ç‰¹å¾åï¼Œå®ƒå°±å˜æˆäº† Waker ï¼Œåœ¨è°ƒç”¨ wake() å¯¹å…¶å”¤é†’åä¼šå°†ä»»åŠ¡å¤åˆ¶ä¸€ä»½æ‰€æœ‰æƒ( Arc )ï¼Œç„¶åå°†å…¶å‘é€åˆ°ä»»åŠ¡é€šé“ä¸­ã€‚æœ€åæˆ‘ä»¬çš„æ‰§è¡Œå™¨å°†ä»é€šé“ä¸­è·å–ä»»åŠ¡ï¼Œç„¶åè¿›è¡Œ poll æ‰§è¡Œï¼š
```rs
impl Executor {
    fn run(&self) {
        while let Ok(task) = self.ready_queue.recv() {
            // è·å–ä¸€ä¸ªfutureï¼Œè‹¥å®ƒè¿˜æ²¡æœ‰å®Œæˆ(ä»ç„¶æ˜¯Someï¼Œä¸æ˜¯None)ï¼Œåˆ™å¯¹å®ƒè¿›è¡Œä¸€æ¬¡pollå¹¶å°è¯•å®Œæˆå®ƒ
            let mut future_slot = task.future.lock().unwrap();
            if let Some(mut future) = future_slot.take() {
                // åŸºäºä»»åŠ¡è‡ªèº«åˆ›å»ºä¸€ä¸ª `LocalWaker`
                let waker = waker_ref(&task);
                let context = &mut Context::from_waker(&*waker);
                // `BoxFuture<T>`æ˜¯`Pin<Box<dyn Future<Output = T> + Send + 'static>>`çš„ç±»å‹åˆ«å
                // é€šè¿‡è°ƒç”¨`as_mut`æ–¹æ³•ï¼Œå¯ä»¥å°†ä¸Šé¢çš„ç±»å‹è½¬æ¢æˆ`Pin<&mut dyn Future + Send + 'static>`
                if future.as_mut().poll(context).is_pending() {
                    // Futureè¿˜æ²¡æ‰§è¡Œå®Œï¼Œå› æ­¤å°†å®ƒæ”¾å›ä»»åŠ¡ä¸­ï¼Œç­‰å¾…ä¸‹æ¬¡è¢«poll
                    *future_slot = Some(future);
                }
            }
        }
    }
}
```

ä¸‹é¢å†æ¥å†™ä¸€æ®µä»£ç ä½¿ç”¨è¯¥æ‰§è¡Œå™¨å»è¿è¡Œä¹‹å‰çš„å®šæ—¶å™¨ Future ï¼š
```rs
fn main() {
    let (executor, spawner) = new_executor_and_spawner();

    // ç”Ÿæˆä¸€ä¸ªä»»åŠ¡
    spawner.spawn(async {
        println!("howdy!");
        // åˆ›å»ºå®šæ—¶å™¨Futureï¼Œå¹¶ç­‰å¾…å®ƒå®Œæˆ
        TimerFuture::new(Duration::new(2, 0)).await;
        println!("done!");
    });

    // dropæ‰ä»»åŠ¡ï¼Œè¿™æ ·æ‰§è¡Œå™¨å°±çŸ¥é“ä»»åŠ¡å·²ç»å®Œæˆï¼Œä¸ä¼šå†æœ‰æ–°çš„ä»»åŠ¡è¿›æ¥
    drop(spawner);

    // è¿è¡Œæ‰§è¡Œå™¨ç›´åˆ°ä»»åŠ¡é˜Ÿåˆ—ä¸ºç©º
    // ä»»åŠ¡è¿è¡Œåï¼Œä¼šå…ˆæ‰“å°`howdy!`, æš‚åœ2ç§’ï¼Œæ¥ç€æ‰“å° `done!`
    executor.run();
}
```

#### æ‰§è¡Œå™¨å’Œç³»ç»Ÿ IO
å‰é¢æˆ‘ä»¬ä¸€èµ·çœ‹è¿‡ä¸€ä¸ªä½¿ç”¨ Future ä» Socket ä¸­å¼‚æ­¥è¯»å–æ•°æ®çš„ä¾‹å­:
```rs

pub struct SocketRead<'a> {
    socket: &'a Socket,
}

impl SimpleFuture for SocketRead<'_> {
    type Output = Vec<u8>;

    fn poll(&mut self, wake: fn()) -> Poll<Self::Output> {
        if self.socket.has_data_to_read() {
            // socketæœ‰æ•°æ®ï¼Œå†™å…¥bufferä¸­å¹¶è¿”å›
            Poll::Ready(self.socket.read_buf())
        } else {
            // socketä¸­è¿˜æ²¡æ•°æ®
            //
            // æ³¨å†Œä¸€ä¸ª`wake`å‡½æ•°ï¼Œå½“æ•°æ®å¯ç”¨æ—¶ï¼Œè¯¥å‡½æ•°ä¼šè¢«è°ƒç”¨ï¼Œ
            // ç„¶åå½“å‰Futureçš„æ‰§è¡Œå™¨ä¼šå†æ¬¡è°ƒç”¨`poll`æ–¹æ³•ï¼Œæ­¤æ—¶å°±å¯ä»¥è¯»å–åˆ°æ•°æ®
            self.socket.set_readable_callback(wake);
            Poll::Pending
        }
    }
}
```

è¯¥ä¾‹å­ä¸­ï¼ŒFuture å°†ä» Socket è¯»å–æ•°æ®ï¼Œè‹¥å½“å‰è¿˜æ²¡æœ‰æ•°æ®ï¼Œåˆ™ä¼šè®©å‡ºå½“å‰çº¿ç¨‹çš„æ‰€æœ‰æƒï¼Œå…è®¸æ‰§è¡Œå™¨å»æ‰§è¡Œå…¶å®ƒçš„ Future ã€‚å½“æ•°æ®å‡†å¤‡å¥½åï¼Œä¼šè°ƒç”¨ wake() å‡½æ•°å°†è¯¥ Future çš„ä»»åŠ¡æ”¾å…¥ä»»åŠ¡é€šé“ä¸­ï¼Œç­‰å¾…æ‰§è¡Œå™¨çš„ poll ã€‚

å…³äºè¯¥æµç¨‹å·²ç»åå¤è®²äº†å¾ˆå¤šæ¬¡ï¼Œç›¸ä¿¡å¤§å®¶åº”è¯¥éå¸¸æ¸…æ¥šäº†ã€‚ç„¶è€Œè¯¥ä¾‹å­ä¸­è¿˜æœ‰ä¸€ä¸ªç–‘é—®æ²¡æœ‰è§£å†³ï¼š

set_readable_callback æ–¹æ³•åˆ°åº•æ˜¯æ€ä¹ˆå·¥ä½œçš„ï¼Ÿæ€ä¹ˆæ‰èƒ½çŸ¥é“ socket ä¸­çš„æ•°æ®å·²ç»å¯ä»¥è¢«è¯»å–äº†ï¼Ÿ
å…³äºç¬¬äºŒç‚¹ï¼Œå…¶ä¸­ä¸€ä¸ªç®€å•ç²—æš´çš„æ–¹æ³•å°±æ˜¯ä½¿ç”¨ä¸€ä¸ªæ–°çº¿ç¨‹ä¸åœçš„æ£€æŸ¥ socket ä¸­æ˜¯å¦æœ‰äº†æ•°æ®ï¼Œå½“æœ‰äº†åï¼Œå°±è°ƒç”¨ wake() å‡½æ•°ã€‚è¯¥æ–¹æ³•ç¡®å®å¯ä»¥æ»¡è¶³éœ€æ±‚ï¼Œä½†æ˜¯æ€§èƒ½ç€å®å¤ªä½äº†ï¼Œéœ€è¦ä¸ºæ¯ä¸ªé˜»å¡çš„ Future éƒ½åˆ›å»ºä¸€ä¸ªå•ç‹¬çš„çº¿ç¨‹ï¼

åœ¨ç°å®ä¸–ç•Œä¸­ï¼Œè¯¥é—®é¢˜å¾€å¾€æ˜¯é€šè¿‡æ“ä½œç³»ç»Ÿæä¾›çš„ IO å¤šè·¯å¤ç”¨æœºåˆ¶æ¥å®Œæˆï¼Œä¾‹å¦‚ Linux ä¸­çš„ epollï¼ŒFreeBSD å’Œ macOS ä¸­çš„ kqueue ï¼ŒWindows ä¸­çš„ IOCP, Fuchisaä¸­çš„ ports ç­‰(å¯ä»¥é€šè¿‡ Rust çš„è·¨å¹³å°åŒ… mio æ¥ä½¿ç”¨å®ƒä»¬)ã€‚å€ŸåŠ© IO å¤šè·¯å¤ç”¨æœºåˆ¶ï¼Œå¯ä»¥å®ç°ä¸€ä¸ªçº¿ç¨‹åŒæ—¶é˜»å¡åœ°å»ç­‰å¾…å¤šä¸ªå¼‚æ­¥ IO äº‹ä»¶ï¼Œä¸€æ—¦æŸä¸ªäº‹ä»¶å®Œæˆå°±ç«‹å³é€€å‡ºé˜»å¡å¹¶è¿”å›æ•°æ®ã€‚ç›¸å…³å®ç°ç±»ä¼¼äºä»¥ä¸‹ä»£ç ï¼š
```rs
pub struct SocketRead<'a> {
    socket: &'a Socket,
}

impl SimpleFuture for SocketRead<'_> {
    type Output = Vec<u8>;

    fn poll(&mut self, wake: fn()) -> Poll<Self::Output> {
        if self.socket.has_data_to_read() {
            // socketæœ‰æ•°æ®ï¼Œå†™å…¥bufferä¸­å¹¶è¿”å›
            Poll::Ready(self.socket.read_buf())
        } else {
            // socketä¸­è¿˜æ²¡æ•°æ®
            // æ³¨å†Œä¸€ä¸ª`wake`å‡½æ•°ï¼Œå½“æ•°æ®å¯ç”¨æ—¶ï¼Œè¯¥å‡½æ•°ä¼šè¢«è°ƒç”¨ï¼Œ
            // ç„¶åå½“å‰Futureçš„æ‰§è¡Œå™¨ä¼šå†æ¬¡è°ƒç”¨`poll`æ–¹æ³•ï¼Œæ­¤æ—¶å°±å¯ä»¥è¯»å–åˆ°æ•°æ®
            self.socket.set_readable_callback(wake);
            Poll::Pending
        }
    }
}

struct IoBlocker {
    /* ... */
}

struct Event {
    // Eventçš„å”¯ä¸€IDï¼Œè¯¥äº‹ä»¶å‘ç”Ÿåï¼Œå°±ä¼šè¢«ç›‘å¬èµ·æ¥
    id: usize,

    // ä¸€ç»„éœ€è¦ç­‰å¾…æˆ–è€…å·²å‘ç”Ÿçš„ä¿¡å·
    signals: Signals,
}

impl IoBlocker {
    /// åˆ›å»ºéœ€è¦é˜»å¡ç­‰å¾…çš„å¼‚æ­¥IOäº‹ä»¶çš„é›†åˆ
    fn new() -> Self { /* ... */ }

    /// å¯¹æŒ‡å®šçš„IOäº‹ä»¶è¡¨ç¤ºå…´è¶£
    fn add_io_event_interest(
        &self,

        /// äº‹ä»¶æ‰€ç»‘å®šçš„socket
        io_object: &IoObject,

        event: Event,
    ) { /* ... */ }

    /// è¿›å…¥é˜»å¡ï¼Œç›´åˆ°æŸä¸ªäº‹ä»¶å‡ºç°
    fn block(&self) -> Event { /* ... */ }
}

let mut io_blocker = IoBlocker::new();
io_blocker.add_io_event_interest(
    &socket_1,
    Event { id: 1, signals: READABLE },
);
io_blocker.add_io_event_interest(
    &socket_2,
    Event { id: 2, signals: READABLE | WRITABLE },
);
let event = io_blocker.block();

// å½“socketçš„æ•°æ®å¯ä»¥è¯»å–æ—¶ï¼Œæ‰“å° "Socket 1 is now READABLE"
println!("Socket {:?} is now {:?}", event.id, event.signals);
```
è¿™æ ·ï¼Œæˆ‘ä»¬åªéœ€è¦ä¸€ä¸ªæ‰§è¡Œå™¨çº¿ç¨‹ï¼Œå®ƒä¼šæ¥æ”¶ IO äº‹ä»¶å¹¶å°†å…¶åˆ†å‘åˆ°å¯¹åº”çš„ Waker ä¸­ï¼Œæ¥ç€åè€…ä¼šå”¤é†’ç›¸å…³çš„ä»»åŠ¡ï¼Œæœ€ç»ˆé€šè¿‡æ‰§è¡Œå™¨ poll åï¼Œä»»åŠ¡å¯ä»¥é¡ºåˆ©åœ°ç»§ç»­æ‰§è¡Œ, è¿™ç§ IO è¯»å–æµç¨‹å¯ä»¥ä¸åœçš„å¾ªç¯ï¼Œç›´åˆ° socket å…³é—­ã€‚
### å®šæµ·ç¥é’ˆ Pin å’Œ Unpin
åœ¨ Rust ä¸­ï¼Œæ‰€æœ‰çš„ç±»å‹å¯ä»¥åˆ†ä¸ºä¸¤ç±»:
- ç±»å‹çš„å€¼å¯ä»¥åœ¨å†…å­˜ä¸­å®‰å…¨åœ°è¢«ç§»åŠ¨ï¼Œä¾‹å¦‚æ•°å€¼ã€å­—ç¬¦ä¸²ã€å¸ƒå°”å€¼ã€ç»“æ„ä½“ã€æšä¸¾ï¼Œæ€»ä¹‹ä½ èƒ½æƒ³åˆ°çš„å‡ ä¹æ‰€æœ‰ç±»å‹éƒ½å¯ä»¥è½å…¥åˆ°æ­¤èŒƒç•´å†…
- è‡ªå¼•ç”¨ç±»å‹ï¼Œ
#### ä¸ºä½•éœ€è¦ Pin
å…¶å® Pin è¿˜æœ‰ä¸€ä¸ªå°ä¼™ä¼´ UnPin ï¼Œä¸å‰è€…ç›¸åï¼Œåè€…è¡¨ç¤ºç±»å‹å¯ä»¥åœ¨å†…å­˜ä¸­å®‰å…¨åœ°ç§»åŠ¨ã€‚åœ¨æ·±å…¥ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆæ¥å›å¿†ä¸‹ async/.await æ˜¯å¦‚ä½•å·¥ä½œçš„:
```rs

let fut_one = /* ... */; // Future 1
let fut_two = /* ... */; // Future 2
async move {
    fut_one.await;
    fut_two.await;
}
```

åœ¨åº•å±‚ï¼Œasync ä¼šåˆ›å»ºä¸€ä¸ªå®ç°äº† Future çš„åŒ¿åç±»å‹ï¼Œå¹¶æä¾›äº†ä¸€ä¸ª poll æ–¹æ³•ï¼š
```rs
// `async { ... }`è¯­å¥å—åˆ›å»ºçš„ `Future` ç±»å‹
struct AsyncFuture {
    fut_one: FutOne,
    fut_two: FutTwo,
    state: State,
}

// `async` è¯­å¥å—å¯èƒ½å¤„äºçš„çŠ¶æ€
enum State {
    AwaitingFutOne,
    AwaitingFutTwo,
    Done,
}

impl Future for AsyncFuture {
    type Output = ();

    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {
        loop {
            match self.state {
                State::AwaitingFutOne => match self.fut_one.poll(..) {
                    Poll::Ready(()) => self.state = State::AwaitingFutTwo,
                    Poll::Pending => return Poll::Pending,
                }
                State::AwaitingFutTwo => match self.fut_two.poll(..) {
                    Poll::Ready(()) => self.state = State::Done,
                    Poll::Pending => return Poll::Pending,
                }
                State::Done => return Poll::Ready(()),
            }
        }
    }
}
```

å½“ poll ç¬¬ä¸€æ¬¡è¢«è°ƒç”¨æ—¶ï¼Œå®ƒä¼šå»æŸ¥è¯¢ fut_one çš„çŠ¶æ€ï¼Œè‹¥ fut_one æ— æ³•å®Œæˆï¼Œåˆ™ poll æ–¹æ³•ä¼šè¿”å›ã€‚æœªæ¥å¯¹ poll çš„è°ƒç”¨å°†ä»ä¸Šä¸€æ¬¡è°ƒç”¨ç»“æŸçš„åœ°æ–¹å¼€å§‹ã€‚è¯¥è¿‡ç¨‹ä¼šä¸€ç›´æŒç»­ï¼Œç›´åˆ° Future å®Œæˆä¸ºæ­¢ã€‚

ç„¶è€Œï¼Œå¦‚æœæˆ‘ä»¬çš„ async è¯­å¥å—ä¸­ä½¿ç”¨äº†å¼•ç”¨ç±»å‹ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿä¾‹å¦‚ä¸‹é¢ä¾‹å­ï¼š
```rs

async {
    let mut x = [0; 128];
    let read_into_buf_fut = read_into_buf(&mut x);
    read_into_buf_fut.await;
    println!("{:?}", x);
}
```

è¿™æ®µä»£ç ä¼šç¼–è¯‘æˆä¸‹é¢çš„å½¢å¼ï¼š
```RS
struct ReadIntoBuf<'a> {
    buf: &'a mut [u8], // æŒ‡å‘ä¸‹é¢çš„`x`å­—æ®µ
}

struct AsyncFuture {
    x: [u8; 128],
    read_into_buf_fut: ReadIntoBuf<'what_lifetime?>,
}
```

è¿™é‡Œï¼ŒReadIntoBuf æ‹¥æœ‰ä¸€ä¸ªå¼•ç”¨å­—æ®µï¼ŒæŒ‡å‘äº†ç»“æ„ä½“çš„å¦ä¸€ä¸ªå­—æ®µ x ï¼Œä¸€æ—¦ AsyncFuture è¢«ç§»åŠ¨ï¼Œé‚£ x çš„åœ°å€ä¹Ÿå°†éšä¹‹å˜åŒ–ï¼Œæ­¤æ—¶å¯¹ x çš„å¼•ç”¨å°±å˜æˆäº†ä¸åˆæ³•çš„ï¼Œä¹Ÿå°±æ˜¯ read_into_buf_fut.buf ä¼šå˜ä¸ºä¸åˆæ³•çš„ã€‚

è‹¥èƒ½å°† Future åœ¨å†…å­˜ä¸­å›ºå®šåˆ°ä¸€ä¸ªä½ç½®ï¼Œå°±å¯ä»¥é¿å…è¿™ç§é—®é¢˜çš„å‘ç”Ÿï¼Œä¹Ÿå°±å¯ä»¥å®‰å…¨çš„åˆ›å»ºä¸Šé¢è¿™ç§å¼•ç”¨ç±»å‹ã€‚
```rs
struct Test {
    a: String,
    b: *const String,
}

impl Test {
    fn new(txt: &str) -> Self {
        Test {
            a: String::from(txt),
            b: std::ptr::null(),
        }
    }

    fn init(&mut self) {
        let self_ref: *const String = &self.a;
        self.b = self_ref;
    }

    fn a(&self) -> &str {
        &self.a
    }

    fn b(&self) -> &String {
        assert!(!self.b.is_null(), "Test::b called without Test::init being called first");
        unsafe { &*(self.b) }
    }
}

```
#### Unpin
äº‹å®ä¸Šï¼Œç»å¤§å¤šæ•°ç±»å‹éƒ½ä¸åœ¨æ„æ˜¯å¦è¢«ç§»åŠ¨ï¼Œå› æ­¤å®ƒä»¬éƒ½è‡ªåŠ¨å®ç°äº† Unpin ç‰¹å¾ã€‚
```mermaid
graph TB
    A(Pin<Pointer>)-->B[Pointerï¼ˆe.g.Box<Data>ï¼‰]-->C[Data];
```
å®é™…ä¸Šï¼ŒPin ä¸æŒ‰å¥—è·¯å‡ºç‰Œï¼Œå®ƒæ˜¯ä¸€ä¸ªç»“æ„ä½“ï¼š
```RS
pub struct Pin<P> {
    pointer: P,
}

```

å®ƒåŒ…è£¹ä¸€ä¸ªæŒ‡é’ˆï¼Œå¹¶ä¸”èƒ½ç¡®ä¿è¯¥æŒ‡é’ˆæŒ‡å‘çš„æ•°æ®ä¸ä¼šè¢«ç§»åŠ¨ï¼Œä¾‹å¦‚ Pin<&mut T> , Pin<&T> , Pin&LT;Box>&LT;T>> ï¼Œéƒ½èƒ½ç¡®ä¿ T ä¸ä¼šè¢«ç§»åŠ¨ã€‚


è€Œ Unpin æ‰æ˜¯ä¸€ä¸ªç‰¹å¾ï¼Œå®ƒè¡¨æ˜ä¸€ä¸ªç±»å‹å¯ä»¥éšæ„è¢«ç§»åŠ¨ï¼Œå¯ä»¥è¢« Pin ä½çš„å€¼å®ç°çš„ç‰¹å¾æ˜¯ !Unpin ï¼Œå¤§å®¶å¯èƒ½ä¹‹å‰æ²¡æœ‰è§è¿‡ï¼Œ!Unpin è¯´æ˜ç±»å‹æ²¡æœ‰å®ç° Unpin ç‰¹å¾ï¼Œé‚£è‡ªç„¶å°±å¯ä»¥è¢« Pin äº†ã€‚



ä¾‹å¦‚ Pin<&mut u8> ï¼Œæ˜¾ç„¶ u8 å®ç°äº† Unpin ç‰¹å¾ï¼Œå®ƒå¯ä»¥åœ¨å†…å­˜ä¸­è¢«ç§»åŠ¨ï¼Œå› æ­¤ Pin<&mut u8> è·Ÿ &mut u8 å®é™…ä¸Šå¹¶æ— åŒºåˆ«ï¼Œä¸€æ ·å¯ä»¥è¢«ç§»åŠ¨ã€‚

- éƒ½æ˜¯æ ‡è®°ç‰¹å¾( marker trait )ï¼Œè¯¥ç‰¹å¾æœªå®šä¹‰ä»»ä½•è¡Œä¸ºï¼Œéå¸¸é€‚ç”¨äºæ ‡è®°
- éƒ½å¯ä»¥é€šè¿‡!è¯­æ³•å»é™¤å®ç°
- ç»å¤§å¤šæ•°æƒ…å†µéƒ½æ˜¯è‡ªåŠ¨å®ç°, æ— éœ€æˆ‘ä»¬çš„æ“å¿ƒ
#### æ·±å…¥ç†è§£ Pin
å¯¹äºä¸Šé¢çš„é—®é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥ç®€å•çš„å½’ç»“ä¸ºå¦‚ä½•åœ¨ Rust ä¸­å¤„ç†è‡ªå¼•ç”¨ç±»å‹ï¼Œä¸‹é¢ç”¨ä¸€ä¸ªç¨å¾®ç®€å•ç‚¹çš„ä¾‹å­æ¥ç†è§£ä¸‹ Pin :
```rs
#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
}

impl Test {
    fn new(txt: &str) -> Self {
        Test {
            a: String::from(txt),
            b: std::ptr::null(),
        }
    }

    fn init(&mut self) {
        // è£¸æŒ‡é’ˆï¼Œè¿›è¡Œè‡ªå¼•ç”¨
        let self_ref: *const String = &self.a;
        // è¿›è¡Œè‡ªå¼•ç”¨
        self.b = self_ref;
    }
    // è·å–aå­—æ®µçš„å¼•ç”¨å€¼
    fn a(&self) -> &str {
        &self.a
    }
    // è·å–bå­—æ®µçš„å¼•ç”¨å€¼
    fn b(&self) -> &String {
        assert!(!self.b.is_null(), "Test::b called without Test::init being called first");
        unsafe { &*(self.b) }
    }
}
```

Test æä¾›äº†æ–¹æ³•ç”¨äºè·å–å­—æ®µ a å’Œ b çš„å€¼çš„å¼•ç”¨ã€‚è¿™é‡Œb æ˜¯ a çš„ä¸€ä¸ªå¼•ç”¨ï¼Œä½†æ˜¯æˆ‘ä»¬å¹¶æ²¡æœ‰ä½¿ç”¨å¼•ç”¨ç±»å‹è€Œæ˜¯ç”¨äº†è£¸æŒ‡é’ˆï¼ŒåŸå› æ˜¯ï¼šRust çš„å€Ÿç”¨è§„åˆ™ä¸å…è®¸æˆ‘ä»¬è¿™æ ·ç”¨ï¼Œå› ä¸ºä¸ç¬¦åˆç”Ÿå‘½å‘¨æœŸçš„è¦æ±‚ã€‚ æ­¤æ—¶çš„ Test å°±æ˜¯ä¸€ä¸ªè‡ªå¼•ç”¨ç»“æ„ä½“ã€‚

å¦‚æœä¸ç§»åŠ¨ä»»ä½•å€¼ï¼Œé‚£ä¹ˆä¸Šé¢çš„ä¾‹å­å°†æ²¡æœ‰ä»»ä½•é—®é¢˜ï¼Œä¾‹å¦‚:
```rs
fn main() {
    let mut test1 = Test::new("test1");
    test1.init();
    let mut test2 = Test::new("test2");
    test2.init();

    println!("a: {}, b: {}", test1.a(), test1.b());
    println!("a: {}, b: {}", test2.a(), test2.b());

}
```

è¾“å‡ºéå¸¸æ­£å¸¸ï¼š
```rs
a: test1, b: test1
a: test2, b: test2
```
æ—¢ç„¶ç§»åŠ¨æ•°æ®ä¼šå¯¼è‡´æŒ‡é’ˆä¸åˆæ³•ï¼Œé‚£æˆ‘ä»¬å°±ç§»åŠ¨ä¸‹æ•°æ®è¯•è¯•ï¼Œå°† test1 å’Œ test2 è¿›è¡Œä¸‹äº¤æ¢ï¼š
```rs
fn main() {
    let mut test1 = Test::new("test1");
    test1.init();
    let mut test2 = Test::new("test2");
    test2.init();

    println!("a: {}, b: {}", test1.a(), test1.b());
    std::mem::swap(&mut test1, &mut test2);
    println!("a: {}, b: {}", test2.a(), test2.b());

}
```

æŒ‰ç†æ¥è¯´ï¼Œè¿™æ ·ä¿®æ”¹åï¼Œè¾“å‡ºåº”è¯¥å¦‚ä¸‹:
```rs
a: test1, b: test1
a: test1, b: test1

```

ä½†æ˜¯å®é™…è¿è¡Œåï¼Œå´äº§ç”Ÿäº†ä¸‹é¢çš„è¾“å‡º:
```rs
a: test1, b: test1
a: test1, b: test2
```

åŸå› æ˜¯ test2.b æŒ‡é’ˆä¾ç„¶æŒ‡å‘äº†æ—§çš„åœ°å€ï¼Œè€Œè¯¥åœ°å€å¯¹åº”çš„å€¼ç°åœ¨åœ¨ test1 é‡Œï¼Œæœ€ç»ˆä¼šæ‰“å°å‡ºæ„æ–™ä¹‹å¤–çš„å€¼ã€‚

å¦‚æœå¤§å®¶è¿˜æ˜¯å°†ä¿¡å°†ç–‘ï¼Œé‚£å†çœ‹çœ‹ä¸‹é¢çš„ä»£ç ï¼š
```rs
fn main() {
    let mut test1 = Test::new("test1");
    test1.init();
    let mut test2 = Test::new("test2");
    test2.init();

    println!("a: {}, b: {}", test1.a(), test1.b());
    std::mem::swap(&mut test1, &mut test2);// åœ¨ä¸¤ä¸ªå¯å˜ä½ç½®äº¤æ¢å€¼
    test1.a = "I've totally changed now!".to_string();
    println!("a: {}, b: {}", test2.a(), test2.b());

}
```

ä¸‹é¢çš„å›¾ç‰‡ä¹Ÿå¯ä»¥å¸®åŠ©æ›´å¥½çš„ç†è§£è¿™ä¸ªè¿‡ç¨‹ï¼š

![Alt text](image.png)
#### Pin åœ¨å®è·µä¸­çš„è¿ç”¨
**å°†å€¼å›ºå®šåˆ°æ ˆä¸Š**
å›åˆ°ä¹‹å‰çš„ä¾‹å­ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ Pin æ¥è§£å†³æŒ‡é’ˆæŒ‡å‘çš„æ•°æ®è¢«ç§»åŠ¨çš„é—®é¢˜:
```rs
use std::pin::Pin;
use std::marker::PhantomPinned;

#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
    _marker: PhantomPinned,
}
impl Test {
    fn new(txt: &str) -> Self {
        Test {
            a: String::from(txt),
            b: std::ptr::null(),
            _marker: PhantomPinned, // è¿™ä¸ªæ ‡è®°å¯ä»¥è®©æˆ‘ä»¬çš„ç±»å‹è‡ªåŠ¨å®ç°ç‰¹å¾`!Unpin`
        }
    }

    fn init(self: Pin<&mut Self>) {
        let self_ptr: *const String = &self.a;
        let this = unsafe { self.get_unchecked_mut() };
        this.b = self_ptr;
    }

    fn a(self: Pin<&Self>) -> &str {
        &self.get_ref().a
    }

    fn b(self: Pin<&Self>) -> &String {
        assert!(!self.b.is_null(), "Test::b called without Test::init being called first");
        unsafe { &*(self.b) }
    }
}
```

æˆ‘ä»¬ä½¿ç”¨äº†ä¸€ä¸ªæ ‡è®°ç±»å‹ PhantomPinned å°†è‡ªå®šä¹‰ç»“æ„ä½“ Test å˜æˆäº† !Unpinï¼Œå› æ­¤è¯¥ç»“æ„ä½“æ— æ³•å†è¢«ç§»åŠ¨ã€‚

ä¸€æ—¦ç±»å‹å®ç°äº† !Unpin ï¼Œé‚£å°†å®ƒçš„å€¼å›ºå®šåˆ°æ ˆ( stack )ä¸Šå°±æ˜¯ä¸å®‰å…¨çš„è¡Œä¸ºï¼Œå› æ­¤åœ¨ä»£ç ä¸­æˆ‘ä»¬ä½¿ç”¨äº† unsafe è¯­å¥å—æ¥è¿›è¡Œå¤„ç†ï¼Œä½ ä¹Ÿå¯ä»¥ä½¿ç”¨ pin_utils æ¥é¿å… unsafe çš„ä½¿ç”¨ã€‚

Rust ä¸­çš„ unsafe å…¶å®æ²¡æœ‰é‚£ä¹ˆå¯æ€•ï¼Œè™½ç„¶å¬ä¸Šå»å¾ˆä¸å®‰å…¨ï¼Œä½†æ˜¯å®é™…ä¸Š Rust ä¾ç„¶æä¾›äº†å¾ˆå¤šæœºåˆ¶æ¥å¸®æˆ‘ä»¬æå‡äº†å®‰å…¨æ€§ï¼Œå› æ­¤ä¸å¿…åƒå¯¹å¾… Go è¯­è¨€çš„ unsafe é‚£æ ·å»ç•æƒ§äºä½¿ç”¨ Rust ä¸­çš„ unsafe ï¼Œå¤§è‡´ä½¿ç”¨åŸåˆ™æ€»ç»“å¦‚ä¸‹ï¼šæ²¡å¿…è¦ç”¨æ—¶ï¼Œå°±ä¸è¦ç”¨ï¼Œå½“æœ‰å¿…è¦ç”¨æ—¶ï¼Œå°±å¤§èƒ†ç”¨ï¼Œä½†æ˜¯å°½é‡æ§åˆ¶å¥½è¾¹ç•Œï¼Œè®© unsafe çš„èŒƒå›´å°½å¯èƒ½å°

æ­¤æ—¶ï¼Œå†å»å°è¯•ç§»åŠ¨è¢«å›ºå®šçš„å€¼ï¼Œå°±ä¼šå¯¼è‡´ç¼–è¯‘é”™è¯¯ï¼š
```rs
pub fn main() {
    // æ­¤æ—¶çš„`test1`å¯ä»¥è¢«å®‰å…¨çš„ç§»åŠ¨
    let mut test1 = Test::new("test1");
    // æ–°çš„`test1`ç”±äºä½¿ç”¨äº†`Pin`ï¼Œå› æ­¤æ— æ³•å†è¢«ç§»åŠ¨ï¼Œè¿™é‡Œçš„å£°æ˜ä¼šå°†ä¹‹å‰çš„`test1`é®è”½
    let mut test1 = unsafe { Pin::new_unchecked(&mut test1) };
    Test::init(test1.as_mut());

    let mut test2 = Test::new("test2");
    let mut test2 = unsafe { Pin::new_unchecked(&mut test2) };
    Test::init(test2.as_mut());

    println!("a: {}, b: {}", Test::a(test1.as_ref()), Test::b(test1.as_ref()));
    std::mem::swap(test1.get_mut(), test2.get_mut());
    println!("a: {}, b: {}", Test::a(test2.as_ref()), Test::b(test2.as_ref()));
}
```

æ˜¯çš„ï¼ŒRust å¹¶ä¸æ˜¯åœ¨è¿è¡Œæ—¶åšè¿™ä»¶äº‹ï¼Œè€Œæ˜¯åœ¨ç¼–è¯‘æœŸå°±å®Œæˆäº†ï¼Œå› æ­¤æ²¡æœ‰é¢å¤–çš„æ€§èƒ½å¼€é”€ï¼æ¥çœ‹çœ‹æŠ¥é”™:
```shell
error[E0277]: `PhantomPinned` cannot be unpinned
   --> src/main.rs:47:43
    |
47  |     std::mem::swap(test1.get_mut(), test2.get_mut());
    |                                           ^^^^^^^ within `Test`, the trait `Unpin` is not implemented for `PhantomPinned`
```

éœ€è¦æ³¨æ„çš„æ˜¯å›ºå®šåœ¨æ ˆä¸Šéå¸¸ä¾èµ–äºä½ å†™å‡ºçš„ unsafe ä»£ç çš„æ­£ç¡®æ€§ã€‚æˆ‘ä»¬çŸ¥é“ &'a mut T å¯ä»¥å›ºå®šçš„ç”Ÿå‘½å‘¨æœŸæ˜¯ 'a ï¼Œä½†æ˜¯æˆ‘ä»¬å´ä¸çŸ¥é“å½“ç”Ÿå‘½å‘¨æœŸ 'a ç»“æŸåï¼Œè¯¥æŒ‡é’ˆæŒ‡å‘çš„æ•°æ®æ˜¯å¦ä¼šè¢«ç§»èµ°ã€‚å¦‚æœä½ çš„ unsafe ä»£ç é‡Œè¿™ä¹ˆå®ç°äº†ï¼Œé‚£ä¹ˆå°±ä¼šè¿èƒŒ Pin åº”è¯¥å…·æœ‰çš„ä½œç”¨ï¼

ä¸€ä¸ªå¸¸è§çš„é”™è¯¯å°±æ˜¯å¿˜è®°å»é®è”½( shadow )åˆå§‹çš„å˜é‡ï¼Œå› ä¸ºä½ å¯ä»¥ drop æ‰ Pin ï¼Œç„¶ååœ¨ &'a mut T ç»“æŸåå»ç§»åŠ¨æ•°æ®:
```rs

fn main() {
   let mut test1 = Test::new("test1");
   let mut test1_pin = unsafe { Pin::new_unchecked(&mut test1) };
   Test::init(test1_pin.as_mut());

   drop(test1_pin);
   println!(r#"test1.b points to "test1": {:?}..."#, test1.b);

   let mut test2 = Test::new("test2");
   mem::swap(&mut test1, &mut test2);
   println!("... and now it points nowhere: {:?}", test1.b);
}
```

#### å›ºå®šåˆ°å †ä¸Š
å°†ä¸€ä¸ª !Unpin ç±»å‹çš„å€¼å›ºå®šåˆ°å †ä¸Šï¼Œä¼šç»™äºˆè¯¥å€¼ä¸€ä¸ªç¨³å®šçš„å†…å­˜åœ°å€ï¼Œå®ƒæŒ‡å‘çš„å †ä¸­çš„å€¼åœ¨ Pin åæ˜¯æ— æ³•è¢«ç§»åŠ¨çš„ã€‚è€Œä¸”ä¸å›ºå®šåœ¨æ ˆä¸Šä¸åŒï¼Œæˆ‘ä»¬çŸ¥é“å †ä¸Šçš„å€¼åœ¨æ•´ä¸ªç”Ÿå‘½å‘¨æœŸå†…éƒ½ä¼šè¢«ç¨³ç¨³åœ°å›ºå®šä½ã€‚
```rs
use std::pin::Pin;
use std::marker::PhantomPinned;

#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
    _marker: PhantomPinned,
}

impl Test {
    fn new(txt: &str) -> Pin<Box<Self>> {
        let t = Test {
            a: String::from(txt),
            b: std::ptr::null(),
            _marker: PhantomPinned,
        };
        let mut boxed = Box::pin(t);
        let self_ptr: *const String = &boxed.as_ref().a;
        unsafe { boxed.as_mut().get_unchecked_mut().b = self_ptr };

        boxed
    }

    fn a(self: Pin<&Self>) -> &str {
        &self.get_ref().a
    }

    fn b(self: Pin<&Self>) -> &String {
        unsafe { &*(self.b) }
    }
}

pub fn main() {
    let test1 = Test::new("test1");
    let test2 = Test::new("test2");

    println!("a: {}, b: {}",test1.as_ref().a(), test1.as_ref().b());
    println!("a: {}, b: {}",test2.as_ref().a(), test2.as_ref().b());
}
```

#### å°†å›ºå®šä½çš„ Future å˜ä¸º Unpin
async å‡½æ•°è¿”å›çš„ Future é»˜è®¤å°±æ˜¯ !Unpin çš„ã€‚

ä½†æ˜¯ï¼Œåœ¨å®é™…åº”ç”¨ä¸­ï¼Œä¸€äº›å‡½æ•°ä¼šè¦æ±‚å®ƒä»¬å¤„ç†çš„ Future æ˜¯ Unpin çš„ï¼Œæ­¤æ—¶ï¼Œè‹¥ä½ ä½¿ç”¨çš„ Future æ˜¯ !Unpin çš„ï¼Œå¿…é¡»è¦ä½¿ç”¨ä»¥ä¸‹çš„æ–¹æ³•å…ˆå°† Future è¿›è¡Œå›ºå®š:

- Box::pinï¼Œ åˆ›å»ºä¸€ä¸ª Pin&lt;Box&lt;T>>
- pin_utils::pin_mut!ï¼Œ åˆ›å»ºä¸€ä¸ª Pin<&mut T>
å›ºå®šåè·å¾—çš„ Pin<Box<T>> å’Œ Pin<&mut T> æ—¢å¯ä»¥ç”¨äº Future ï¼Œåˆä¼šè‡ªåŠ¨å®ç° Unpinã€‚
```rs
use pin_utils::pin_mut; // `pin_utils` å¯ä»¥åœ¨crates.ioä¸­æ‰¾åˆ°

// å‡½æ•°çš„å‚æ•°æ˜¯ä¸€ä¸ª`Future`ï¼Œä½†æ˜¯è¦æ±‚è¯¥`Future`å®ç°`Unpin`
fn execute_unpin_future(x: impl Future<Output = ()> + Unpin) { /* ... */ }

let fut = async { /* ... */ };
// ä¸‹é¢ä»£ç æŠ¥é”™: é»˜è®¤æƒ…å†µä¸‹ï¼Œ`fut` å®ç°çš„æ˜¯`!Unpin`ï¼Œå¹¶æ²¡æœ‰å®ç°`Unpin`
// execute_unpin_future(fut);

// ä½¿ç”¨`Box`è¿›è¡Œå›ºå®š
let fut = async { /* ... */ };
let fut = Box::pin(fut);
execute_unpin_future(fut); // OK

// ä½¿ç”¨`pin_mut!`è¿›è¡Œå›ºå®š
let fut = async { /* ... */ };
pin_mut!(fut);
execute_unpin_future(fut); // OK
```
#### æ€»ç»“
è„‘è¢‹é‡Œå·²ç»å¿«è¢« Pin ã€ Unpin ã€ !Unpin æ•´çˆ†ç‚¸äº†ï¼Œæ²¡äº‹ï¼Œæˆ‘ä»¬å†æ¥ç«ä¸Šæµ‡æ²¹ä¸‹:
- è‹¥ T: Unpin ( Rust ç±»å‹çš„é»˜è®¤å®ç°)ï¼Œé‚£ä¹ˆ Pin<'a, T> è·Ÿ &'a mut T å®Œå…¨ç›¸åŒï¼Œä¹Ÿå°±æ˜¯ Pin å°†æ²¡æœ‰ä»»ä½•æ•ˆæœ, è¯¥ç§»åŠ¨è¿˜æ˜¯ç…§å¸¸ç§»åŠ¨
- ç»å¤§å¤šæ•°æ ‡å‡†åº“ç±»å‹éƒ½å®ç°äº† Unpin ï¼Œäº‹å®ä¸Šï¼Œå¯¹äº Rust ä¸­ä½ èƒ½é‡åˆ°çš„ç»å¤§å¤šæ•°ç±»å‹ï¼Œè¯¥ç»“è®ºä¾ç„¶æˆç«‹ ï¼Œå…¶ä¸­ä¸€ä¸ªä¾‹å¤–å°±æ˜¯ï¼šasync/await ç”Ÿæˆçš„ Future æ²¡æœ‰å®ç° Unpin
- ä½ å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹æ³•ä¸ºè‡ªå·±çš„ç±»å‹æ·»åŠ  !Unpin çº¦æŸï¼š
    - ä½¿ç”¨æ–‡ä¸­æåˆ°çš„ std::marker::PhantomPinned
    - ä½¿ç”¨nightly ç‰ˆæœ¬ä¸‹çš„ feature flag
- å¯ä»¥å°†å€¼å›ºå®šåˆ°æ ˆä¸Šï¼Œä¹Ÿå¯ä»¥å›ºå®šåˆ°å †ä¸Š
    - å°† !Unpin å€¼å›ºå®šåˆ°æ ˆä¸Šéœ€è¦ä½¿ç”¨ unsafe
    - å°† !Unpin å€¼å›ºå®šåˆ°å †ä¸Šæ— éœ€ unsafe ï¼Œå¯ä»¥é€šè¿‡ Box::pin æ¥ç®€å•çš„å®ç°
- å½“å›ºå®šç±»å‹ T: !Unpin æ—¶ï¼Œä½ éœ€è¦ä¿è¯æ•°æ®ä»è¢«å›ºå®šåˆ°è¢« drop è¿™æ®µæ—¶æœŸå†…ï¼Œå…¶å†…å­˜ä¸ä¼šå˜å¾—éæ³•æˆ–è€…è¢«é‡ç”¨
### async/await å’Œ Stream æµå¤„ç†
#### async/await å’Œ Stream æµå¤„ç†
async å…è®¸æˆ‘ä»¬ä½¿ç”¨ move å…³é”®å­—æ¥å°†ç¯å¢ƒä¸­å˜é‡çš„æ‰€æœ‰æƒè½¬ç§»åˆ°è¯­å¥å—å†…ï¼Œå°±åƒé—­åŒ…é‚£æ ·ï¼Œå¥½å¤„æ˜¯ä½ ä¸å†å‘æ„è¯¥å¦‚ä½•è§£å†³å€Ÿç”¨ç”Ÿå‘½å‘¨æœŸçš„é—®é¢˜ï¼Œåå¤„å°±æ˜¯æ— æ³•è·Ÿå…¶å®ƒä»£ç å®ç°å¯¹å˜é‡çš„å…±äº«.
```rs
// `foo()`è¿”å›ä¸€ä¸ª`Future<Output = u8>`,
// å½“è°ƒç”¨`foo().await`æ—¶ï¼Œè¯¥`Future`å°†è¢«è¿è¡Œï¼Œå½“è°ƒç”¨ç»“æŸåæˆ‘ä»¬å°†è·å–åˆ°ä¸€ä¸ª`u8`å€¼
async fn foo() -> u8 { 5 }

fn bar() -> impl Future<Output = u8> {
    // ä¸‹é¢çš„`async`è¯­å¥å—è¿”å›`Future<Output = u8>`
    async {
        let x: u8 = foo().await;
        x + 5
    }
}
```

async æ˜¯æ‡’æƒ°çš„ï¼Œç›´åˆ°è¢«æ‰§è¡Œå™¨ poll æˆ–è€… .await åæ‰ä¼šå¼€å§‹è¿è¡Œï¼Œå…¶ä¸­åè€…æ˜¯æœ€å¸¸ç”¨çš„è¿è¡Œ Future çš„æ–¹æ³•ã€‚ å½“ .await è¢«è°ƒç”¨æ—¶ï¼Œå®ƒä¼šå°è¯•è¿è¡Œ Future ç›´åˆ°å®Œæˆï¼Œä½†æ˜¯è‹¥è¯¥ Future è¿›å…¥é˜»å¡ï¼Œé‚£å°±ä¼šè®©å‡ºå½“å‰çº¿ç¨‹çš„æ§åˆ¶æƒã€‚å½“ Future åé¢å‡†å¤‡å†ä¸€æ¬¡è¢«è¿è¡Œæ—¶(ä¾‹å¦‚ä» socket ä¸­è¯»å–åˆ°äº†æ•°æ®)ï¼Œæ‰§è¡Œå™¨ä¼šå¾—åˆ°é€šçŸ¥ï¼Œå¹¶å†æ¬¡è¿è¡Œè¯¥ Future ï¼Œå¦‚æ­¤å¾ªç¯ï¼Œç›´åˆ°å®Œæˆã€‚
#### async çš„ç”Ÿå‘½å‘¨æœŸ
async fn å‡½æ•°å¦‚æœæ‹¥æœ‰å¼•ç”¨ç±»å‹çš„å‚æ•°ï¼Œé‚£å®ƒè¿”å›çš„ Future çš„ç”Ÿå‘½å‘¨æœŸå°±ä¼šè¢«è¿™äº›å‚æ•°çš„ç”Ÿå‘½å‘¨æœŸæ‰€é™åˆ¶:
```rs
async fn foo(x: &u8) -> u8 { *x }

// ä¸Šé¢çš„å‡½æ•°è·Ÿä¸‹é¢çš„å‡½æ•°æ˜¯ç­‰ä»·çš„:
    async move { *x }
}
```

æ„å‘³ç€ async fn å‡½æ•°è¿”å›çš„ Future å¿…é¡»æ»¡è¶³ä»¥ä¸‹æ¡ä»¶: å½“ x ä¾ç„¶æœ‰æ•ˆæ—¶ï¼Œ è¯¥ Future å°±å¿…é¡»ç»§ç»­ç­‰å¾…( .await ), ä¹Ÿå°±æ˜¯è¯´ x å¿…é¡»æ¯” Future æ´»å¾—æ›´ä¹…ã€‚

åœ¨ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œåœ¨å‡½æ•°è°ƒç”¨åå°±ç«‹å³ .await ä¸ä¼šå­˜åœ¨ä»»ä½•é—®é¢˜ï¼Œä¾‹å¦‚foo(&x).awaitã€‚ä½†æ˜¯ï¼Œè‹¥ Future è¢«å…ˆå­˜èµ·æ¥æˆ–å‘é€åˆ°å¦ä¸€ä¸ªä»»åŠ¡æˆ–è€…çº¿ç¨‹ï¼Œå°±å¯èƒ½å­˜åœ¨é—®é¢˜äº†:
```rs
use std::future::Future;
fn bad() -> impl Future<Output = u8> {
    let x = 5;
    borrow_x(&x) // ERROR: `x` does not live long enough
}

async fn borrow_x(x: &u8) -> u8 { *x }

```


ä»¥ä¸Šä»£ç ä¼šæŠ¥é”™ï¼Œå› ä¸º x çš„ç”Ÿå‘½å‘¨æœŸåªåˆ° bad å‡½æ•°çš„ç»“å°¾ã€‚ ä½†æ˜¯ Future æ˜¾ç„¶ä¼šæ´»å¾—æ›´ä¹…ï¼š
```shell
error[E0597]: `x` does not live long enough
 --> src/main.rs:4:14
  |
4 |     borrow_x(&x) // ERROR: `x` does not live long enough
  |     ---------^^-
  |     |        |
  |     |        borrowed value does not live long enough
  |     argument requires that `x` is borrowed for `'static`
5 | }
  | - `x` dropped here while still borrowed
```
å…¶ä¸­ä¸€ä¸ªå¸¸ç”¨çš„è§£å†³æ–¹æ³•å°±æ˜¯å°†å…·æœ‰å¼•ç”¨å‚æ•°çš„ async fn å‡½æ•°è½¬å˜æˆä¸€ä¸ªå…·æœ‰ 'static ç”Ÿå‘½å‘¨æœŸçš„ Future ã€‚ ä»¥ä¸Šè§£å†³æ–¹æ³•å¯ä»¥é€šè¿‡å°†å‚æ•°å’Œå¯¹ async fn çš„è°ƒç”¨æ”¾åœ¨åŒä¸€ä¸ª async è¯­å¥å—æ¥å®ç°:
```rs
use std::future::Future;

async fn borrow_x(x: &u8) -> u8 { *x }

fn good() -> impl Future<Output = u8> {
    async {
        let x = 5;
        borrow_x(&x).await
    }
}
```

å¦‚ä¸Šæ‰€ç¤ºï¼Œé€šè¿‡å°†å‚æ•°ç§»åŠ¨åˆ° async è¯­å¥å—å†…ï¼Œ æˆ‘ä»¬å°†å®ƒçš„ç”Ÿå‘½å‘¨æœŸæ‰©å±•åˆ° 'staticï¼Œ å¹¶è·Ÿè¿”å›çš„ Future ä¿æŒäº†ä¸€è‡´ã€‚

#### async move
async å…è®¸æˆ‘ä»¬ä½¿ç”¨ move å…³é”®å­—æ¥å°†ç¯å¢ƒä¸­å˜é‡çš„æ‰€æœ‰æƒè½¬ç§»åˆ°è¯­å¥å—å†…ï¼Œå°±åƒé—­åŒ…é‚£æ ·ï¼Œå¥½å¤„æ˜¯ä½ ä¸å†å‘æ„è¯¥å¦‚ä½•è§£å†³å€Ÿç”¨ç”Ÿå‘½å‘¨æœŸçš„é—®é¢˜ï¼Œåå¤„å°±æ˜¯æ— æ³•è·Ÿå…¶å®ƒä»£ç å®ç°å¯¹å˜é‡çš„å…±äº«:
```rs
// å¤šä¸ªä¸åŒçš„ `async` è¯­å¥å—å¯ä»¥è®¿é—®åŒä¸€ä¸ªæœ¬åœ°å˜é‡ï¼Œåªè¦å®ƒä»¬åœ¨è¯¥å˜é‡çš„ä½œç”¨åŸŸå†…æ‰§è¡Œ
async fn blocks() {
    let my_string = "foo".to_string();

    let future_one = async {
        // ...
        println!("{my_string}");
    };

    let future_two = async {
        // ...
        println!("{my_string}");
    };

    // è¿è¡Œä¸¤ä¸ª Future ç›´åˆ°å®Œæˆ
    let ((), ()) = futures::join!(future_one, future_two);
}

// ç”±äº `async move` ä¼šæ•è·ç¯å¢ƒä¸­çš„å˜é‡ï¼Œå› æ­¤åªæœ‰ä¸€ä¸ª `async move` è¯­å¥å—å¯ä»¥è®¿é—®è¯¥å˜é‡ï¼Œ
// ä½†æ˜¯å®ƒä¹Ÿæœ‰éå¸¸æ˜æ˜¾çš„å¥½å¤„ï¼š å˜é‡å¯ä»¥è½¬ç§»åˆ°è¿”å›çš„ Future ä¸­ï¼Œä¸å†å—å€Ÿç”¨ç”Ÿå‘½å‘¨æœŸçš„é™åˆ¶
fn move_block() -> impl Future<Output = ()> {
    let my_string = "foo".to_string();
    async move {
        // ...
        println!("{my_string}");
    }
}
```

#### å½“.await é‡è§å¤šçº¿ç¨‹æ‰§è¡Œå™¨
éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå½“ä½¿ç”¨å¤šçº¿ç¨‹ Future æ‰§è¡Œå™¨( executor )æ—¶ï¼Œ Future å¯èƒ½ä¼šåœ¨çº¿ç¨‹é—´è¢«ç§»åŠ¨ï¼Œå› æ­¤ async è¯­å¥å—ä¸­çš„å˜é‡å¿…é¡»è¦èƒ½åœ¨çº¿ç¨‹é—´ä¼ é€’ã€‚ è‡³äº Future ä¼šåœ¨çº¿ç¨‹é—´ç§»åŠ¨çš„åŸå› æ˜¯ï¼šå®ƒå†…éƒ¨çš„ä»»ä½•.awaitéƒ½å¯èƒ½å¯¼è‡´å®ƒè¢«åˆ‡æ¢åˆ°ä¸€ä¸ªæ–°çº¿ç¨‹ä¸Šå»æ‰§è¡Œã€‚

ç”±äºéœ€è¦åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä½¿ç”¨ï¼Œæ„å‘³ç€ Rcã€ RefCell ã€æ²¡æœ‰å®ç° Send çš„æ‰€æœ‰æƒç±»å‹ã€æ²¡æœ‰å®ç° Sync çš„å¼•ç”¨ç±»å‹ï¼Œå®ƒä»¬éƒ½æ˜¯ä¸å®‰å…¨çš„ï¼Œå› æ­¤æ— æ³•è¢«ä½¿ç”¨

éœ€è¦æ³¨æ„ï¼å®é™…ä¸Šå®ƒä»¬è¿˜æ˜¯æœ‰å¯èƒ½è¢«ä½¿ç”¨çš„ï¼Œåªè¦åœ¨ .await è°ƒç”¨æœŸé—´ï¼Œå®ƒä»¬æ²¡æœ‰åœ¨ä½œç”¨åŸŸèŒƒå›´å†…ã€‚

ç±»ä¼¼çš„åŸå› ï¼Œåœ¨ .await æ—¶ä½¿ç”¨æ™®é€šçš„é”ä¹Ÿä¸å®‰å…¨ï¼Œä¾‹å¦‚ Mutex ã€‚åŸå› æ˜¯ï¼Œå®ƒå¯èƒ½ä¼šå¯¼è‡´çº¿ç¨‹æ± è¢«é”ï¼šå½“ä¸€ä¸ªä»»åŠ¡è·å–é” A åï¼Œè‹¥å®ƒå°†çº¿ç¨‹çš„æ§åˆ¶æƒè¿˜ç»™æ‰§è¡Œå™¨ï¼Œç„¶åæ‰§è¡Œå™¨åˆè°ƒåº¦è¿è¡Œå¦ä¸€ä¸ªä»»åŠ¡ï¼Œè¯¥ä»»åŠ¡ä¹Ÿå»å°è¯•è·å–äº†é” A ï¼Œç»“æœå½“å‰çº¿ç¨‹ä¼šç›´æ¥å¡æ­»ï¼Œæœ€ç»ˆé™·å…¥æ­»é”ä¸­ã€‚

å› æ­¤ï¼Œä¸ºäº†é¿å…è¿™ç§æƒ…å†µçš„å‘ç”Ÿï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨ futures åŒ…ä¸‹çš„é” futures::lock æ¥æ›¿ä»£ Mutex å®Œæˆä»»åŠ¡ã€‚

#### Stream æµå¤„ç†
Stream ç‰¹å¾ç±»ä¼¼äº Future ç‰¹å¾ï¼Œä½†æ˜¯å‰è€…åœ¨å®Œæˆå‰å¯ä»¥ç”Ÿæˆå¤šä¸ªå€¼ï¼Œè¿™ç§è¡Œä¸ºè·Ÿæ ‡å‡†åº“ä¸­çš„ Iterator ç‰¹å¾å€’æ˜¯é¢‡ä¸ºç›¸ä¼¼ã€‚
```rs
trait Stream {
    // Streamç”Ÿæˆçš„å€¼çš„ç±»å‹
    type Item;

    // å°è¯•å»è§£æStreamä¸­çš„ä¸‹ä¸€ä¸ªå€¼,
    // è‹¥æ— æ•°æ®ï¼Œè¿”å›`Poll::Pending`, è‹¥æœ‰æ•°æ®ï¼Œè¿”å› `Poll::Ready(Some(x))`, `Stream`å®Œæˆåˆ™è¿”å› `Poll::Ready(None)`
    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>)
        -> Poll<Option<Self::Item>>;
}

```

å…³äº Stream çš„ä¸€ä¸ªå¸¸è§ä¾‹å­æ˜¯æ¶ˆæ¯é€šé“ï¼ˆ futures åŒ…ä¸­çš„ï¼‰çš„æ¶ˆè´¹è€… Receiverã€‚æ¯æ¬¡æœ‰æ¶ˆæ¯ä» Send ç«¯å‘é€åï¼Œå®ƒéƒ½å¯ä»¥æ¥æ”¶åˆ°ä¸€ä¸ª Some(val) å€¼ï¼Œ ä¸€æ—¦ Send ç«¯å…³é—­( drop )ï¼Œä¸”æ¶ˆæ¯é€šé“ä¸­æ²¡æœ‰æ¶ˆæ¯åï¼Œå®ƒä¼šæ¥æ”¶åˆ°ä¸€ä¸ª None å€¼ã€‚
```rs
async fn send_recv() {
    const BUFFER_SIZE: usize = 10;
    let (mut tx, mut rx) = mpsc::channel::<i32>(BUFFER_SIZE);

    tx.send(1).await.unwrap();
    tx.send(2).await.unwrap();
    drop(tx);

    // `StreamExt::next` ç±»ä¼¼äº `Iterator::next`, ä½†æ˜¯å‰è€…è¿”å›çš„ä¸æ˜¯å€¼ï¼Œè€Œæ˜¯ä¸€ä¸ª `Future<Output = Option<T>>`ï¼Œ
    // å› æ­¤è¿˜éœ€è¦ä½¿ç”¨`.await`æ¥è·å–å…·ä½“çš„å€¼
    assert_eq!(Some(1), rx.next().await);
    assert_eq!(Some(2), rx.next().await);
    assert_eq!(None, rx.next().await);
}
```

#### è¿­ä»£å’Œå¹¶å‘
è·Ÿè¿­ä»£å™¨ç±»ä¼¼ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥è¿­ä»£ä¸€ä¸ª Streamã€‚ ä¾‹å¦‚ä½¿ç”¨ mapï¼Œfilterï¼Œfold æ–¹æ³•ï¼Œä»¥åŠå®ƒä»¬çš„é‡åˆ°é”™è¯¯æå‰è¿”å›çš„ç‰ˆæœ¬ï¼š try_mapï¼Œtry_filterï¼Œtry_foldã€‚

ä½†æ˜¯è·Ÿè¿­ä»£å™¨åˆæœ‰æ‰€ä¸åŒï¼Œfor å¾ªç¯æ— æ³•åœ¨è¿™é‡Œä½¿ç”¨ï¼Œä½†æ˜¯å‘½ä»¤å¼é£æ ¼çš„å¾ªç¯while letæ˜¯å¯ä»¥ç”¨çš„ï¼ŒåŒæ—¶è¿˜å¯ä»¥ä½¿ç”¨next å’Œ try_next æ–¹æ³•:
```rs
async fn sum_with_next(mut stream: Pin<&mut dyn Stream<Item = i32>>) -> i32 {
    use futures::stream::StreamExt; // å¼•å…¥ next
    let mut sum = 0;
    while let Some(item) = stream.next().await {
        sum += item;
    }
    sum
}

async fn sum_with_try_next(
    mut stream: Pin<&mut dyn Stream<Item = Result<i32, io::Error>>>,
) -> Result<i32, io::Error> {
    use futures::stream::TryStreamExt; // å¼•å…¥ try_next
    let mut sum = 0;
    while let Some(item) = stream.try_next().await? {
        sum += item;
    }
    Ok(sum)
}
```

ä¸Šé¢ä»£ç æ˜¯ä¸€æ¬¡å¤„ç†ä¸€ä¸ªå€¼çš„æ¨¡å¼ï¼Œä½†æ˜¯éœ€è¦æ³¨æ„çš„æ˜¯ï¼šå¦‚æœä½ é€‰æ‹©ä¸€æ¬¡å¤„ç†ä¸€ä¸ªå€¼çš„æ¨¡å¼ï¼Œå¯èƒ½ä¼šé€ æˆæ— æ³•å¹¶å‘ï¼Œè¿™å°±å¤±å»äº†å¼‚æ­¥ç¼–ç¨‹çš„æ„ä¹‰ã€‚ å› æ­¤ï¼Œå¦‚æœå¯ä»¥çš„è¯æˆ‘ä»¬è¿˜æ˜¯è¦é€‰æ‹©ä»ä¸€ä¸ª Stream å¹¶å‘å¤„ç†å¤šä¸ªå€¼çš„æ–¹å¼ï¼Œé€šè¿‡ for_each_concurrent æˆ– try_for_each_concurrent æ–¹æ³•æ¥å®ç°:
```rs
async fn jump_around(
    mut stream: Pin<&mut dyn Stream<Item = Result<u8, io::Error>>>,
) -> Result<(), io::Error> {
    use futures::stream::TryStreamExt; // å¼•å…¥ `try_for_each_concurrent`
    const MAX_CONCURRENT_JUMPERS: usize = 100;

    stream.try_for_each_concurrent(MAX_CONCURRENT_JUMPERS, |num| async move {
        jump_n_times(num).await?;
        report_n_jumps(num).await?;
        Ok(())
    }).await?;

    Ok(())
}
```

### ä½¿ç”¨ join! å’Œ select! åŒæ—¶è¿è¡Œå¤šä¸ª Future
#### join!
futures åŒ…ä¸­æä¾›äº†å¾ˆå¤šå®ç”¨çš„å·¥å…·ï¼Œå…¶ä¸­ä¸€ä¸ªå°±æ˜¯ join! å®ï¼Œ å®ƒå…è®¸æˆ‘ä»¬åŒæ—¶ç­‰å¾…å¤šä¸ªä¸åŒ Future çš„å®Œæˆï¼Œä¸”å¯ä»¥å¹¶å‘åœ°è¿è¡Œè¿™äº› Futureã€‚
```rs
use futures::join;

async fn enjoy_book_and_music() -> (Book, Music) {
    let book_fut = enjoy_book();
    let music_fut = enjoy_music();
    join!(book_fut, music_fut)
}

```
#### try_join!
ç”±äº join! å¿…é¡»ç­‰å¾…å®ƒç®¡ç†çš„æ‰€æœ‰ Future å®Œæˆåæ‰èƒ½å®Œæˆï¼Œå¦‚æœä½ å¸Œæœ›åœ¨æŸä¸€ä¸ª Future æŠ¥é”™åå°±ç«‹å³åœæ­¢æ‰€æœ‰ Future çš„æ‰§è¡Œï¼Œå¯ä»¥ä½¿ç”¨ try_join!ï¼Œç‰¹åˆ«æ˜¯å½“ Future è¿”å› Result æ—¶:
```rs
use futures::{
    future::TryFutureExt,
    try_join,
};

async fn get_book() -> Result<Book, ()> { /* ... */ Ok(Book) }
async fn get_music() -> Result<Music, String> { /* ... */ Ok(Music) }

async fn get_book_and_music() -> Result<(Book, Music), String> {
    let book_fut = get_book().map_err(|()| "Unable to get book".to_string());
    let music_fut = get_music();
    try_join!(book_fut, music_fut)
}

```
#### select!
join! åªæœ‰ç­‰æ‰€æœ‰ Future ç»“æŸåï¼Œæ‰èƒ½é›†ä¸­å¤„ç†ç»“æœï¼Œå¦‚æœä½ æƒ³åŒæ—¶ç­‰å¾…å¤šä¸ª Future ï¼Œä¸”ä»»ä½•ä¸€ä¸ª Future ç»“æŸåï¼Œéƒ½å¯ä»¥ç«‹å³è¢«å¤„ç†ï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨ futures::select!:
```rs
use futures::{
    future::FutureExt, // for `.fuse()`
    pin_mut,
    select,
};

async fn task_one() { /* ... */ }
async fn task_two() { /* ... */ }

async fn race_tasks() {
    let t1 = task_one().fuse();
    let t2 = task_two().fuse();

    pin_mut!(t1, t2);

    select! {
        () = t1 => println!("ä»»åŠ¡1ç‡å…ˆå®Œæˆ"),
        () = t2 => println!("ä»»åŠ¡2ç‡å…ˆå®Œæˆ"),
    }
}
```
#### default å’Œ complete
- select!è¿˜æ”¯æŒ default å’Œ complete åˆ†æ”¯:
- complete åˆ†æ”¯å½“æ‰€æœ‰çš„ Future å’Œ Stream å®Œæˆåæ‰ä¼šè¢«æ‰§è¡Œï¼Œå®ƒå¾€å¾€é…åˆ loop ä½¿ç”¨ï¼Œloop ç”¨äºå¾ªç¯å®Œæˆæ‰€æœ‰çš„ Future
default åˆ†æ”¯ï¼Œè‹¥æ²¡æœ‰ä»»ä½• Future æˆ– Stream å¤„äº Ready çŠ¶æ€ï¼Œ åˆ™è¯¥åˆ†æ”¯ä¼šè¢«ç«‹å³æ‰§è¡Œ
```rs
use futures::future;
use futures::select;
pub fn main() {
    let mut a_fut = future::ready(4);
    let mut b_fut = future::ready(6);
    let mut total = 0;

    loop {
        select! {
            a = a_fut => total += a,
            b = b_fut => total += b,
            complete => break,
            default => panic!(), // è¯¥åˆ†æ”¯æ°¸è¿œä¸ä¼šè¿è¡Œï¼Œå› ä¸º `Future` ä¼šå…ˆè¿è¡Œï¼Œç„¶åæ˜¯ `complete`
        };
    }
    assert_eq!(total, 10);
}
```
#### è·Ÿ Unpin å’Œ FusedFuture è¿›è¡Œäº¤äº’
é¦–å…ˆï¼Œ.fuse() æ–¹æ³•å¯ä»¥è®© Future å®ç° FusedFuture ç‰¹å¾ï¼Œ è€Œ pin_mut! å®ä¼šä¸º Future å®ç° Unpin ç‰¹å¾ï¼Œè¿™ä¸¤ä¸ªç‰¹å¾æ°æ°æ˜¯ä½¿ç”¨ select æ‰€å¿…é¡»çš„:

- Unpinï¼Œç”±äº select ä¸ä¼šé€šè¿‡æ‹¿èµ°æ‰€æœ‰æƒçš„æ–¹å¼ä½¿ç”¨ Futureï¼Œè€Œæ˜¯é€šè¿‡å¯å˜å¼•ç”¨çš„æ–¹å¼å»ä½¿ç”¨ï¼Œè¿™æ ·å½“ select ç»“æŸåï¼Œè¯¥ Future è‹¥æ²¡æœ‰è¢«å®Œæˆï¼Œå®ƒçš„æ‰€æœ‰æƒè¿˜å¯ä»¥ç»§ç»­è¢«å…¶å®ƒä»£ç ä½¿ç”¨ã€‚
- FusedFuture çš„åŸå› è·Ÿä¸Šé¢ç±»ä¼¼ï¼Œå½“ Future ä¸€æ—¦å®Œæˆåï¼Œé‚£ select å°±ä¸èƒ½å†å¯¹å…¶è¿›è¡Œè½®è¯¢ä½¿ç”¨ã€‚Fuse æ„å‘³ç€ç†”æ–­ï¼Œç›¸å½“äº Future ä¸€æ—¦å®Œæˆï¼Œå†æ¬¡è°ƒç”¨ poll ä¼šç›´æ¥è¿”å› Poll::Pendingã€‚
åªæœ‰å®ç°äº† FusedFutureï¼Œselect æ‰èƒ½é…åˆ loop ä¸€èµ·ä½¿ç”¨ã€‚å‡å¦‚æ²¡æœ‰å®ç°ï¼Œå°±ç®—ä¸€ä¸ª Future å·²ç»å®Œæˆäº†ï¼Œå®ƒä¾ç„¶ä¼šè¢« select ä¸åœçš„è½®è¯¢æ‰§è¡Œã€‚

Stream ç¨æœ‰ä¸åŒï¼Œå®ƒä»¬ä½¿ç”¨çš„ç‰¹å¾æ˜¯ FusedStreamã€‚ é€šè¿‡ .fuse()(ä¹Ÿå¯ä»¥æ‰‹åŠ¨å®ç°)å®ç°äº†è¯¥ç‰¹å¾çš„ Streamï¼Œå¯¹å…¶è°ƒç”¨ .next() æˆ– .try_next() æ–¹æ³•å¯ä»¥è·å–å®ç°äº† FusedFuture ç‰¹å¾çš„Future:

```rs

use futures::{
    stream::{Stream, StreamExt, FusedStream},
    select,
};

async fn add_two_streams(
    mut s1: impl Stream<Item = u8> + FusedStream + Unpin,
    mut s2: impl Stream<Item = u8> + FusedStream + Unpin,
) -> u8 {
    let mut total = 0;

    loop {
        let item = select! {
            x = s1.next() => x,
            x = s2.next() => x,
            complete => break,
        };
        if let Some(next_num) = item {
            total += next_num;
        }
    }

    total
}

```
#### åœ¨ select å¾ªç¯ä¸­å¹¶å‘
ä¸€ä¸ªå¾ˆå®ç”¨ä½†åˆé²œä¸ºäººçŸ¥çš„å‡½æ•°æ˜¯ Fuse::terminated() ï¼Œå¯ä»¥ä½¿ç”¨å®ƒæ„å»ºä¸€ä¸ªç©ºçš„ Future ï¼Œç©ºè‡ªç„¶æ²¡å•¥ç”¨ï¼Œä½†æ˜¯å¦‚æœå®ƒèƒ½åœ¨åé¢å†è¢«å¡«å……å‘¢ï¼Ÿ

è€ƒè™‘ä»¥ä¸‹åœºæ™¯ï¼šå½“ä½ è¦åœ¨ select å¾ªç¯ä¸­è¿è¡Œä¸€ä¸ªä»»åŠ¡ï¼Œä½†æ˜¯è¯¥ä»»åŠ¡å´æ˜¯åœ¨ select å¾ªç¯å†…éƒ¨åˆ›å»ºæ—¶ï¼Œä¸Šé¢çš„å‡½æ•°å°±éå¸¸å¥½ç”¨äº†ã€‚
```rs
use futures::{
    future::{Fuse, FusedFuture, FutureExt},
    stream::{FusedStream, Stream, StreamExt},
    pin_mut,
    select,
};

async fn get_new_num() -> u8 { /* ... */ 5 }

async fn run_on_new_num(_: u8) { /* ... */ }

async fn run_loop(
    mut interval_timer: impl Stream<Item = ()> + FusedStream + Unpin,
    starting_num: u8,
) {
    let run_on_new_num_fut = run_on_new_num(starting_num).fuse();
    let get_new_num_fut = Fuse::terminated();
    pin_mut!(run_on_new_num_fut, get_new_num_fut);
    loop {
        select! {
            () = interval_timer.select_next_some() => {
                // å®šæ—¶å™¨å·²ç»“æŸï¼Œè‹¥`get_new_num_fut`æ²¡æœ‰åœ¨è¿è¡Œï¼Œå°±åˆ›å»ºä¸€ä¸ªæ–°çš„
                if get_new_num_fut.is_terminated() {
                    get_new_num_fut.set(get_new_num().fuse());
                }
            },
            new_num = get_new_num_fut => {
                // æ”¶åˆ°æ–°çš„æ•°å­— -- åˆ›å»ºä¸€ä¸ªæ–°çš„`run_on_new_num_fut`å¹¶ä¸¢å¼ƒæ‰æ—§çš„
                run_on_new_num_fut.set(run_on_new_num(new_num).fuse());
            },
            // è¿è¡Œ `run_on_new_num_fut`
            () = run_on_new_num_fut => {},
            // è‹¥æ‰€æœ‰ä»»åŠ¡éƒ½å®Œæˆï¼Œç›´æ¥ `panic`ï¼Œ åŸå› æ˜¯ `interval_timer` åº”è¯¥è¿ç»­ä¸æ–­çš„äº§ç”Ÿå€¼ï¼Œè€Œä¸æ˜¯ç»“æŸ
            //åï¼Œæ‰§è¡Œåˆ° `complete` åˆ†æ”¯
            complete => panic!("`interval_timer` completed unexpectedly"),
        }
    }
}

```

å½“æŸä¸ª Future æœ‰å¤šä¸ªæ‹·è´éƒ½éœ€è¦åŒæ—¶è¿è¡Œæ—¶ï¼Œå¯ä»¥ä½¿ç”¨ FuturesUnordered ç±»å‹ã€‚ä¸‹é¢çš„ä¾‹å­è·Ÿä¸Šä¸ªä¾‹å­å¤§ä½“ç›¸ä¼¼ï¼Œä½†æ˜¯å®ƒä¼šå°† run_on_new_num_fut çš„æ¯ä¸€ä¸ªæ‹·è´éƒ½è¿è¡Œåˆ°å®Œæˆï¼Œè€Œä¸æ˜¯åƒä¹‹å‰é‚£æ ·ä¸€æ—¦åˆ›å»ºæ–°çš„å°±ç»ˆæ­¢æ—§çš„ã€‚

```rs
use futures::{
    future::{Fuse, FusedFuture, FutureExt},
    stream::{FusedStream, FuturesUnordered, Stream, StreamExt},
    pin_mut,
    select,
};

async fn get_new_num() -> u8 { /* ... */ 5 }

async fn run_on_new_num(_: u8) -> u8 { /* ... */ 5 }


// ä½¿ç”¨ä» `get_new_num` è·å–çš„æœ€æ–°æ•°å­— æ¥è¿è¡Œ `run_on_new_num`
//
// æ¯å½“è®¡æ—¶å™¨ç»“æŸåï¼Œ`get_new_num` å°±ä¼šè¿è¡Œä¸€æ¬¡ï¼Œå®ƒä¼šç«‹å³å–æ¶ˆå½“å‰æ­£åœ¨è¿è¡Œçš„`run_on_new_num` ,
// å¹¶ä¸”ä½¿ç”¨æ–°è¿”å›çš„å€¼æ¥æ›¿æ¢
async fn run_loop(
    mut interval_timer: impl Stream<Item = ()> + FusedStream + Unpin,
    starting_num: u8,
) {
    let mut run_on_new_num_futs = FuturesUnordered::new();
    run_on_new_num_futs.push(run_on_new_num(starting_num));
    let get_new_num_fut = Fuse::terminated();
    pin_mut!(get_new_num_fut);
    loop {
        select! {
            () = interval_timer.select_next_some() => {
                 // å®šæ—¶å™¨å·²ç»“æŸï¼Œè‹¥ `get_new_num_fut` æ²¡æœ‰åœ¨è¿è¡Œï¼Œå°±åˆ›å»ºä¸€ä¸ªæ–°çš„
                if get_new_num_fut.is_terminated() {
                    get_new_num_fut.set(get_new_num().fuse());
                }
            },
            new_num = get_new_num_fut => {
                 // æ”¶åˆ°æ–°çš„æ•°å­— -- åˆ›å»ºä¸€ä¸ªæ–°çš„ `run_on_new_num_fut` (å¹¶æ²¡æœ‰åƒä¹‹å‰çš„ä¾‹å­é‚£æ ·ä¸¢å¼ƒæ‰æ—§å€¼)
                run_on_new_num_futs.push(run_on_new_num(new_num));
            },
            // è¿è¡Œ `run_on_new_num_futs`, å¹¶æ£€æŸ¥æ˜¯å¦æœ‰å·²ç»å®Œæˆçš„
            res = run_on_new_num_futs.select_next_some() => {
                println!("run_on_new_num_fut returned {:?}", res);
            },
            // è‹¥æ‰€æœ‰ä»»åŠ¡éƒ½å®Œæˆï¼Œç›´æ¥ `panic`ï¼Œ åŸå› æ˜¯ `interval_timer` åº”è¯¥è¿ç»­ä¸æ–­çš„äº§ç”Ÿå€¼ï¼Œè€Œä¸æ˜¯ç»“æŸ
            //åï¼Œæ‰§è¡Œåˆ° `complete` åˆ†æ”¯
            complete => panic!("`interval_timer` completed unexpectedly"),
        }
    }
}

```

# å®ç¼–ç¨‹
## è¯­æ³•æ‹“å±•
### æºä»£ç è§£ææ–¹å¼
#### æ ‡è¯†åŒ– (Tokenization)
Rustç¨‹åºç¼–è¯‘è¿‡ç¨‹çš„ç¬¬ä¸€é˜¶æ®µæ˜¯ æ ‡è®°è§£æã€‚ åœ¨è¿™ä¸€è¿‡ç¨‹ä¸­ï¼Œæºä»£ç å°†è¢«è½¬æ¢æˆä¸€ç³»åˆ—çš„æ ‡è®° (token)ã€‚

æŸäº›è¯­è¨€çš„å®ç³»ç»Ÿæ­£æ‰æ ¹äºè¿™ä¸€é˜¶æ®µã€‚Rustå¹¶éå¦‚æ­¤ã€‚ ä¸¾ä¾‹æ¥è¯´ï¼Œä»æ•ˆæœæ¥çœ‹ï¼ŒC/C++çš„å®å°±æ˜¯åœ¨è¿™é‡Œå¾—åˆ°å¤„ç†çš„ã€‚3 è¿™ä¹Ÿæ­£æ˜¯ä¸‹åˆ—ä»£ç èƒ½å¤Ÿè¿è¡Œçš„åŸå› : 
```c
#define SUB void
#define BEGIN {
#define END }

SUB main() BEGIN
    printf("Oh, the horror!\n");
END
```
#### è¯­æ³•è§£æ (Parsing)

è¿™ä¸€è¿‡ç¨‹ä¸­ï¼Œä¸€ç³»åˆ—çš„ token å°†è¢«è½¬æ¢æˆä¸€æ£µæŠ½è±¡è¯­æ³•æ ‘ (AST: Abstract Syntax Tree)ã€‚ æ­¤è¿‡ç¨‹å°†åœ¨å†…å­˜ä¸­å»ºç«‹èµ·ç¨‹åºçš„è¯­æ³•ç»“æ„ã€‚

ä¸¾ä¾‹æ¥è¯´ï¼Œæ ‡è®°åºåˆ— 1+2 å°†è¢«è½¬æ¢æˆæŸç§ç±»ä¼¼äº:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ BinOp   â”‚ â”Œâ•´â”‚ LitInt  â”‚
â”‚ op: Add â”‚ â”‚ â”‚ val: 1  â”‚
â”‚ lhs: â—Œ  â”‚â•¶â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚ rhs: â—Œ  â”‚â•¶â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â•´â”‚ LitInt  â”‚
              â”‚ val: 2  â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

AST å°†åŒ…å« æ•´ä¸ª ç¨‹åºçš„ç»“æ„ï¼Œä½†è¿™ä¸€ç»“æ„ä»…åŒ…å«è¯æ³•ä¿¡æ¯ã€‚

ä¸¾ä¾‹æ¥è®²ï¼Œåœ¨è¿™ä¸ªé˜¶æ®µç¼–è¯‘å™¨è™½ç„¶å¯èƒ½çŸ¥é“æŸä¸ªè¡¨è¾¾å¼æåŠäº†æŸä¸ªåä¸º a çš„å˜é‡ï¼Œ ä½†å®ƒå¹¶ æ²¡æœ‰åŠæ³•çŸ¥é“ a ç©¶ç«Ÿæ˜¯ä»€ä¹ˆï¼Œæˆ–è€…å®ƒä»å“ªæ¥ã€‚

åœ¨ AST ç”Ÿæˆä¹‹åï¼Œå®å¤„ç†è¿‡ç¨‹æ‰å¼€å§‹ã€‚
#### æ ‡è®°æ ‘ (Token Trees)
æ ‡è®°æ ‘æ˜¯ä»‹äº æ ‡è®° (token) ä¸ AST ä¹‹é—´çš„ä¸œè¥¿ã€‚

é¦–å…ˆæ˜ç¡®ä¸€ç‚¹ï¼Œå‡ ä¹æ‰€æœ‰æ ‡è®°éƒ½æ„æˆæ ‡è®°æ ‘ã€‚ å…·ä½“æ¥è¯´ï¼Œå®ƒä»¬å¯è¢«çœ‹ä½œæ ‡è®°æ ‘å¶èŠ‚ç‚¹ã€‚ è¿˜æœ‰å¦ä¸€ç±»äº‹ç‰©ä¹Ÿå¯è¢«çœ‹ä½œæ ‡è®°æ ‘å¶èŠ‚ç‚¹ï¼Œæˆ‘ä»¬å°†åœ¨ç¨åæåˆ°å®ƒã€‚

ä»…æœ‰çš„ä¸€ç§åŸºç¡€æ ‡è®°ä¸æ˜¯æ ‡è®°æ ‘å¶èŠ‚ç‚¹â€”â€”â€œåˆ†ç»„â€æ ‡è®°ï¼š(...)ï¼Œ [...] å’Œ {...}ã€‚ è¿™ä¸‰è€…å±äºæ ‡è®°æ ‘å†…çš„èŠ‚ç‚¹ï¼Œæ­£æ˜¯å®ƒä»¬ç»™æ ‡è®°æ ‘å¸¦æ¥äº†æ ‘çŠ¶çš„ç»“æ„ã€‚

ç»™ä¸ªå…·ä½“çš„ä¾‹å­ï¼Œè¿™åˆ—æ ‡è®°ï¼š


a + b + (c + d[0]) + e
å°†è¢«è§£æä¸ºè¿™æ ·çš„æ ‡è®°æ ‘ï¼š


Â«aÂ» Â«+Â» Â«bÂ» Â«+Â» Â«(   )Â» Â«+Â» Â«eÂ»
          â•­â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
           Â«cÂ» Â«+Â» Â«dÂ» Â«[   ]Â»
                        â•­â”€â”´â”€â•®
                         Â«0Â»
æ³¨æ„å®ƒè·Ÿæœ€åç”Ÿæˆçš„ AST å¹¶ æ²¡æœ‰å…³è”ã€‚ AST å°†ä»…æœ‰ä¸€ä¸ªæ ¹èŠ‚ç‚¹ï¼Œè€Œè¿™æ£µæ ‡è®°æ ‘æœ‰ ä¸ƒ ä¸ªã€‚ ä½œä¸ºå‚è€ƒï¼Œæœ€åç”Ÿæˆçš„ AST åº”è¯¥æ˜¯è¿™æ ·ï¼š


              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ BinOp   â”‚
              â”‚ op: Add â”‚
            â”Œâ•´â”‚ lhs: â—Œ  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ rhs: â—Œ  â”‚â•¶â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Var     â”‚â•¶â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â•´â”‚ BinOp   â”‚
â”‚ name: a â”‚                 â”‚ op: Add â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”Œâ•´â”‚ lhs: â—Œ  â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ rhs: â—Œ  â”‚â•¶â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ Var     â”‚â•¶â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â•´â”‚ BinOp   â”‚
              â”‚ name: b â”‚                 â”‚ op: Add â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”Œâ•´â”‚ lhs: â—Œ  â”‚
                            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ rhs: â—Œ  â”‚â•¶â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                            â”‚ BinOp   â”‚â•¶â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â•´â”‚ Var     â”‚
                            â”‚ op: Add â”‚                 â”‚ name: e â”‚
                          â”Œâ•´â”‚ lhs: â—Œ  â”‚                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ rhs: â—Œ  â”‚â•¶â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ Var     â”‚â•¶â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â•´â”‚ Index   â”‚
              â”‚ name: c â”‚               â”Œâ•´â”‚ arr: â—Œ  â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ ind: â—Œ  â”‚â•¶â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                            â”‚ Var     â”‚â•¶â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â•´â”‚ LitInt  â”‚
                            â”‚ name: d â”‚                 â”‚ val: 0  â”‚
                            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
ç†è§£ AST ä¸ æ ‡è®°æ ‘ (token tree) ä¹‹é—´çš„åŒºåˆ«è‡³å…³é‡è¦ã€‚ å†™å®æ—¶ï¼Œä½ å°†åŒæ—¶ä¸è¿™ä¸¤è€…æ‰“äº¤é“ã€‚

è¿˜æœ‰ä¸€æ¡éœ€è¦æ³¨æ„ï¼šä¸å¯èƒ½ å‡ºç°ä¸åŒ¹é…çš„å°/ä¸­/å¤§æ‹¬å·ï¼Œä¹Ÿä¸å¯èƒ½å­˜åœ¨åŒ…å«é”™è¯¯åµŒå¥—ç»“æ„çš„æ ‡è®°æ ‘ã€‚
### AST ä¸­çš„å®
Rust è¯­æ³•åŒ…å«æ•°ç§â€œè¯­æ³•æ‰©å±•â€çš„å½¢å¼ã€‚å…·ä½“æ¥è¯´æœ‰ä»¥ä¸‹å››ç§ï¼ˆé¡ºä¾¿ç»™å‡ºä¾‹å­ï¼‰ï¼š
```rs
# [ $arg ] å½¢å¼ï¼šæ¯”å¦‚ #[derive(Clone)], #[no_mangle]
# ! [ $arg ] å½¢å¼ï¼šæ¯”å¦‚ #![allow(dead_code)], #![crate_name="blang"]
$name ! $arg å½¢å¼ï¼šæ¯”å¦‚ println!("Hi!"), concat!("a", "b"),
$name ! $arg0 $arg1 å½¢å¼ï¼šæ¯”å¦‚ macro_rules! dummy { () => {}; }.
```

å¤´ä¸¤ç§å½¢å¼è¢«ç§°ä½œâ€œå±æ€§â€ (attributes)ã€‚å±æ€§ç”¨æ¥ç»™æ¡ç›® (items) ã€è¡¨è¾¾å¼ã€è¯­å¥åŠ ä¸Šæ³¨è§£ã€‚å±æ€§æœ‰ä¸‰ç±»ï¼š

- å†…ç½®çš„å±æ€§ (built-in attributes)
- è¿‡ç¨‹å®å±æ€§ (proc-macro attributes)
- æ´¾ç”Ÿå±æ€§ (derive attributes)
å†…ç½®çš„å±æ€§ç”±ç¼–è¯‘å™¨å®ç°ã€‚è¿‡ç¨‹å®å±æ€§å’Œæ´¾ç”Ÿå±æ€§åœ¨ Rust ç¬¬äºŒç±»å®ç³»ç»Ÿ â€”â€” è¿‡ç¨‹å® (procedural macros) â€”â€” ä¸­å®ç°ã€‚


æ³¨æ„ç¬¬ 3 ç§å½¢å¼çš„å‡½æ•°å¼å®æ˜¯ä¸€ç§ä¸€èˆ¬çš„è¯­æ³•æ‹“å±•å½¢å¼ï¼Œå¹¶éä»…ç”¨ macro_rules! å†™å‡ºã€‚ æ¯”å¦‚ format! æ˜¯ä¸€ä¸ª macro_rules! å®ï¼Œè€Œç”¨æ¥å®ç° format! çš„ format_args! ä¸æ˜¯è¿™é‡Œè°ˆè®ºçš„å®ï¼ˆå› ä¸ºå®ƒç”±ç¼–è¯‘å™¨å®ç°ï¼Œæ˜¯å†…ç½®çš„å±æ€§ï¼‰ã€‚

ç¬¬å››ç§å½¢å¼æœ¬è´¨ä¸Šæ˜¯å®çš„å˜ç§ã€‚å…¶å®ï¼Œè¿™ç§å½¢å¼çš„å”¯ä¸€ç”¨ä¾‹åªæœ‰ macro_rules!ã€‚




çŸ¥é“è¿™ä¸€ç‚¹åï¼Œè¯­æ³•è§£æå™¨å¦‚ä½•ç†è§£å¦‚ä¸‹è°ƒç”¨å½¢å¼ï¼Œå°±å˜å¾—æ˜¾è€Œæ˜“è§äº†ï¼š
```rs
bitflags! {
    struct Color: u8 {
        const RED    = 0b0001,
        const GREEN  = 0b0010,
        const BLUE   = 0b0100,
        const BRIGHT = 0b1000,
    }
}

lazy_static! {
    static ref FIB_100: u32 = {
        fn fib(a: u32) -> u32 {
            match a {
                0 => 0,
                1 => 1,
                a => fib(a-1) + fib(a-2)
            }
        }

        fib(100)
    };
}

fn main() {
    use Color::*;
    let colors = vec![RED, GREEN, BLUE];
    println!("Hello, World!");
}
```


è™½ç„¶ä¸Šè¿°è°ƒç”¨çœ‹èµ·æ¥åŒ…å«äº†å„å¼å„æ ·çš„ Rust ä»£ç ï¼Œä½†å¯¹è¯­æ³•è§£æå™¨æ¥è¯´ï¼Œå®ƒä»¬ä»…ä»…æ˜¯å †æ— å®é™…æ„ä¹‰çš„æ ‡è®°æ ‘ã€‚

ä¸ºäº†è¯´æ˜é—®é¢˜ï¼Œæˆ‘ä»¬æŠŠæ‰€æœ‰è¿™äº›å¥æ³•â€œé»‘ç›’â€ç”¨ â¬š ä»£æ›¿ï¼Œä»…å‰©ä¸‹ï¼š

```rs
bitflags! â¬š

lazy_static! â¬š

fn main() {
    let colors = vec! â¬š;
    println! â¬š;
}
```

å†æ¬¡é‡ç”³ï¼Œè¯­æ³•è§£æå™¨å¯¹ â¬š ä¸ä½œä»»ä½•å‡è®¾ï¼›å®ƒè®°å½•é»‘ç›’æ‰€åŒ…å«çš„æ ‡è®°ï¼Œä½†å¹¶ä¸å°è¯•ç†è§£å®ƒä»¬ã€‚

è¿™æ„å‘³ç€ â¬š å¯ä»¥æ˜¯ä»»ä½•ä¸œè¥¿ï¼Œç”šè‡³æ˜¯æ— æ•ˆçš„ Rust è¯­æ³•ã€‚

ä»¥ä¸‹å‡ ç‚¹å¾ˆé‡è¦ï¼š

Rust åŒ…å«å¤šç§è¯­æ³•æ‰©å±•ã€‚
- å½“é‡è§å½¢å¦‚ $name! $arg çš„ç»“æ„æ—¶ï¼Œå®ƒå¯èƒ½æ˜¯å…¶å®ƒè¯­æ³•æ‰©å±•ï¼Œæ¯”å¦‚ macro_rules! å®ã€è¿‡ç¨‹å®ç”šè‡³å†…ç½®å®ã€‚
- æ‰€æœ‰ ! å®ï¼ˆå³ç¬¬ 3 ç§å½¢å¼ï¼‰çš„è¾“å…¥éƒ½æ˜¯éå¶èŠ‚ç‚¹çš„å•ä¸ªæ ‡è®°æ ‘ã€‚
- è¯­æ³•æ‰©å±•éƒ½å°†ä½œä¸ºæŠ½è±¡è¯­æ³•æ ‘ (AST) çš„ä¸€éƒ¨åˆ†è¢«è§£æã€‚

æœ€åä¸€ç‚¹æœ€ä¸ºé‡è¦ï¼Œå®ƒå¸¦æ¥äº†ä¸€äº›æ·±è¿œçš„å½±å“ã€‚ç”±äºè¯­æ³•æ‹“å±•å°†è¢«è§£æè¿› AST ä¸­ï¼Œå®ƒä»¬åªèƒ½å‡ºç°åœ¨é‚£äº›æ˜ç¡®æ”¯æŒå®ƒä»¬å‡ºç°çš„ä½ç½®ã€‚å…·ä½“æ¥è¯´ï¼Œè¯­æ³•æ‹“å±•èƒ½åœ¨å¦‚ä¸‹ä½ç½®å‡ºç°ï¼š
- æ¨¡å¼ (pattern)
- è¯­å¥ (statement)
- è¡¨è¾¾å¼ (expression)
- æ¡ç›® (item) ï¼ˆåŒ…æ‹¬ impl å—ï¼‰
- ç±»å‹

ä¸€äº›å¹¶ä¸æ”¯æŒçš„ä½ç½®åŒ…æ‹¬ï¼š

- æ ‡è¯†ç¬¦ (identifier)
- match åˆ†æ”¯

### å±•å¼€
å±•å¼€ç›¸å¯¹ç®€å•ã€‚åœ¨ç”Ÿæˆ AST ä¹‹åï¼Œå’Œç¼–è¯‘å™¨å¯¹ç¨‹åºè¿›è¡Œè¯­ä¹‰ç†è§£ä¹‹å‰ï¼Œç¼–è¯‘å™¨å°†ä¼šå¯¹æ‰€æœ‰è¯­æ³•æ‹“å±•è¿›è¡Œå±•å¼€ã€‚

è¿™ä¸€è¿‡ç¨‹åŒ…æ‹¬ï¼šéå† ASTï¼Œç¡®å®šæ‰€æœ‰è¯­æ³•æ‹“å±•è°ƒç”¨çš„ä½ç½®ï¼Œå¹¶æŠŠå®ƒä»¬æ›¿æ¢æˆå±•å¼€çš„å†…å®¹ã€‚

æ¯å½“ç¼–è¯‘å™¨é‡è§ä¸€ä¸ªè¯­æ³•æ‰©å±•ï¼Œéƒ½ä¼šæ ¹æ®ä¸Šä¸‹æ–‡è§£ææˆæœ‰é™è¯­æ³•å…ƒç´ é›†ä¸­çš„ä¸€ä¸ªã€‚

äº‹å®ä¸Šï¼Œä¸€ä¸ªè¯­ä¹‰æ‰©å±•çš„å±•å¼€ç»“æœä¼šå˜æˆä»¥ä¸‹ä¸€ç§æƒ…å†µï¼š

- ä¸€ä¸ªè¡¨è¾¾å¼
- ä¸€ä¸ªæ¨¡å¼
- ä¸€ä¸ªç±»å‹
- é›¶æˆ–å¤šä¸ªæ¡ç›®ï¼ˆåŒ…æ‹¬çš„ impl å—ï¼‰
- é›¶æˆ–å¤šä¸ªè¯­å¥
æ¢å¥è¯è®²ï¼Œè¯­æ³•æ‹“å±•è°ƒç”¨æ‰€åœ¨çš„ä½ç½®ï¼Œå†³å®šäº†è¯¥è¯­æ³•æ‹“å±•å±•å¼€ç»“æœè¢«è§£è¯»çš„æ–¹å¼ã€‚

ç¼–è¯‘å™¨ä¼šæ“ä½œ AST èŠ‚ç‚¹ï¼ŒæŠŠè¯­æ³•æ‹“å±•è°ƒç”¨å¤„çš„èŠ‚ç‚¹å®Œå…¨æ›¿æ¢æˆè¾“å‡ºçš„èŠ‚ç‚¹ã€‚è¿™ä¸€æ›¿æ¢æ˜¯ç»“æ„æ€§ (structural) çš„ï¼Œè€Œéç»‡æ„æ€§ (textural) çš„ã€‚
```rs
let eight = 2 * four!();
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Let         â”‚
â”‚ name: eight â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ init: â—Œ     â”‚â•¶â”€â•´â”‚ BinOp   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ op: Mul â”‚
                â”Œâ•´â”‚ lhs: â—Œ  â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ rhs: â—Œ  â”‚â•¶â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ LitInt â”‚â•¶â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â•´â”‚ Macro      â”‚
     â”‚ val: 2 â”‚                 â”‚ name: four â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚ body: ()   â”‚
                                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ ¹æ®ä¸Šä¸‹æ–‡ï¼Œfour!() å¿…é¡»å±•å¼€æˆä¸€ä¸ªè¡¨è¾¾å¼ï¼ˆinitializer åªå¯èƒ½æ˜¯è¡¨è¾¾å¼ï¼‰ã€‚å› æ­¤ï¼Œæ— è®ºå®é™…å±•å¼€çš„ç»“æœå¦‚ä½•ï¼Œå®ƒéƒ½å°†è¢«è§£è¯»æˆä¸€ä¸ªå®Œæ•´çš„è¡¨è¾¾å¼ã€‚
æ­¤å¤„å‡è®¾ four! æˆå…¶å±•å¼€ç»“æœä¸ºè¡¨è¾¾å¼ 1 + 3ã€‚æ•…è€Œï¼Œå±•å¼€åå°† AST å˜ä¸ºï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Let         â”‚
â”‚ name: eight â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ init: â—Œ     â”‚â•¶â”€â•´â”‚ BinOp   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ op: Mul â”‚
                â”Œâ•´â”‚ lhs: â—Œ  â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ rhs: â—Œ  â”‚â•¶â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚ LitInt â”‚â•¶â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â•´â”‚ BinOp   â”‚
     â”‚ val: 2 â”‚                 â”‚ op: Add â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”Œâ•´â”‚ lhs: â—Œ  â”‚
                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ rhs: â—Œ  â”‚â•¶â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
                   â”‚ LitInt â”‚â•¶â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â•´â”‚ LitInt â”‚
                   â”‚ val: 1 â”‚                 â”‚ val: 3 â”‚
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜

è¿™åˆèƒ½è¢«é‡å†™æˆï¼š

```rs
let eight = 2 * (1 + 3);
```
è¯­æ³•æ‹“å±•è¢«å½“ä½œ AST èŠ‚ç‚¹å±•å¼€ï¼Œè¿™ä¸€è§‚ç‚¹éå¸¸é‡è¦ï¼Œå®ƒé€ æˆä¸¤å¤§å½±å“ï¼š

- è¯­æ³•æ‹“å±•ä¸ä»…è°ƒç”¨ä½ç½®æœ‰é™åˆ¶ï¼Œå…¶å±•å¼€ç»“æœä¹Ÿåªèƒ½è·Ÿè¯­æ³•è§£æå™¨åœ¨è¯¥ä½ç½®æ‰€é¢„æœŸçš„ AST èŠ‚ç‚¹ç§ç±»ä¸€è‡´ã€‚
- å› æ­¤ï¼Œè¯­æ³•æ‹“å±•å¿…å®šæ— æ³•å±•å¼€æˆä¸å®Œæ•´æˆ–ä¸åˆè¯­æ³•çš„ç»“æ„ã€‚
### å«ç”Ÿæ€§
å«ç”Ÿæ€§ (hygiene) æ˜¯å®çš„ä¸€ä¸ªé‡è¦æ¦‚å¿µã€‚å®ƒæè¿°äº†å®åœ¨å…¶è¯­æ³•ä¸Šä¸‹æ–‡ä¸­å·¥ä½œçš„èƒ½åŠ›ï¼šä¸å½±å“æˆ–ä¸å—å…¶å‘¨å›´ç¯å¢ƒçš„å½±å“ã€‚

ç®€è€Œè¨€ä¹‹ï¼Œå¦‚æœç”±è¯­æ³•æ‰©å±•åˆ›å»ºçš„æ ‡è¯†ç¬¦ä¸èƒ½è¢«è°ƒç”¨è¯¥è¯­æ³•æ‰©å±•çš„ç¯å¢ƒè®¿é—®ï¼Œé‚£ä¹ˆå®ƒå¯¹äºè¯¥æ ‡è¯†ç¬¦æ˜¯å«ç”Ÿçš„ã€‚

åŒæ ·ï¼Œå¦‚æœè¯­æ³•æ‰©å±•ä¸­ä½¿ç”¨çš„æ ‡è¯†ç¬¦ä¸èƒ½å¼•ç”¨åˆ°åœ¨è¯­æ³•æ‰©å±•ä¹‹å¤–å®šä¹‰çš„å†…å®¹ï¼Œåˆ™è¢«è®¤ä¸ºæ˜¯å«ç”Ÿçš„ã€‚

```rs
macro_rules! make_local {
    () => { let local = 0; }
}
fn main() {
    make_local!();
    assert_eq!(local, 0);
}
```
å¦‚æœ assert_eq!(local, 0); ä¸­çš„ local è¢«è§£æä¸ºè¯­æ³•æ‰©å±•æ‰€å®šä¹‰çš„ localï¼Œåˆ™è¯­æ³•æ‰©å±•ä¸æ˜¯å«ç”Ÿçš„ï¼ˆè‡³å°‘åœ¨ local è¿™ä¸ªåç§°/ç»‘å®šæ–¹é¢ä¸æ˜¯å«ç”Ÿçš„ï¼‰ã€‚
### è°ƒè¯•
rustc é€šè¿‡ä¸ç¨³å®šçš„ -Zunpretty=expanded å‚æ•°æ¥æä¾›æŸ¥çœ‹å±•å¼€ä»£ç çš„åŠŸèƒ½ã€‚
```rs
// Shorthand for initializing a `String`.
macro_rules! S {
    ($e:expr) => {String::from($e)};
}

fn main() {
    let world = S!("World");
    println!("Hello, {}!", world);
}
```
rustc +nightly -Zunpretty=expanded hello.rs
```rs
#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2018::*;
#[macro_use]
extern crate std;
// Shorthand for initializing a `String`.
macro_rules! S { ($e : expr) => { String :: from($e) } ; }

fn main() {
    let world = String::from("World");
    {
        ::std::io::_print(
            ::core::fmt::Arguments::new_v1(
                &["Hello, ", "!\n"],
                &match (&world,) {
                    (arg0,) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt)
                    ],
                }
            )
        );
    };
}
```
## å£°æ˜å®
### æ€è·¯ä»‹ç»
#### macro_rules!
macro_rules! æœ¬èº«å°±æ˜¯ä¸€ä¸ªè¯­æ³•æ‰©å±•ï¼Œä¹Ÿå°±æ˜¯ä»æŠ€æœ¯ä¸Šè¯´ï¼Œå®ƒå¹¶ä¸æ˜¯ Rust è¯­æ³•çš„ä¸€éƒ¨åˆ†ã€‚å®ƒçš„å½¢å¼å¦‚ä¸‹ï¼š
```rs
macro_rules! $name {
    $rule0 ;
    $rule1 ;
    // â€¦
    $ruleN ;
}
```
è‡³å°‘å¾—æœ‰ä¸€æ¡è§„åˆ™ï¼Œæ¯æ¡â€œè§„åˆ™â€éƒ½å½¢å¦‚ï¼š
```rs
($matcher) => {$expansion}
```
#### åŒ¹é…
å¯¹æ¯æ¡è§„åˆ™ï¼Œå®ƒéƒ½å°†å°è¯•å°†è¾“å…¥æ ‡è®°æ ‘çš„å†…å®¹ä¸è¯¥è§„åˆ™çš„ matcher è¿›è¡ŒåŒ¹é…ã€‚æŸä¸ª matcher 2 å¿…é¡»ä¸è¾“å…¥å®Œå…¨åŒ¹é…æ‰è¢«è®¤ä¸ºæ˜¯ä¸€æ¬¡åŒ¹é…ã€‚
æœ€ç®€å•çš„ä¾‹å­æ˜¯ç©º matcherï¼š
```rs
macro_rules! four {
    () => { 1 + 3 };
}
```
å½“ä¸”ä»…å½“åŒ¹é…åˆ°ç©ºçš„è¾“å…¥æ—¶ï¼ŒåŒ¹é…æˆåŠŸï¼Œå³ four!()ã€four![] æˆ– four!{} ä¸‰ç§æ–¹å¼è°ƒç”¨æ˜¯åŒ¹é…æˆåŠŸçš„ ã€‚
æ³¨æ„æ‰€ç”¨çš„åˆ†ç»„æ ‡è®°å¹¶ä¸éœ€è¦åŒ¹é…å®šä¹‰æ—¶é‡‡ç”¨çš„åˆ†ç»„æ ‡è®°ï¼Œå› ä¸ºå®é™…ä¸Šåˆ†ç»„æ ‡è®°å¹¶æœªä¼ ç»™è°ƒç”¨ã€‚
æ¯”å¦‚ï¼Œè¦åŒ¹é…æ ‡è®°åºåˆ— 4 fn ['spang "whammo"] @_@ ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·å†™ï¼š
```rs
macro_rules! gibberish {
    (4 fn ['spang "whammo"] @_@) => {...};
}

ä½¿ç”¨ gibberish!(4 fn ['spang "whammo"] @_@]) å³å¯æˆåŠŸåŒ¹é…å’Œè°ƒç”¨ã€‚
```

#### å…ƒå˜é‡
matcher è¿˜å¯ä»¥åŒ…å«æ•è· (captures)ã€‚å³åŸºäºæŸç§é€šç”¨è¯­æ³•ç±»åˆ«æ¥åŒ¹é…è¾“å…¥ï¼Œå¹¶å°†ç»“æœæ•è·åˆ°å…ƒå˜é‡ (metavariable) ä¸­ï¼Œç„¶åå°†æ›¿æ¢å…ƒå˜é‡åˆ°è¾“å‡ºã€‚
æ•è·çš„ä¹¦å†™æ–¹å¼æ˜¯ï¼šå…ˆå†™ç¾å…ƒç¬¦å· $ï¼Œç„¶åè·Ÿä¸€ä¸ªæ ‡è¯†ç¬¦ï¼Œç„¶åæ˜¯å†’å· :ï¼Œæœ€åæ˜¯æ•è·æ–¹å¼ï¼Œæ¯”å¦‚ $e:exprã€‚

æ•è·æ–¹å¼åˆè¢«ç§°ä½œâ€œç‰‡æ®µåˆ†ç±»ç¬¦â€ (fragment-specifier)ï¼Œå¿…é¡»æ˜¯ä»¥ä¸‹ä¸€ç§ï¼š

- blockï¼šä¸€ä¸ªå—ï¼ˆæ¯”å¦‚ä¸€å—è¯­å¥æˆ–è€…ç”±å¤§æ‹¬å·åŒ…å›´çš„ä¸€ä¸ªè¡¨è¾¾å¼ï¼‰
- exprï¼šä¸€ä¸ªè¡¨è¾¾å¼ (expression)
- identï¼šä¸€ä¸ªæ ‡è¯†ç¬¦ (identifier)ï¼ŒåŒ…æ‹¬å…³é”®å­— (keywords)
- itemï¼šä¸€ä¸ªæ¡ç›®ï¼ˆæ¯”å¦‚å‡½æ•°ã€ç»“æ„ä½“ã€æ¨¡å—ã€impl å—ï¼‰
- lifetimeï¼šä¸€ä¸ªç”Ÿå‘½å‘¨æœŸæ³¨è§£ï¼ˆæ¯”å¦‚ 'fooã€'staticï¼‰
- literalï¼šä¸€ä¸ªå­—é¢å€¼ï¼ˆæ¯”å¦‚ "Hello World!"ã€3.14ã€'ğŸ¦€'ï¼‰
- metaï¼šä¸€ä¸ªå…ƒä¿¡æ¯ï¼ˆæ¯”å¦‚ #[...] å’Œ #![...] å±æ€§å†…éƒ¨çš„ä¸œè¥¿ï¼‰
- patï¼šä¸€ä¸ªæ¨¡å¼ (pattern)
- pathï¼šä¸€æ¡è·¯å¾„ï¼ˆæ¯”å¦‚ fooã€::std::mem::replaceã€transmute::<_, int>ï¼‰
- stmtï¼šä¸€æ¡è¯­å¥ (statement)
- ttï¼šå•æ£µæ ‡è®°æ ‘
- tyï¼šä¸€ä¸ªç±»å‹
- visï¼šä¸€ä¸ªå¯èƒ½ä¸ºç©ºçš„å¯è§†æ ‡è¯†ç¬¦ï¼ˆæ¯”å¦‚ pubã€pub(in crate)ï¼‰
```rs
macro_rules! multiply_add {
    ($a:expr, $b:expr, $c:expr) => { $a * ($b + $c) };
}
```
#### åå¤
matcher å¯ä»¥æœ‰åå¤æ•è· (repetition)ï¼Œè¿™ä½¿å¾—åŒ¹é…ä¸€è¿ä¸²æ ‡è®° (token) æˆä¸ºå¯èƒ½ã€‚åå¤æ•è·çš„ä¸€èˆ¬å½¢å¼ä¸º $ ( ... ) sep repã€‚

- $ æ˜¯å­—é¢ä¸Šçš„ç¾å…ƒç¬¦å·æ ‡è®°
- ( ... ) æ˜¯è¢«åå¤åŒ¹é…çš„æ¨¡å¼ï¼Œç”±å°æ‹¬å·åŒ…å›´ã€‚
- sep æ˜¯å¯é€‰çš„åˆ†éš”æ ‡è®°ã€‚å®ƒä¸èƒ½æ˜¯æ‹¬å·æˆ–è€…åå¤æ“ä½œç¬¦ repã€‚å¸¸ç”¨ä¾‹å­æœ‰ , å’Œ ; ã€‚
- rep æ˜¯å¿…é¡»çš„é‡å¤æ“ä½œç¬¦ã€‚å½“å‰å¯ä»¥æ˜¯ï¼š
- ?ï¼šè¡¨ç¤ºæœ€å¤šä¸€æ¬¡é‡å¤ï¼Œæ‰€ä»¥æ­¤æ—¶ä¸èƒ½å‰è·Ÿåˆ†éš”æ ‡è®°ã€‚
- *ï¼šè¡¨ç¤ºé›¶æ¬¡æˆ–å¤šæ¬¡é‡å¤ã€‚
- +ï¼šè¡¨ç¤ºä¸€æ¬¡æˆ–å¤šæ¬¡é‡å¤ã€‚ 
åœ¨ expansion ä¸­ï¼Œä½¿ç”¨è¢«åå¤æ•è·çš„å†…å®¹æ—¶ï¼Œä¹Ÿé‡‡ç”¨ç›¸åŒçš„è¯­æ³•ã€‚è€Œä¸”è¢«åå¤æ•è·çš„å…ƒå˜é‡åªèƒ½å­˜åœ¨äºåå¤è¯­æ³•å†…ã€‚
```rs
macro_rules! vec_strs {
    (
        // å¼€å§‹åå¤æ•è·
        $(
            // æ¯ä¸ªåå¤å¿…é¡»åŒ…å«ä¸€ä¸ªè¡¨è¾¾å¼
            $element:expr
        )
        // ç”±é€—å·åˆ†éš”
        ,
        // 0 æˆ–å¤šæ¬¡
        *
    ) => {
        // åœ¨è¿™ä¸ªå—å†…ç”¨å¤§æ‹¬å·æ‹¬èµ·æ¥ï¼Œç„¶ååœ¨é‡Œé¢å†™å¤šæ¡è¯­å¥
        {
            let mut v = Vec::new();

            // å¼€å§‹åå¤æ•è·
            $(
                // æ¯ä¸ªåå¤ä¼šå±•å¼€æˆä¸‹é¢è¡¨è¾¾å¼ï¼Œå…¶ä¸­ $element è¢«æ¢æˆç›¸åº”è¢«æ•è·çš„è¡¨è¾¾å¼
                v.push(format!("{}", $element));
            )*

            v
        }
    };
}

fn main() {
    let s = vec_strs![1, "a", true, 3.14159f32];
    assert_eq!(s, &["1", "a", "true", "3.14159"]);
}
```
#### å…ƒå˜é‡è¡¨è¾¾å¼
transcriber4 å¯ä»¥åŒ…å«æ‰€è°“çš„å…ƒå˜é‡è¡¨è¾¾ (metavariable expressions)ã€‚
å¯ä»¥ä½¿ç”¨ä»¥ä¸‹è¡¨è¾¾å¼ï¼ˆå…¶ä¸­ ident æ˜¯æ‰€ç»‘å®šçš„å…ƒå˜é‡çš„åç§°ï¼Œè€Œ depth æ˜¯æ•´å‹å­—é¢å€¼ï¼‰ï¼š
```rs
${count(ident)}ï¼šæœ€é‡Œå±‚åå¤ $ident çš„æ€»æ¬¡æ•°ï¼Œç›¸å½“äº ${count(ident, 0)}
${count(identï¼Œdepth)}ï¼šç¬¬ depth å±‚åå¤ $ident çš„æ¬¡æ•°
${index()}ï¼šæœ€é‡Œå±‚åå¤çš„å½“å‰åå¤çš„ç´¢å¼•ï¼Œç›¸å½“äº ${index(0)}
${index(depth)}ï¼šåœ¨ç¬¬ depth å±‚å¤„å½“å‰åå¤çš„ç´¢å¼•ï¼Œå‘å¤–è®¡æ•°
${length()}ï¼šæœ€é‡Œå±‚åå¤çš„é‡å¤æ¬¡æ•°ï¼Œç›¸å½“äº ${length(0)}
${length(depth)}ï¼šåœ¨ç¬¬ depth å±‚åå¤çš„æ¬¡æ•°ï¼Œå‘å¤–è®¡æ•°
${ignore(ident)}ï¼šç»‘å®š $ident è¿›è¡Œé‡å¤ï¼Œå¹¶å±•å¼€æˆç©º
$$ï¼šå±•å¼€ä¸ºå•ä¸ª $ï¼Œè¿™ä¼šæœ‰æ•ˆåœ°è½¬ä¹‰ $ æ ‡è®°ï¼Œå› æ­¤å®ƒä¸ä¼šè¢«å±•å¼€ï¼ˆè½¬å†™ï¼‰

```

### å®æˆ˜ç¯‡
#### æ„å»ºè¿‡ç¨‹
```rs
let fib = recurrence![a[n] = 0, 1, ..., a[n-1] + a[n-2]];

for e in fib.take(10) { println!("{}", e) }
```
ä»¥æ­¤ä¸ºåŸºç‚¹ï¼Œæˆ‘ä»¬å¯ä»¥å‘å®çš„å®šä¹‰è¿ˆå‡ºç¬¬ä¸€æ­¥ï¼Œ å³ä¾¿åœ¨æ­¤æ—¶æˆ‘ä»¬å°šä¸äº†è§£è¯¥å®çš„å±•å¼€éƒ¨åˆ†ç©¶ç«Ÿæ˜¯ä»€ä¹ˆæ ·å­ã€‚ æ­¤æ­¥éª¤çš„ç”¨å¤„åœ¨äºï¼Œå¦‚æœåœ¨æ­¤å¤„æ— æ³•æ˜ç¡®å¦‚ä½•è§£æè¾“å…¥è¯­æ³•ï¼Œ é‚£å°±å¯èƒ½æ„å‘³ç€ï¼Œæ•´ä¸ªå®çš„æ„æ€éœ€è¦æ”¹å˜ã€‚
```rs
macro_rules! recurrence {
    ( a[n] = $($inits:expr),+ , ... , $recur:expr ) => { /* ... */ };
}

```
- ä¸€æ®µå­—é¢æ ‡è®°åºåˆ—ï¼Œa [ n ] = ï¼›
- ä¸€æ®µ é‡å¤ çš„åºåˆ—ï¼ˆ$( ... )ï¼‰ï¼Œå…¶å†…å…ƒç´ ç”±,åˆ†éš”ï¼Œå…è®¸é‡å¤ä¸€æˆ–å¤šæ¬¡ï¼ˆ + ï¼‰ï¼› é‡å¤çš„å†…å®¹å…è®¸ï¼šä¸€ä¸ªæœ‰æ•ˆçš„ è¡¨è¾¾å¼ï¼Œå®ƒå°†è¢«æ•è·è‡³ å…ƒå˜é‡ inits ($inits:expr)
- åˆä¸€æ®µå­—é¢æ ‡è®°åºåˆ— , ... ,ï¼›
- ä¸€ä¸ªæœ‰æ•ˆçš„ è¡¨è¾¾å¼ï¼Œå°†è¢«æ•è·è‡³ å…ƒå˜é‡ recur ($recur:expr)ã€‚

#### å¯¼å‡ºå®
```rs
#[macro_export]
macro_rules! count_exprs { /* */  }

#[macro_export]
macro_rules! recurrence { /* */ }
```
### ç»†èŠ‚
#### ç‰‡æ®µåˆ†ç±»ç¬¦
- block
- expr
- ident
- item
- lifetime
- literal
- meta
- pat
- pat_param
- path
- stmt
- tt
- ty
- vis
##### block
å— (block) ç”± { å¼€å§‹ï¼Œæ¥ç€æ˜¯ä¸€äº›è¯­å¥ï¼Œæœ€åæ˜¯å¯é€‰çš„è¡¨è¾¾å¼ï¼Œç„¶åä»¥ } ç»“æŸã€‚ å—çš„ç±»å‹è¦ä¹ˆæ˜¯æœ€åçš„å€¼è¡¨è¾¾å¼ç±»å‹ï¼Œè¦ä¹ˆæ˜¯ () ç±»å‹ã€‚
```rs
macro_rules! blocks {
    ($($block:block)*) => ();
}

blocks! {
    {}
    {
        let zig;
    }
    { 2 }
}
fn main() {}
```
##### expr
expr åˆ†ç±»ç¬¦ç”¨äºåŒ¹é…ä»»ä½•å½¢å¼çš„è¡¨è¾¾å¼ (expression)ã€‚
```rs
macro_rules! expressions {
    ($($expr:expr)*) => ();
}

expressions! {
    "literal"
    funcall()
    future.await
    break 'foo bar
}
fn main() {}
```
##### ident
ident åˆ†ç±»ç¬¦ç”¨äºåŒ¹é…ä»»ä½•å½¢å¼çš„æ ‡è¯†ç¬¦ (identifier) æˆ–è€…å…³é”®å­—ã€‚ ã€‚
```rs
macro_rules! idents {
    ($($ident:ident)*) => ();
}

idents! {
    // _ <- `_` ä¸æ˜¯æ ‡è¯†ç¬¦ï¼Œè€Œæ˜¯ä¸€ç§æ¨¡å¼
    foo
    async
    O_________O
    _____O_____
}
fn main() {}
```
##### item
item åˆ†ç±»ç¬¦åªåŒ¹é… Rust çš„ item çš„ å®šä¹‰ (definitions) ï¼Œ ä¸ä¼šåŒ¹é…æŒ‡å‘ item çš„æ ‡è¯†ç¬¦ (identifiers)ã€‚ä¾‹å­ï¼š
```rs
macro_rules! items {
    ($($item:item)*) => ();
}

items! {
    struct Foo;
    enum Bar {
        Baz
    }
    impl Foo {}
    /*...*/
}
fn main() {}
```

##### lifetime
lifetime åˆ†ç±»ç¬¦ç”¨äºåŒ¹é…ç”Ÿå‘½å‘¨æœŸæ³¨è§£æˆ–è€…æ ‡ç­¾ (lifetime or label)ã€‚ å®ƒä¸ ident å¾ˆåƒï¼Œä½†æ˜¯ lifetime ä¼šåŒ¹é…åˆ°å‰ç¼€ '' ã€‚
```rs
macro_rules! lifetimes {
    ($($lifetime:lifetime)*) => ();
}

lifetimes! {
    'static
    'shiv
    '_
}
fn main() {}
```
##### literal
literal åˆ†ç±»ç¬¦ç”¨äºåŒ¹é…å­—é¢è¡¨è¾¾å¼ (literal expression)ã€‚
```rs
macro_rules! literals {
    ($($literal:literal)*) => ();
}

literals! {
    -1
    "hello world"
    2.3
    b'b'
    true
}
fn main() {}
```
##### meta
meta åˆ†ç±»ç¬¦ç”¨äºåŒ¹é…å±æ€§ (attribute)ï¼Œ å‡†ç¡®åœ°è¯´æ˜¯å±æ€§é‡Œé¢çš„å†…å®¹ã€‚é€šå¸¸ä½ ä¼šåœ¨ #[$meta:meta] æˆ– #![$meta:meta] æ¨¡å¼åŒ¹é…ä¸­ çœ‹åˆ°è¿™ä¸ªåˆ†ç±»ç¬¦ã€‚
```rs
macro_rules! metas {
    ($($meta:meta)*) => ();
}

metas! {
    ASimplePath
    super::man
    path = "home"
    foo(bar)
}
fn main() {}
```
##### pat
pat åˆ†ç±»ç¬¦ç”¨äºåŒ¹é…ä»»ä½•å½¢å¼çš„æ¨¡å¼ (pattern)ï¼ŒåŒ…æ‹¬ 2021 edition å¼€å§‹çš„ or-patternsã€‚

```rs
macro_rules! patterns {
    ($($pat:pat)*) => ();
}

patterns! {
    "literal"
    _
    0..5
    ref mut PatternsAreNice
    0 | 1 | 2 | 3 
}
fn main() {}
```
##### pat_param
or-patterns æ¨¡å¼å¼€å§‹åº”ç”¨ï¼Œè¿™è®© pat åˆ†ç±»ç¬¦ä¸å†å…è®¸è·Ÿéš |ã€‚
```rs
macro_rules! patterns {
    (pat: $pat:pat) => {
        println!("pat: {}", stringify!($pat));
    };
    (pat_param: $($pat:pat_param)|+) => {
        $( println!("pat_param: {}", stringify!($pat)); )+
    };
}
fn main() {
    patterns! {
       pat: 0 | 1 | 2 | 3
    }
    patterns! {
       pat_param: 0 | 1 | 2 | 3
    }
}
```
##### path
path åˆ†ç±»ç¬¦ç”¨äºåŒ¹é…ç±»å‹ä¸­çš„è·¯å¾„ (TypePath)ã€‚è¿™åŒ…æ‹¬å‡½æ•°å¼çš„ trait å½¢å¼ã€‚
```rs
macro_rules! paths {
    ($($path:path)*) => ();
}

paths! {
    ASimplePath
    ::A::B::C::D
    G::<eneri>::C
    FnMut(u32) -> ()
}
fn main() {}
```
##### stmt
stmt åˆ†ç±»ç¬¦åªåŒ¹é…çš„ è¯­å¥ (statement)ã€‚ é™¤é item è¯­å¥è¦æ±‚ç»“å°¾æœ‰åˆ†å·ï¼Œå¦åˆ™ ä¸ä¼š åŒ¹é…è¯­å¥æœ€åçš„åˆ†å·ã€‚
```rs
macro_rules! statements {
    ($($stmt:stmt)*) => ($($stmt)*);
}

fn main() {
    statements! {
        struct Foo;
        fn foo() {}
        let zig = 3
        if true {} else {}
        {}
    }
}
```
##### tt
tt åˆ†ç±»ç¬¦ç”¨äºåŒ¹é…æ ‡è®°æ ‘ (TokenTree)ã€‚ å¦‚æœä½ æ˜¯æ–°æ‰‹ï¼Œå¯¹æ ‡è®°æ ‘ä¸äº†è§£ï¼Œé‚£ä¹ˆéœ€è¦å›é¡¾æœ¬ä¹¦ æ ‡è®°æ ‘ ä¸€èŠ‚ã€‚tt åˆ†ç±»ç¬¦æ˜¯æœ€æœ‰ä½œç”¨çš„åˆ†ç±»ç¬¦ä¹‹ä¸€ï¼Œå› ä¸ºå®ƒèƒ½åŒ¹é…å‡ ä¹æ‰€æœ‰ä¸œè¥¿ï¼Œ è€Œä¸”èƒ½å¤Ÿè®©ä½ åœ¨ä½¿ç”¨å®ä¹‹åæ£€æŸ¥ (inspect) åŒ¹é…çš„å†…å®¹ã€‚

##### ty
ty åˆ†ç±»ç¬¦ç”¨äºåŒ¹é…ä»»ä½•å½¢å¼çš„ç±»å‹è¡¨è¾¾å¼ (type expression)ã€‚
```rs
macro_rules! types {
    ($($type:ty)*) => ();
}

types! {
    foo::bar
    bool
    [u8]
    impl IntoIterator<Item = u32>
}
fn main() {}
```
##### vis
vis åˆ†ç±»ç¬¦ä¼šåŒ¹é… å¯èƒ½ä¸ºç©º å¯è§æ€§ä¿®é¥°ç¬¦ (Visibility qualifier)ã€‚
```rs
macro_rules! visibilities {
    //         âˆ¨~~æ³¨æ„è¿™ä¸ªé€—å·ï¼Œ`vis` åˆ†ç±»ç¬¦è‡ªèº«ä¸ä¼šåŒ¹é…åˆ°é€—å·
    ($($vis:vis,)*) => ();
}

visibilities! {
    , // æ²¡æœ‰ vis ä¹Ÿè¡Œï¼Œå› ä¸º $vis éšå¼åŒ…å« `?` çš„æƒ…å†µ
    pub,
    pub(crate),
    pub(in super),
    pub(in some_path),
}
fn main() {}
```
#### å†è°ˆå…ƒå˜é‡ä¸å®å±•å¼€

#### å…ƒå˜é‡è¡¨è¾¾å¼
##### Dollar Dollar ($$)

```rs
$$ è¡¨è¾¾å¼å±•å¼€ä¸ºå•ä¸ª $ï¼Œå®é™…ä¸Šä½¿å…¶æˆä¸ºè½¬ä¹‰çš„ $ã€‚è¿™è®©å£°æ˜å®å®ç”Ÿæˆæ–°çš„å£°æ˜å®ã€‚
#![feature(macro_metavar_expr)]

macro_rules! foo {
    () => {
        macro_rules! bar {
            ( $$( $$any:tt )* ) => { $$( $$any )* };
        }
    };
}

foo!();
bar!();
```

##### count(ident, depth)

count è¡¨è¾¾å¼å±•å¼€æˆå…ƒå˜é‡ $ident åœ¨ç»™å®šåå¤æ·±åº¦çš„åå¤æ¬¡æ•°ã€‚

- ident å‚æ•°å¿…é¡»æ˜¯è§„åˆ™ä½œç”¨åŸŸä¸­å£°æ˜çš„å…ƒå˜é‡
- depth å‚æ•°å¿…é¡»æ˜¯å€¼å°äºæˆ–ç­‰äºå…ƒå˜é‡ $ident å‡ºç°çš„æœ€å¤§åå¤æ·±åº¦çš„æ•´å‹å­—é¢å€¼
- count(ident, depth) å±•å¼€æˆä¸å¸¦åç¼€çš„æ•´å‹å­—é¢å€¼æ ‡è®°
- count(ident) æ˜¯ count(ident, 0) çš„ç®€
```rs
#![feature(macro_metavar_expr)]

macro_rules! foo {
    ( $( $outer:ident ( $( $inner:ident ),* ) ; )* ) => {
        println!("count(outer, 0): $outer repeats {} times", ${count(outer)});
        println!("count(inner, 0): The $inner repetition repeats {} times in the outer repetition", ${count(inner, 0)});
        println!("count(inner, 1): $inner repeats {} times in the inner repetitions", ${count(inner, 1)});
    };
}

fn main() {
    foo! {
        outer () ;
        outer ( inner , inner ) ;
        outer () ;
        outer ( inner ) ;
    };
}
```

##### index(depth)
index(depth) è¡¨è¾¾å¼å±•å¼€ä¸ºç»™å®šåå¤æ·±åº¦ä¸‹ï¼Œå½“å‰çš„è¿­ä»£ç´¢å¼•ã€‚

- depth å‚æ•°è¡¨æ˜åœ¨ç¬¬å‡ å±‚åå¤ï¼Œè¿™ä¸ªæ•°å­—ä»æœ€å†…å±‚åå¤è°ƒç”¨è¡¨è¾¾å¼å¼€å§‹å‘å¤–è®¡ç®—
- index(depth) å±•å¼€æˆä¸å¸¦åç¼€çš„æ•´å‹å­—é¢å€¼æ ‡è®°
- index() æ˜¯ index(0) çš„ç®€å†™
```rs

#![feature(macro_metavar_expr)]

macro_rules! attach_iteration_counts {
    ( $( ( $( $inner:ident ),* ) ; )* ) => {
        ( $(
            $((
                stringify!($inner),
                ${index(1)}, // è¿™æŒ‡çš„æ˜¯å¤–å±‚åå¤
                ${index()}  // è¿™æŒ‡çš„æ˜¯å†…å±‚åå¤ï¼Œç­‰ä»·äº `index(0)`
            ),)*
        )* )
    };
}

fn main() {
    let v = attach_iteration_counts! {
        ( hello ) ;
        ( indices , of ) ;
        () ;
        ( these, repetitions ) ;
    };
    println!("{v:?}");
}
```
##### length(depth)
length(depth) è¡¨è¾¾å¼å±•å¼€ä¸ºåœ¨ç»™å®šåå¤æ·±åº¦çš„è¿­ä»£æ¬¡æ•°ã€‚

- depth å‚æ•°è¡¨ç¤ºåœ¨ç¬¬å‡ å±‚åå¤ï¼Œè¿™ä¸ªæ•°å­—ä»æœ€å†…å±‚åå¤è°ƒç”¨è¡¨è¾¾å¼å¼€å§‹å‘å¤–è®¡ç®—
- length(depth) å±•å¼€æˆä¸å¸¦åç¼€çš„æ•´å‹å­—é¢å€¼æ ‡è®°
- length() æ˜¯ length(0) çš„ç®€å†™
```rs

#![feature(macro_metavar_expr)]

macro_rules! lets_count {
    ( $( $outer:ident ( $( $inner:ident ),* ) ; )* ) => {
        $(
            $(
                println!(
                    "'{}' in inner iteration {}/{} with '{}' in outer iteration {}/{} ",
                    stringify!($inner), ${index()}, ${length()},
                    stringify!($outer), ${index(1)}, ${length(1)},
                );
            )*
        )*
    };
}

fn main() {
    lets_count!(
        many (small , things) ;
        none () ;
        exactly ( one ) ;
    );
}
```

##### ignore(ident)

ignore(ident) è¡¨è¾¾å¼å±•å¼€ä¸ºç©ºï¼Œè¿™ä½¿å¾—åœ¨æ— éœ€å®é™…å±•å¼€å…ƒå˜é‡çš„æ—¶å€™ï¼Œåƒå…ƒå˜é‡åå¤å±•å¼€ç›¸åŒæ¬¡æ•°çš„æŸäº›å†…å®¹ã€‚
```rs
#![feature(macro_metavar_expr)]

macro_rules! repetition_tuples {
    ( $( ( $( $inner:ident ),* ) ; )* ) => {
        ($(
            $(
                (
                    ${index()},
                    ${index(1)}
                    ${ignore(inner)} // without this metavariable expression, compilation would fail
                ),
            )*
        )*)
    };
}

fn main() {
    let tuple = repetition_tuples!(
        ( one, two ) ;
        () ;
        ( one ) ;
        ( one, two, three ) ;
    );
    println!("{tuple:?}");
}
```

#### è°ƒè¯•
##### trace_macros!
æœ€æœ‰ç”¨çš„æ˜¯ trace_macros!ï¼Œåœ¨æ¯æ¬¡å£°æ˜å®å±•å¼€å‰ï¼Œå®ƒæŒ‡ç¤ºç¼–è¯‘å™¨è®°å½•ä¸‹å£°æ˜å®çš„è°ƒç”¨ä¿¡æ¯ã€‚
```rs
#![feature(trace_macros)]

macro_rules! each_tt {
    () => {};
    ($_tt:tt $($rest:tt)*) => {each_tt!($($rest)*);};
}

each_tt!(foo bar baz quux);
trace_macros!(true);
each_tt!(spim wak plee whum);
trace_macros!(false);
each_tt!(trom qlip winp xod);

```

##### log_syntax!

å¦ä¸€æœ‰ç”¨çš„å®æ˜¯ log_syntax!ã€‚å®ƒå°†ä½¿å¾—ç¼–è¯‘å™¨è¾“å‡ºæ‰€æœ‰ç»è¿‡ç¼–è¯‘å™¨å¤„ç†çš„æ ‡è®°ã€‚

```rs
#![feature(log_syntax)]

macro_rules! sing {
    () => {};
    ($tt:tt $($rest:tt)*) => {log_syntax!($tt); sing!($($rest)*);};
}

sing! {
    ^ < @ < . @ *
    '\x08' '{' '"' _ # ' '
    - @ '$' && / _ %
    ! ( '\t' @ | = >
    ; '\x08' '\'' + '$' ? '\x7f'
    , # '"' ~ | ) '\x07'
}

```

###### macro_railroad lib

#### ä½œç”¨åŸŸ

ä¸ Rust è¯­è¨€å…¶ä½™æ‰€æœ‰éƒ¨åˆ†éƒ½ä¸åŒçš„æ˜¯ï¼Œå‡½æ•°å¼å®åœ¨å­æ¨¡å—ä¸­ä»ç„¶å¯è§ã€‚
å®åœ¨å®šä¹‰ä¹‹åå¯è§
```rs
mod a {
    // X!(); // undefined
}
macro_rules! X { () => {}; }
mod a {
    X!(); // defined
}
mod b {
    X!(); // defined
}
mod c {
    X!(); // defined
}
fn main() {}
```
##### #[macro_use] å±æ€§

è¿™ä¸ªå±æ€§æ”¾ç½®åœ¨å®å®šä¹‰æ‰€åœ¨çš„æ¨¡å—å‰ æˆ–è€… extern crate è¯­å¥å‰ã€‚

åœ¨æ¨¡å—å‰åŠ ä¸Š #[macro_use] å±æ€§ï¼šå¯¼å‡ºè¯¥æ¨¡å—å†…çš„æ‰€æœ‰å®ï¼Œ ä»è€Œè®©å¯¼å‡ºçš„å®åœ¨æ‰€å®šä¹‰çš„æ¨¡å—ç»“æŸä¹‹åä¾ç„¶å¯ç”¨ã€‚

#### å¯¼å…¥/å¯¼å‡º

### æ¨¡å¼
#### å›è°ƒ
```rs
macro_rules! call_with_larch {
    ($callback:ident) => { $callback!(larch) };
}

macro_rules! expand_to_larch {
    () => { larch };
}

macro_rules! recognize_tree {
    (larch) => { println!("#1, the Larch.") };
    (redwood) => { println!("#2, the Mighty Redwood.") };
    (fir) => { println!("#3, the Fir.") };
    (chestnut) => { println!("#4, the Horse Chestnut.") };
    (pine) => { println!("#5, the Scots Pine.") };
    ($($other:tt)*) => { println!("I don't know; some kind of birch maybe?") };
}

fn main() {
    recognize_tree!(expand_to_larch!()); // æ— æ³•ç›´æ¥ä½¿ç”¨ `expand_to_larch!` çš„å±•å¼€ç»“æœ
    call_with_larch!(recognize_tree);    // å›è°ƒå°±æ˜¯ç»™å¦ä¸€ä¸ªå®ä¼ å…¥å®çš„åç§° (`ident`)ï¼Œè€Œä¸æ˜¯å®çš„ç»“æœ
}

// æ‰“å°ç»“æœï¼š
// I don't know; some kind of birch maybe?
// #1, the Larch. 
```

####  å¢é‡å¼ TT â€œæ’•å’¬æœºâ€
```rs
macro_rules! mixed_rules {
    () => {};
    (trace $name:ident; $($tail:tt)*) => {
        {
            println!(concat!(stringify!($name), " = {:?}"), $name);
            mixed_rules!($($tail)*);
        }
    };
    (trace $name:ident = $init:expr; $($tail:tt)*) => {
        {
            let $name = $init;
            println!(concat!(stringify!($name), " = {:?}"), $name);
            mixed_rules!($($tail)*);
        }
    };
}

```
â€œæ ‡è®°æ ‘æ’•å’¬æœºâ€ (TT muncher) æ˜¯ä¸€ç§é€’å½’å®ï¼Œå…¶å·¥ä½œæœºåˆ¶æœ‰èµ–äºå¯¹è¾“å…¥çš„é¡ºæ¬¡ã€é€æ­¥å¤„ç† (incrementally processing) ã€‚å¤„ç†è¿‡ç¨‹çš„æ¯ä¸€æ­¥ä¸­ï¼Œå®ƒéƒ½å°†åŒ¹é…å¹¶ç§»é™¤ï¼ˆâ€œæ’•å’¬â€æ‰ï¼‰è¾“å…¥å¤´éƒ¨ (start) çš„ä¸€åˆ—æ ‡è®° (tokens)ï¼Œå¾—åˆ°ä¸€äº›ä¸­é—´ç»“æœï¼Œç„¶åå†é€’å½’åœ°å¤„ç†è¾“å…¥å‰©ä¸‹çš„å°¾éƒ¨ã€‚

- ä½ åªèƒ½åŒ¹é… macro_rules! æ•è·åˆ°çš„å­—é¢å€¼å’Œè¯­æ³•ç»“æ„ã€‚
- ä½ æ— æ³•åŒ¹é…ä¸æˆå¯¹çš„æ ‡è®°ç»„ (unbalanced group) ã€‚

#### å†…ç”¨è§„åˆ™

### æ„ä»¶

#### AST å¼ºåˆ¶è½¬æ¢
åœ¨æ›¿æ¢ tt æ—¶ï¼ŒRust çš„è§£æå™¨å¹¶ä¸ååˆ†å¯é ã€‚ å½“å®ƒæœŸæœ›å¾—åˆ°æŸç±»ç‰¹å®šçš„è¯­æ³•ç»“æ„æ—¶ï¼Œ å¦‚æœæ‘†åœ¨å®ƒé¢å‰çš„æ˜¯ä¸€å¨æ›¿æ¢åçš„ tt æ ‡è®°ï¼Œå°±æœ‰å¯èƒ½å‡ºç°é—®é¢˜ã€‚ è§£æå™¨å¸¸å¸¸ç›´æ¥é€‰æ‹©æ”¾å¼ƒè§£æï¼Œè€Œéå°è¯•å»è§£æå®ƒä»¬ã€‚ åœ¨è¿™ç±»æƒ…å†µä¸­ï¼Œå°±è¦ç”¨åˆ° AST å¼ºåˆ¶è½¬æ¢ï¼ˆç®€ç§°â€œå¼ºè½¬â€ï¼‰ã€‚
```rs
#![allow(dead_code)]

macro_rules! as_expr { ($e:expr) => {$e} }
macro_rules! as_item { ($i:item) => {$i} }
macro_rules! as_pat  { ($p:pat)  => {$p} }
macro_rules! as_stmt { ($s:stmt) => {$s} }
macro_rules! as_ty   { ($t:ty)   => {$t} }

fn main() {
    as_item!{struct Dummy;}

    as_stmt!(let as_pat!(_): as_ty!(_) = as_expr!(42));
}
```
#### è®¡æ•°
##### åå¤æ›¿æ¢
åœ¨å®ä¸­è®¡æ•°æ˜¯ä¸€é¡¹è®©äººåƒæƒŠçš„éš¾æçš„æ´»å„¿ã€‚ æœ€ç®€å•çš„æ–¹å¼æ˜¯é‡‡ç”¨åå¤æ›¿æ¢
```rs
macro_rules! replace_expr {
    ($_t:tt $sub:expr) => {$sub};
}

macro_rules! count_tts {
    ($($tts:tt)*) => {0usize $(+ replace_expr!($tts 1usize))*};
}

fn main() {
    assert_eq!(count_tts!(0 1 2), 3);
}
```
##### é€’å½’
```rs
macro_rules! count_tts {
    () => {0usize};
    ($_head:tt $($tail:tt)*) => {1usize + count_tts!($($tail)*)};
}

fn main() {
    assert_eq!(count_tts!(0 1 2), 3);
}
```
##### åˆ‡ç‰‡é•¿åº¦
ç¬¬ä¸‰ç§æ–¹æ³•ï¼Œæ˜¯å¸®åŠ©ç¼–è¯‘å™¨æ„å»ºä¸€ä¸ªæ·±åº¦è¾ƒå°çš„ AST ï¼Œä»¥é¿å…æ ˆæº¢å‡ºã€‚ å¯ä»¥é€šè¿‡æ„é€ æ•°ç»„ï¼Œå¹¶è°ƒç”¨å…¶ len æ–¹æ³•æ¥åšåˆ°ã€‚(slice length)
```rs
macro_rules! replace_expr {
    ($_t:tt $sub:expr) => {$sub};
}

macro_rules! count_tts {
    ($($tts:tt)*) => {<[()]>::len(&[$(replace_expr!($tts ())),*])};
}

fn main() {
    assert_eq!(count_tts!(0 1 2), 3);

    const N: usize = count_tts!(0 1 2);
    let array = [0; N];
    println!("{:?}", array);
}
```
##### æšä¸¾è®¡æ•°
å½“ä½ éœ€è¦ç»Ÿè®¡ äº’ä¸ç›¸åŒçš„æ ‡è¯†ç¬¦ çš„æ•°é‡æ—¶ï¼Œ å¯ä»¥åˆ©ç”¨æšä¸¾ä½“çš„ numeric cast åŠŸèƒ½æ¥è¾¾åˆ°ç»Ÿè®¡æˆå‘˜ï¼ˆå³æ ‡è¯†ç¬¦ï¼‰ä¸ªæ•°ã€‚
```rs
macro_rules! count_idents {
    ($($idents:ident),* $(,)*) => {
        {
            #[allow(dead_code, non_camel_case_types)]
            enum Idents { $($idents,)* __CountIdentsLast } 
            const COUNT: u32 = Idents::__CountIdentsLast as u32;
            COUNT
        }
    };
}

fn main() {
    const COUNT: u32 = count_idents!(A, B, C);
    assert_eq!(COUNT, 3);
}
```

##### bit twiddling

```rs
macro_rules! count_tts {
    () => { 0 };
    ($odd:tt $($a:tt $b:tt)*) => { (count_tts!($($a)*) << 1) | 1 };
    ($($a:tt $even:tt)*) => { count_tts!($($a)*) << 1 };
}

fn main() {
    assert_eq!(count_tts!(0 1 2), 3);
}
```
#### è§£æ Rust

é‡ç‚¹åœ¨äºå®çš„åŒ¹é…æ–¹å¼ (matchers) ï¼›å±•å¼€çš„éƒ¨åˆ† ï¼ˆ Reference é‡Œä½¿ç”¨çš„æœ¯è¯­å«åš transcribers ï¼‰

```rs
macro_rules! function_item_matcher {
    (

        $( #[$meta:meta] )*
    //  ^~~~attributes~~~~^
        $vis:vis fn $name:ident ( $( $arg_name:ident : $arg_ty:ty ),* $(,)? )
    //                          ^~~~~~~~~~~~~~~~argument list!~~~~~~~~~~~~~~^
            $( -> $ret_ty:ty )?
    //      ^~~~return type~~~^
            { $($tt:tt)* }
    //      ^~~~~body~~~~^
    ) => {
        $( #[$meta] )*
        $vis fn $name ( $( $arg_name : $arg_ty ),* ) $( -> $ret_ty )? { $($tt)* }
    }
}

function_item_matcher!(
   #[inline]
   #[cold]
   pub fn foo(bar: i32, baz: i32, ) -> String {
       format!("{} {}", bar, baz)
   }
);

fn main() {
    assert_eq!(foo(13, 37), "13 37");
}
```
##### ç»“æ„ä½“

```rs
macro_rules! struct_item_matcher {
    // Unit-Struct
    (
        $( #[$meta:meta] )*
    //  ^~~~attributes~~~~^
        $vis:vis struct $name:ident;
    ) => {
        $( #[$meta] )*
        $vis struct $name;
    };

    // Tuple-Struct
    (
        $( #[$meta:meta] )*
    //  ^~~~attributes~~~~^
        $vis:vis struct $name:ident (
            $(
                $( #[$field_meta:meta] )*
    //          ^~~~field attributes~~~~^
                $field_vis:vis $field_ty:ty
    //          ^~~~~~a single field~~~~~~^
            ),*
        $(,)? );
    ) => {
        $( #[$meta] )*
        $vis struct $name (
            $(
                $( #[$field_meta] )*
                $field_vis $field_ty
            ),*
        );
    };

    // Named-Struct
    (
        $( #[$meta:meta] )*
    //  ^~~~attributes~~~~^
        $vis:vis struct $name:ident {
            $(
                $( #[$field_meta:meta] )*
    //          ^~~~field attributes~~~!^
                $field_vis:vis $field_name:ident : $field_ty:ty
    //          ^~~~~~~~~~~~~~~~~a single field~~~~~~~~~~~~~~~^
            ),*
        $(,)? }
    ) => {
        $( #[$meta] )*
        $vis struct $name {
            $(
                $( #[$field_meta] )*
                $field_vis $field_name : $field_ty
            ),*
        }
    }
}

struct_item_matcher!(
   #[allow(dead_code)]
   #[derive(Copy, Clone)]
   pub(crate) struct Foo { 
      pub bar: i32,
      baz: &'static str,
      qux: f32
   }
);
struct_item_matcher!(
   #[derive(Copy, Clone)]
   pub(crate) struct Bar;
);
struct_item_matcher!(
   #[derive(Clone)]
   pub(crate) struct Baz (i32, pub f32, String);
);
fn main() {
   let _: Foo = Foo { bar: 42, baz: "macros can be nice", qux: 3.14, };
   let _: Bar = Bar;
   let _: Baz = Baz(2, 0.1234, String::new());
}
```

##### æšä¸¾ä½“
```rs
macro_rules! enum_item_matcher {
    // tuple variant
    (@variant $variant:ident (
        $(
            $( #[$field_meta:meta] )*
    //      ^~~~field attributes~~~~^
            $field_vis:vis $field_ty:ty
    //      ^~~~~~a single field~~~~~~^
        ),* $(,)?
    //âˆ¨~~rest of input~~âˆ¨
    ) $(, $($tt:tt)* )? ) => {

        // process rest of the enum
        $( enum_item_matcher!(@variant $( $tt )*); )?
    };

    // named variant
    (@variant $variant:ident {
        $(
            $( #[$field_meta:meta] )*
    //      ^~~~field attributes~~~!^
            $field_vis:vis $field_name:ident : $field_ty:ty
    //      ^~~~~~~~~~~~~~~~~a single field~~~~~~~~~~~~~~~^
        ),* $(,)?
    //âˆ¨~~rest of input~~âˆ¨
    } $(, $($tt:tt)* )? ) => {
        // process rest of the enum
        $( enum_item_matcher!(@variant $( $tt )*); )?
    };

    // unit variant
    (@variant $variant:ident $(, $($tt:tt)* )? ) => {
        // process rest of the enum
        $( enum_item_matcher!(@variant $( $tt )*); )?
    };

    // trailing comma
    (@variant ,) => {};
    // base case
    (@variant) => {};

    // entry point
    (
        $( #[$meta:meta] )*
        $vis:vis enum $name:ident {
            $($tt:tt)*
        }
    ) => {
        enum_item_matcher!(@variant $($tt)*);
    };
}

enum_item_matcher!(
    #[derive(Copy, Clone)]
    pub(crate) enum Foo {
        Bar,
        Baz,
    }
);
enum_item_matcher!(
    #[derive(Copy, Clone)]
    pub(crate) enum Bar {
        Foo(i32, f32),
        Bar,
        Baz(),
    }
);
enum_item_matcher!(
    #[derive(Clone)]
    pub(crate) enum Baz {}
);

fn main() {}
```
## è¿‡ç¨‹å®
### æ€è·¯
è¿‡ç¨‹å®é‡‡ç”¨ Rust å‡½æ•°çš„å½¢å¼ï¼Œæ¥å—ä¸€ä¸ªï¼ˆæˆ–ä¸¤ä¸ªï¼‰æ ‡è®°æµå¹¶è¾“å‡ºä¸€ä¸ªæ ‡è®°æµã€‚
è¿‡ç¨‹å®çš„æ ¸å¿ƒåªæ˜¯ä¸€ä¸ªä» proc-macro crate type è¿™ç§ç±»å‹çš„åº“ä¸­æ‰€å¯¼å‡ºçš„å…¬æœ‰å‡½æ•°ï¼Œå› æ­¤å½“ç¼–å†™å¤šä¸ªè¿‡ç¨‹å®æ—¶ï¼Œä½ å¯ä»¥å°†å®ƒä»¬å…¨éƒ¨æ”¾åœ¨ä¸€ä¸ª crate ä¸­
```toml
[lib]
proc-macro = true

```

proc-macro ç±»å‹çš„ crate ä¼šéšå¼é“¾æ¥åˆ°ç¼–è¯‘å™¨æä¾›çš„ proc_macro åº“ï¼Œ proc_macro åº“åŒ…å«äº†å¼€å‘è¿‡ç¨‹å®æ‰€éœ€çš„æ‰€æœ‰å†…å®¹ï¼Œå¹¶ä¸”å®ƒå…¬å¼€äº†ä¸¤ä¸ªæœ€é‡è¦çš„ç±»å‹ï¼š
1. TokenStreamï¼šå®ƒè¡¨ç¤ºæˆ‘ä»¬æ‰€ç†ŸçŸ¥çš„æ ‡è®°æ ‘
2. Spanï¼šå®ƒè¡¨ç¤ºæºä»£ç çš„ä¸€éƒ¨åˆ†ï¼Œä¸»è¦ç”¨äºé”™è¯¯ä¿¡æ¯çš„æŠ¥å‘Šå’Œå«ç”Ÿæ€§ï¼Œæ›´å¤šä¿¡æ¯è¯·é˜…è¯» å«ç”Ÿæ€§å’Œ Spans ä¸€ç« 



è¿‡ç¨‹å®å®é™…ä¸Šå­˜åœ¨ä¸‰ç§ä¸åŒçš„ç±»å‹ï¼Œæ¯ç§ç±»å‹çš„æ€§è´¨éƒ½ç•¥æœ‰ä¸åŒã€‚1

- å‡½æ•°å¼ï¼šå®ç° $nameï¼$input åŠŸèƒ½çš„å®
```rs
#[proc_macro]
pub fn name(input: TokenStream) -> TokenStream {
    TokenStream::new()
}
```
- å±æ€§å¼ï¼šå®ç° #[$input] åŠŸèƒ½çš„å±æ€§
```rs
#[proc_macro_attribute]
pub fn name(attr: TokenStream, input: TokenStream) -> TokenStream {
    TokenStream::new()
}
```
- derive å¼ï¼šå®ç° #[derive($name)] åŠŸèƒ½çš„å±æ€§
```rs
#[proc_macro_derive(Name)]
pub fn my_derive(input: TokenStream) -> TokenStream {
    TokenStream::new()
} 
```
#### å‡½æ•°å¼è¿‡ç¨‹å®
```rs
use proc_macro::TokenStream;

#[proc_macro]
pub fn tlborm_fn_macro(input: TokenStream) -> TokenStream {
    input
}

```

è¿‡ç¨‹å®æ›´å¼ºå¤§ï¼Œå› ä¸ºå®ƒä»¬å¯ä»¥ä»»æ„ä¿®æ”¹å…¶è¾“å…¥ï¼Œå¹¶ç”Ÿæˆä»»ä½•æ‰€éœ€çš„è¾“å‡ºï¼Œåªè¦è¾“å‡ºåœ¨ Rust çš„è¯­æ³•èŒƒå›´å†…ã€‚
```rs
use tlborm_proc::tlborm_attribute;

fn foo() {
    tlborm_attribute!(be quick; time is mana);
}

```
#### å±æ€§å¼è¿‡ç¨‹å®
å±æ€§å¼è¿‡ç¨‹å®å®šä¹‰äº†å¯æ·»åŠ åˆ°æ¡ç›®çš„çš„æ–°å¤–éƒ¨å±æ€§ã€‚è¿™ç§å®é€šè¿‡ #[attr] æˆ– #[attr(â€¦)] æ–¹å¼è°ƒç”¨ï¼Œå…¶ä¸­ â€¦ æ˜¯ä»»æ„æ ‡è®°æ ‘ã€‚
```rs
use proc_macro::TokenStream;

#[proc_macro_attribute]
pub fn tlborm_attribute(input: TokenStream, annotated_item: TokenStream) -> TokenStream {
    annotated_item
}

```

- ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯å±æ€§åç§°åé¢çš„å¸¦åˆ†éš”ç¬¦çš„æ ‡è®°æ ‘ï¼Œä¸åŒ…æ‹¬å®ƒå‘¨å›´çš„åˆ†éš”ç¬¦ã€‚å¦‚æœåªæœ‰å±æ€§åç§°ï¼ˆå…¶åä¸å¸¦æ ‡è®°æ ‘ï¼Œæ¯”å¦‚ #[attr]ï¼‰ï¼Œåˆ™è¿™ä¸ªå‚æ•°çš„å€¼ä¸ºç©ºã€‚
- ç¬¬äºŒä¸ªå‚æ•°æ˜¯æ·»åŠ äº†è¯¥è¿‡ç¨‹å®å±æ€§çš„æ¡ç›®ï¼Œä½†ä¸åŒ…æ‹¬è¯¥è¿‡ç¨‹å®æ‰€å®šä¹‰çš„å±æ€§ã€‚å› ä¸ºè¿™æ˜¯ä¸€ä¸ª active å±æ€§ï¼Œåœ¨ä¼ é€’ç»™è¿‡ç¨‹å®ä¹‹å‰ï¼Œè¯¥å±æ€§å°†ä»æ¡ç›®ä¸­å‰¥ç¦»å‡ºæ¥ã€‚

#### derive å¼è¿‡ç¨‹å®
derive å¼è¿‡ç¨‹å®1ä¸º derive å±æ€§å®šä¹‰äº†æ–°çš„è¾“å…¥ã€‚è¿™ç§å®é€šè¿‡å°†å…¶åç§°æä¾›ç»™ derive å±æ€§çš„è¾“å…¥æ¥è°ƒç”¨ï¼Œä¾‹å¦‚ #[derive(TlbormDerve)]ã€‚
```rs
use proc_macro::TokenStream;

#[proc_macro_derive(TlbormDerive)]
pub fn tlborm_derive(input: TokenStream) -> TokenStream {
    TokenStream::new()
}

```

derive å®åˆæœ‰ä¸€ç‚¹ç‰¹æ®Šï¼Œå› ä¸ºå®ƒå¯ä»¥æ·»åŠ ä»…åœ¨æ¡ç›®å®šä¹‰èŒƒå›´å†…å¯è§çš„é™„åŠ å±æ€§ã€‚

è¿™äº›å±æ€§è¢«ç§°ä¸ºæ´¾ç”Ÿå®è¾…åŠ©å±æ€§ (derive macro helper attributes) ï¼Œå¹¶ä¸”æ˜¯æƒ°æ€§çš„(inert)ã€‚

è¾…åŠ©å±æ€§çš„ç›®çš„æ˜¯åœ¨æ¯ä¸ªç»“æ„ä½“å­—æ®µæˆ–æšä¸¾ä½“æˆå‘˜çš„åŸºç¡€ä¸Šä¸º derive å®æä¾›é¢å¤–çš„å¯å®šåˆ¶æ€§ã€‚